{
  "js-theory": [
    {
      "id": "ad13c892-6f39-4de0-bdff-45c5939c6978",
      "title": "1. Как создать объект?",
      "data": [
        {
          "id": "text-0-1",
          "contentType": "text",
          "content": "Существует несколько способов это сделать. Вот некоторые из них:"
        },
        {
          "id": "text-0-2",
          "contentType": "text",
          "content": "Литерал объекта:"
        },
        {
          "id": "code-0-1",
          "contentType": "code",
          "content": "const object = {}"
        },
        {
          "id": "text-0-3",
          "contentType": "text",
          "content": "Конструктор объекта (использовать не рекомендуется):"
        },
        {
          "id": "code-0-2",
          "contentType": "code",
          "content": "const object = new Object()"
        },
        {
          "id": "text-0-4",
          "contentType": "text",
          "content": "Метод Object.create()"
        },
        {
          "id": "text-0-5",
          "contentType": "text",
          "content": "При использовании данного метода ему в качестве аргумента передается объект, который станет прототипом нового объекта."
        },
        {
          "id": "code-0-3",
          "contentType": "code",
          "content": "// создаем объект без прототипа - пустой объект\nconst object = Object.create(null)"
        },
        {
          "id": "text-0-6",
          "contentType": "text",
          "content": "Функция-конструктор"
        },
        {
          "id": "text-0-7",
          "contentType": "text",
          "content": "Создаем функцию-конструктор и применяем оператор \"new\" для создания экземпляра этой функции - объекта:"
        },
        {
          "id": "code-0-4",
          "contentType": "code",
          "content": "function Person (name) {\n    const object = {}\n    object.name = name\n    object.age = 30\n    return object\n}\nconst user = new Person('Ванька')"
        },
        {
          "id": "text-0-8",
          "contentType": "text",
          "content": "Класс:"
        },
        {
          "id": "code-0-5",
          "contentType": "code",
          "content": "class Person {\n    constructor(name) {\n        this.name = name\n    }\n}\n\nconst user = new Person('Ванька')"
        },
        {
          "id": "nav-0-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/object",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "91b01091-9266-4759-b257-c39b7bcceec5",
      "title": "2. Что такое прототипы?",
      "data": [
        {
          "id": "text-1-1",
          "contentType": "text",
          "content": "Прототипы используется для создания новых объектов на основе существующих. Такая техника называется прототипным наследованием. Прототип экземпляра объекта доступен через Object.getProtocontentTypeOf(object) или свойство __proto__ (внутреннее скрытое свойство [[ProtocontentType]])."
        },
        {
          "id": "img-1-1",
          "contentType": "img",
          "content": "data:image/png;base64,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"
        },
        {
          "id": "nav-1-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/protocontentType-inheritance",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Learn/JavaScript/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%8B/Object_protocontentTypes",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "ac6f03fc-55c4-40aa-9929-34e9286e6df9",
      "title": "3. В чем разница между call(), apply() и bind()?",
      "data": [
        {
          "id": "text-2-1",
          "contentType": "text",
          "content": "Разницу между данными методами проще всего объяснить с помощью примеров."
        },
        {
          "id": "text-2-2",
          "contentType": "text",
          "content": "Метод call() вызывает функцию с указанным значением this и аргументами через запятую."
        },
        {
          "id": "code-2-1",
          "contentType": "code",
          "content": "const employee1 = { firstName: 'Иван', lastName: 'Иванов' }\nconst employee2 = { firstName: 'Петр', lastName: 'Петров' }\n\nfunction invite (greet1, greet2) {\n    console.log(`${greet1}, ${this.firstName} ${this.lastName}. ${greet2}`)\n}\n\ninvite.call(employee1, 'Привет', 'Как дела?') // Привет, Иван Иванов. Как дела?\ninvite.call(employee2, 'Привет', 'Как дела?') // Привет, Петр Петров. Как дела?"
        },
        {
          "id": "text-2-3",
          "contentType": "text",
          "content": "Метод apply() вызывает функцию с указанным значением this и аргументами в виде массива."
        },
        {
          "id": "code-2-2",
          "contentType": "code",
          "content": "const employee1 = { firstName: 'Иван', lastName: 'Иванов' }\nconst employee2 = { firstName: 'Петр', lastName: 'Петров' }\n\nfunction invite (greet1, greet2) {\n    console.log(`${greet1}, ${this.firstName} ${this.lastName}. ${greet2}`)\n}\n\ninvite.apply(employee1, ['Привет', 'Как дела?']) // Привет, Иван Иванов. Как дела?\ninvite.apply(employee2, ['Привет', 'Как дела?']) // Привет, Петр Петров. Как дела?"
        },
        {
          "id": "text-2-4",
          "contentType": "text",
          "content": "Метод bind() возвращает новую функцию с указанным значением this и позволяет передать ей массив или любое количество аргументов через запятую."
        },
        {
          "id": "code-2-3",
          "contentType": "code",
          "content": "const employee1 = { firstName: 'Иван', lastName: 'Иванов' }\nconst employee2 = { firstName: 'Петр', lastName: 'Петров' }\n\nfunction invite (greet1, greet2) {\n    console.log(`${greet1}, ${this.firstName} ${this.lastName}. ${greet2}`)\n}\n\nconst inviteEmployee1 = invite.bind(employee1)\nconst inviteEmployee2 = invite.bind(employee2)\ninviteEmployee1('Привет', 'Как дела?') // Привет, Иван Иванов. Как дела?\ninviteEmployee2('Привет', 'Как дела?') // Привет, Петр Петров. Как дела?"
        },
        {
          "id": "text-2-5",
          "contentType": "text",
          "content": "Таким образом, методы call() и apply() вызывают функцию после ее привязки к объекту. Разница между ними состоит в способе передачи аргументов. Эту разницу легко запомнить при помощи первых букв методов: call - это запятая (comma, c), apply - массив (array, a). Метод bind() возвращает новую функцию, привязанную к указаному объекту."
        },
        {
          "id": "nav-2-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/call-apply-decorators",
              "title": "Call/Apply"
            },
            {
              "id": "subnav-1-1",
              "name": "jsr",
              "src": "https://learn.javascript.ru/bind",
              "title": "Bind"
            },
            {
              "id": "subnav-1-2",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/call",
              "title": "Call"
            },
            {
              "id": "subnav-1-3",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/apply",
              "title": "Apply"
            },
            {
              "id": "subnav-1-4",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/bind",
              "title": "Bind"
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "faa44a9b-d78a-4362-bdb0-399edd26fb0f",
      "title": "4. Что такое JSON и какие у него есть методы?",
      "data": [
        {
          "id": "text-3-1",
          "contentType": "text",
          "content": "JSON - это текстовый формат данных, основанный на синтаксисе объектов JavaScript, изобретенный Дугласом Крокфордом. Он используется для передачи данных по сети и, обычно, имеет расширение .json и MIME-тип application/json."
        },
        {
          "id": "text-3-2",
          "contentType": "text",
          "content": "Разбор (парсинг): преобразует строку в формате JSON в объект."
        },
        {
          "id": "code-3-1",
          "contentType": "code",
          "content": "JSON.parse(text)"
        },
        {
          "id": "text-3-3",
          "contentType": "text",
          "content": "Стрингификация: преобразует объект в строку в формате JSON для передачи по сети."
        },
        {
          "id": "code-3-2",
          "contentType": "code",
          "content": "JSON.stringify(object)"
        },
        {
          "id": "nav-3-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/json",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "4fae3be5-dd5c-4c7e-aac2-e90045927f53",
      "title": "5. Что делает метод Array.slice()?",
      "data": [
        {
          "id": "text-4-1",
          "contentType": "text",
          "content": "Метод slice() возвращает выбранные элементы массива в виде нового массива. Он возвращает элементы, начиная с индекса, указанного в первом аргументе, и заканчивая, но не включая, индексом, указанном во втором необязательном аргументе. Если второй аргумент отсутствует, то будут извлечены все элементы, начиная с индекса, указанного в первом аргументе."
        },
        {
          "id": "code-4-1",
          "contentType": "code",
          "content": "const arrayIntegers = [1, 2, 3, 4, 5]\nconst arrayIntegers1 = arrayIntegers.slice(0, 2) // [1, 2]\nconst arrayIntegers2 = arrayIntegers.slice(2, 3) // [3]\nconst arrayIntegers3 = arrayIntegers.slice(4) // [5]"
        },
        {
          "id": "text-4-2",
          "contentType": "text",
          "content": "Обратите внимание, что данный метод не изменяет исходный массив, а лишь возвращает его подмножество в виде нового массива."
        },
        {
          "id": "nav-4-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/array-methods",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/slice",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "e4dd9d66-e59a-4247-a54a-4f3eed160fe5",
      "title": "6. Что делает метод Array.splice()?",
      "data": [
        {
          "id": "text-5-1",
          "contentType": "text",
          "content": "Метод splice() используется для добавления или удаления элементов в или из массива. Первый аргумент определяет начальную позицию для добавления или удаления элементов, второй опциональный аргумент - количество удаляемых элементов. Каждый последующий аргумент (третий и т.д.) добавляется в массив:"
        },
        {
          "id": "code-5-1",
          "contentType": "code",
          "content": "let arrayOriginal1 = [1, 2, 3, 4, 5]\nlet arrayOriginal2 = [1, 2, 3, 4, 5]\nlet arrayOriginal3 = [1, 2, 3, 4, 5]\n\nlet array1 = arrayOriginal1.splice(0, 2) // возвращается [1, 2]; исходный массив = [3, 4, 5]\nlet array2 = arrayOriginal2.slice(3) // возвращается [4, 5]; исходный массив = [1, 2, 3]\nlet array3 = arrayOriginal3.slice(3, 1, 'a', 'b', 'c') // возвращается [4]; исходный массив = [1, 2, 3, 'a', 'b', 'c']"
        },
        {
          "id": "text-5-2",
          "contentType": "text",
          "content": "Обратите внимание, что метод splice() модифицирует исходный массив и возвращает массив извлеченных элементов."
        },
        {
          "id": "nav-5-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/array-methods",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/splice",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "3ad7ce18-3046-4c60-bfed-fce10631e4ab",
      "title": "7. В чем разница между slice() и splice()?",
      "data": [
        {
          "id": "text-6-1",
          "contentType": "text",
          "content": "Основные отличия состоят в следующем:"
        },
        {
          "id": "table-6-1",
          "contentType": "table",
          "content": [
            [
              "Slice",
              "Splice"
            ],
            [
              "Не изменяет исходный массив",
              "Изменяет исходный массив"
            ],
            [
              "Возвращает подмассив исходного массива",
              "Возвращает удаленные элементы в виде массива"
            ],
            [
              "Служит для извлечения элементов из массива",
              "Служит для добавления/удаления элементов в/из массива"
            ]
          ]
        },
        {
          "id": "nav-6-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/array-methods",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/slice",
              "title": "Slice"
            },
            {
              "id": "subnav-1-2",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/splice",
              "title": "Splice"
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "e0b179d2-7df7-45ea-a1a5-3d2cb3015c35",
      "title": "8. Как сравниваются объекты и карты?",
      "data": [
        {
          "id": "text-7-1",
          "contentType": "text",
          "content": "Объекты похожи на карты в том, что они оба позволяют устанавливать ключи для значений, извлекать значения, удалять ключи и определять наличие значения по ключу. По этой причине объекты раньше использовались как карты. Однако, между ними существуют некоторые отличия, которые делают использование карт более предпочтительным в определенных случаях."
        },
        {
          "id": "list-7-1",
          "contentType": "list",
          "content": [
            "Ключами объекта могут быть только строки и символы, а ключами карты - любые значения, включая функции и объекты",
            "Ключи карты упорядочены, а ключи объекта нет. Поэтому при итерации ключи карты возвращаются в порядке их добавления",
            "Вы можете получить размер карты с помощью свойства size, а количество свойств объекта определяется вручную",
            "Карта является итерируемой сущностью, а для итерации по объекту необходимо сначала каким-то образом получить его ключи, а затем их перебрать",
            "При использовании объекта в качестве карты следует помнить о том, что любой объект имеет прототип, поэтому собственные ключи такой карты могут пересекаться с пользовательскими ключами. Поэтому для создания карты-объекта следует использовать Object.create(null), но сейчас такой способ используется редко",
            "Объект уступает карте в плане производительности, когда речь идет о быстром добавлении/удалении ключей"
          ]
        },
        {
          "id": "nav-7-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/map-set",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Map",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "e2b900cd-e059-4d93-81b2-43dd86da0f9e",
      "title": "9. В чем разница между операторами \"==\" и \"===\"?",
      "data": [
        {
          "id": "text-8-1",
          "contentType": "text",
          "content": "JavaScript предоставляет два способа для сравнения значений: строгое (===, !==) и абстрактное (==, !==). При строгом сравнении значения сравниваются как есть, а при нестрогом, при необходимости, осуществляется неявное преобразование (приведение) типов значений. Строгие операторы используют следующие правила для сравнения различных типов значений:"
        },
        {
          "id": "list-8-1",
          "contentType": "list",
          "content": [
            "Две строки являются строго равными, когда они имеют одинаковый набор символов, одинаковую длину и одинаковые символы на одних и тех же позициях",
            "Два числа являются строго равными, если равны их значения. Существует два особых случая:\nNaN не равно ничему, включая NaN\nПоложительный и отрицательный нули равны друг другу",
            "NaN не равно ничему, включая NaN",
            "Положительный и отрицательный нули равны друг другу",
            "Логические значение являются строго равными, когда оба являются истинными или ложными, т.е. true или false",
            "Два объекта являются строго равными, если ссылаются на один и тот же объект (место в памяти)",
            "null === undefined возвращает false, а null == undefined - true"
          ]
        },
        {
          "id": "text-8-2",
          "contentType": "text",
          "content": "Несколько примеров:"
        },
        {
          "id": "code-8-1",
          "contentType": "code",
          "content": "0 == false // true\n0 === false // false\n1 == \"1\" // true\n1 === \"1\" // false\nnull == undefined // true\nnull === undefined // false\n'0' == false // true\n'0' === false // false\n[] == [] // или\n[] === [] // false, ссылаются на разные места в памяти\n{} == {} // или\n{} === {} // false, ссылаются на разные места в памяти"
        },
        {
          "id": "nav-8-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/comparison",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B_%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "baaac64c-e763-4080-9c7e-deb1a7cfef66",
      "title": "10. Что такое лямбда- или стрелочные функции?",
      "data": [
        {
          "id": "text-9-1",
          "contentType": "text",
          "content": "Стрелочные функции - это сокращенный способ записи функциональных выражений. Они не имеют собственных this, arguments, super и new.target. Эти функции служат хорошей альтернативой функциям, не имеющим методов, но не могут использоваться как конструкторы."
        },
        {
          "id": "code-9-1",
          "contentType": "code",
          "content": "function regularSum (x, y) {\n    return x + y\n}\n\nconst arrowSum = (x, y) => x + y"
        },
        {
          "id": "nav-9-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/arrow-functions-basics",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "d3a8b308-7110-4b61-9e3f-347c4eb8b716",
      "title": "11. Почему функции называют объектами первого класса?",
      "data": [
        {
          "id": "text-10-1",
          "contentType": "text",
          "content": "В JavaScript функции являются объектами первого класса. Это означает, что функции могут использоваться как обычные переменные."
        },
        {
          "id": "text-10-2",
          "contentType": "text",
          "content": "Например, функция может передаваться в качестве аргумента другой функции, возвращаться как значение из другой функции и присваиваться переменной. В следующем примере функция присваиваивается обработчику:"
        },
        {
          "id": "code-10-1",
          "contentType": "code",
          "content": "const handler = () => console.log('Я - функция обработки клика')\ndocument.addEventListener('click', handler)"
        },
        {
          "id": "nav-10-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/function-basics",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/First-class_Function",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "e79281dd-ff0c-40e1-820d-ab059f14b119",
      "title": "12. Что такое функция первого порядка?",
      "data": [
        {
          "id": "text-11-1",
          "contentType": "text",
          "content": "Функция первого порядка - это функция, которая не принимает другую функцию в качестве аргумента и не возвращает функцию как значение:"
        },
        {
          "id": "code-11-1",
          "contentType": "code",
          "content": "const firstOrder = () => console.log('Я - функция первого порядка')"
        },
        {
          "id": "nav-11-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/function-basics",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "70c16f0a-2620-433e-9904-32c1ed825364",
      "title": "13. Что такое функция высшего порядка?",
      "data": [
        {
          "id": "text-12-1",
          "contentType": "text",
          "content": "Функция высшего порядка - это функция, которая принимает другую функцию в качестве аргумента или возращает другую функцию как значение:"
        },
        {
          "id": "code-12-1",
          "contentType": "code",
          "content": "const firstOrderFun = () => console.log('Я - функция высшего порядка')\nconst higherOrder = returnFirstOrderFun => returnFirstOrderFun()\nhigherOrder(firstOrderFunc)"
        },
        {
          "id": "nav-12-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/function-basics",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "4e02f913-51fb-423d-80ed-625024b8c50f",
      "title": "14. Что такое унарная функция?",
      "data": [
        {
          "id": "text-13-1",
          "contentType": "text",
          "content": "Унарная функция (функция-монада) - это функция, принимающая только один аргумент:"
        },
        {
          "id": "code-13-1",
          "contentType": "code",
          "content": "const unaryFun = a => console.log(a + 10) // прибавляем 10 к переданному аргументу и выводим результат в консоль"
        },
        {
          "id": "nav-13-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/function-basics",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "10bf3d6c-6d63-4ece-94a9-897ec57ba02b",
      "title": "15. Что такое каррирование (currying)?",
      "data": [
        {
          "id": "text-14-1",
          "contentType": "text",
          "content": "Каррирование - это процесс преобразования функции с несколькими параметрами в несколько функций с одним параметром. Данный процесс назван в четь математика Хаскелла Карри. Каррирование превращает одну n-арную функцию в несколько унарных функций (уменьшает арность функции):"
        },
        {
          "id": "code-14-1",
          "contentType": "code",
          "content": "const sum = (a, b, c) => a + b + c\nconst currySum = a => b => c => a + b + c\n\ncurrySum(1) // возвращает функцию: b => c => 1 + b + c\ncurrySum(1)(2) // возвращает функцию: c => 3 + c\ncurrySum(1)(2)(3) // возвращает число 6"
        },
        {
          "id": "text-14-2",
          "contentType": "text",
          "content": "Каррирование применяется в целях обеспечения возможности повторного использования кода (частичное применение функции) и создания композиции из функций."
        },
        {
          "id": "nav-14-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/currying-partials",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "472f9f2a-9ce3-4214-bd69-c34790bffe12",
      "title": "16. Что такое чистая функция?",
      "data": [
        {
          "id": "text-15-1",
          "contentType": "text",
          "content": "Чистая функция - это функция, возвращаемое значение которой зависит только от передаваемых аргументов, без побочных эффектов. Проще говоря, если вы вызывается функцию n раз с n аргументами, и функция всегда возвращает одно и тоже значение, значит, она является чистой:"
        },
        {
          "id": "code-15-1",
          "contentType": "code",
          "content": "// не чистая\nlet numberArray = []\nconst impureAddNumber = number => numberArray.push(number)\n// чистая\nconst pureAddNumber = number => argNumberArray => argNumberArray.concat([number])\n\nconsole.log(impureAddNumber(1)) // 1\nconsole.log(numberArray) // [1]\nconsole.log(pureAddNumber(2)(numberArray)) // [1, 2]\nconsole.log(numberArray) // [1]"
        },
        {
          "id": "text-15-2",
          "contentType": "text",
          "content": "В приведенном примере impureAddNumber не является чистой функцией, поскольку метод push() возвращает новую длину массива, которая не зависит от передаваемого аргумента. Вторая функция является чистой, поскольку метод concat() объединяет два массива без побочных эффектов и возвращает новый массив. Чистые функции важны для юнит-тестирования и не нуждаются во внедрении зависимостей. Отсутствие побочных эффектов повышает надежность приложения за счет более слабых связей между его элементами. Одним из воплощений данного принципа является концепция неизменности (иммутабельности), представленная в ES6, и заключающаяся в предпочтении const перед let."
        },
        {
          "id": "nav-15-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/function-basics",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "6c530d30-80a5-41f0-b42e-817e2c312c46",
      "title": "17. Для чего используется ключевое слово \"let\"?",
      "data": [
        {
          "id": "text-16-1",
          "contentType": "text",
          "content": "Ключевое слово \"let\" служит для объявления локальной переменной, имеющей блочную область видимости. Область видимости такой переменной органичена блоком, оператором или выражением, в котором она используется. Переменные, объявленные с помощью ключевого слова \"var\", имеют глобальную область видимости или область видимости функции, в которой они определены:"
        },
        {
          "id": "code-16-1",
          "contentType": "code",
          "content": "let counter = 1\nif (counter === 1) {\n    let counter = 2\n    console.log(counter) // 2\n}\nconsole.log(counter) // 1 (переменная counter, объявленная в блоке, здесь не существует)"
        },
        {
          "id": "nav-16-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/variables",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/let",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "6f86d0ff-dfa7-4598-8726-813f5e7bccb7",
      "title": "18. В чем разница между let и var?",
      "data": [
        {
          "id": "text-17-1",
          "contentType": "text",
          "content": "Основные отличия состоят в следующем:"
        },
        {
          "id": "table-17-1",
          "contentType": "table",
          "content": [
            [
              "var",
              "let"
            ],
            [
              "Доступно с момента появления JavaScript",
              "Представлено в ES6"
            ],
            [
              "Имеет глобальную или функциональную область видимости",
              "Имеет блочную область видимости"
            ],
            [
              "Переменные поднимаются в начало области видимости",
              "Переменные также поднимаются, но не инициализируются (поднимается только объявление, но не присвоение значения)"
            ]
          ]
        },
        {
          "id": "text-17-2",
          "contentType": "text",
          "content": "Несколько примеров:"
        },
        {
          "id": "code-17-1",
          "contentType": "code",
          "content": "function userDetails(username) {\n    if (username) {\n        console.log(salary)\n        console.log(age)\n        let age = 30\n        var salary = 10000\n    }\n    console.log(salary) // 10000 (область видимости функции)\n    console.log(age) // SyntaxError: \"age\" is not defined (блочная область видимости)\n}"
        },
        {
          "id": "nav-17-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/variables",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/let",
              "title": "let"
            },
            {
              "id": "subnav-1-2",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/var",
              "title": "var"
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "0f01871b-ff07-4a40-b125-1046e7e713d5",
      "title": "19. Почему в качестве ключевого слова было выбрано слово \"let\"?",
      "data": [
        {
          "id": "text-18-1",
          "contentType": "text",
          "content": "Let (пусть) - это математический оператор, который использовался ранними языками программирования, такими как Scheme и Basic. В настоящее время let используется большим количеством языков программирования, так что данное слово является наиболее близкой альтернативой сокращению \"var\" (variable - переменная)."
        },
        {
          "id": "nav-18-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/variables",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/let",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "bc924308-07f6-4ce4-8c00-73a580ea19d6",
      "title": "20. Как переопределить переменную в блоке switch?",
      "data": [
        {
          "id": "text-19-1",
          "contentType": "text",
          "content": "Если вы попытаетесь переопределить переменную, объявленную с помощью ключевого слова \"let\" в блоке switch, то получите ошибку:"
        },
        {
          "id": "code-19-1",
          "contentType": "code",
          "content": "let counter = 1\nswitch(x) {\n    case 0:\n        let name\n        break\n    case 1:\n        let name // SyntaxError\n        break\n}"
        },
        {
          "id": "text-19-2",
          "contentType": "text",
          "content": "Для решения данной задачи необходимо создать новый блок внутри case - новую лексическую область видимости:"
        },
        {
          "id": "code-19-2",
          "contentType": "code",
          "content": "let counter = 1\nswitch(x) {\n    case 0: {\n        let name\n        break\n    }\n    case 1: {\n        let name\n        break\n    }\n}"
        },
        {
          "id": "nav-19-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/switch",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/switch",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "6c8abbc4-f5f2-42cd-ab2e-85a6c22544ed",
      "title": "21. Что такое временная мертвая зона?",
      "data": [
        {
          "id": "text-20-1",
          "contentType": "text",
          "content": "При попытке доступа к переменным, объявленным с помощью ключевого слова \"let\" или \"const\" (но не \"var\"), до их определения (т.е. до присваивания им значения внутри текущей области видимости) будет выброшено исключение ReferenceError (ошибка ссылки). Другими словами, временной мертвой зоной называется время между созданием контекста (области видимости) переменной и ее определением:"
        },
        {
          "id": "code-20-1",
          "contentType": "code",
          "content": "function someMethod () {\n    console.log(counter1) // undefined\n    console.log(counter2) // ReferenceError\n    var counter1 = 1\n    const counter2 = 2\n}"
        },
        {
          "id": "nav-20-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/let",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "0e36a54a-63be-4459-8670-1a279fd08340",
      "title": "22. Что такое немедленно вызываемое функциональное выражение (Immediately Invoked Function Expression, IIFE)?",
      "data": [
        {
          "id": "text-21-1",
          "contentType": "text",
          "content": "IIFE - это функция, которая вызывается сразу после определения. Синтаксис такой функции может выглядеть так (один из вариантов, наиболее распространенный):"
        },
        {
          "id": "code-21-1",
          "contentType": "code",
          "content": "(function () {\n    // код\n})()\n\n// или, если речь идет о стрелочной функции\n(() => {\n    // код\n})()"
        },
        {
          "id": "text-21-2",
          "contentType": "text",
          "content": "Главная причина использования IIFE заключается в обеспечении приватности переменных, поскольку доступ к переменным, объявленным внутри IIFE, нельзя получить из внешнего окружения:"
        },
        {
          "id": "code-21-2",
          "contentType": "code",
          "content": "(function () {\n    var message = 'IIFE'\n    console.log(message)\n})()\nconsole.log(message) // SyntaxError: \"message\" is not defined"
        },
        {
          "id": "nav-21-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/closure#bloki-koda-i-tsikly-iife",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/IIFE",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "9ea073c7-0492-4e22-84ad-a924f7f8c127",
      "title": "23. В чем заключаются преимущества использования модулей?",
      "data": [
        {
          "id": "text-22-1",
          "contentType": "text",
          "content": "Среди прочего, можно назвать следующее:"
        },
        {
          "id": "list-22-1",
          "contentType": "list",
          "content": [
            "Повышение читаемости и облегчение поддержки кода",
            "Возможность повторного использования кода",
            "Сохранение чистоты глобального пространства имен"
          ]
        },
        {
          "id": "nav-22-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/modules-intro",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Modules",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "a2cb8872-6fda-4978-8bf7-0d41ac981f4f",
      "title": "24. Что такое запоминание или мемоизация?",
      "data": [
        {
          "id": "text-23-1",
          "contentType": "text",
          "content": "Мемоизация - это способ повышения производительности функции за счет сохранения в кэше ранее полученных результатов выполнения этой функции. При каждом вызове функции переданный ей аргумент становится индексом кэша. Если данные имеются в кэше, они возвращаются без повторного выполнения функции. В противном случае, функция выполняется, а результат записывается в кэш:"
        },
        {
          "id": "code-23-1",
          "contentType": "code",
          "content": "const memoAdd = () => {\n    let cache = {}\n    return value => {\n        if (value in cache) {\n            console.log('Получение данных из кэша')\n            return cache[value] // в данном случае, cache.value не может быть использовано в качестве названия свойства, поскольку названия свойств в JavaScript не могут начинаться с числа. Поэтому используется скобочная нотация\n        } else {\n            console.log('Результат вычисляется')\n            let result = value + 20\n            cache[value] = result\n            return result\n        }\n    }\n}\n// возвращаем функцию из memoAdd\nconst add = memoAdd()\nconsole.log(add(20)) // Результат вычисляется 40\nconsole.log(add(20)) // Получения данных из кэша 40"
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "9721c09a-badc-4523-8baa-fdbd913b9b3e",
      "title": "25. Что такое поднятие переменных (hoisting)?",
      "data": [
        {
          "id": "text-24-1",
          "contentType": "text",
          "content": "Поднятие - это процесс перемещения переменных и функциональных выражений в начало их области видимости перед выполнением кода. Запомните: поднимаются только сами переменные и выражения, а не их инициализация (т.е. поднимается объявление переменной, а не присваивание ей значения):"
        },
        {
          "id": "code-24-1",
          "contentType": "code",
          "content": "console.log(message) // undefined\nvar message = 'Привет!'"
        },
        {
          "id": "text-24-2",
          "contentType": "text",
          "content": "Для интерпретатора данный код выглядит так:"
        },
        {
          "id": "code-24-2",
          "contentType": "code",
          "content": "var message\nconsole.log(message)\nmessage = 'Привет!'"
        },
        {
          "id": "nav-24-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/var",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%9F%D0%BE%D0%B4%D0%BD%D1%8F%D1%82%D0%B8%D0%B5",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "74ae9b28-fcd2-429b-83d9-48bd4032879e",
      "title": "26. Что такое класс?",
      "data": [
        {
          "id": "text-25-1",
          "contentType": "text",
          "content": "Классы, представленные в ES6, являются синтаксическим сахаром (оберткой, абстракцией или надстройкой) для протипного наследования (для прототипа функции-конструктора). Пример функции-конструктора:"
        },
        {
          "id": "code-25-1",
          "contentType": "code",
          "content": "function Bike(model, color) {\n    this.model = model\n    this.color = color\n}\n\nBike.protocontentType.getDetails = function () {\n    return 'Эта ' + this.model + ' велосипеда имеет ' + this.color + ' цвет.'\n}"
        },
        {
          "id": "text-25-2",
          "contentType": "text",
          "content": "Тот же пример с использованием класса:"
        },
        {
          "id": "code-25-2",
          "contentType": "code",
          "content": "class Bike {\n    constructor (color, model) {\n        this.color = color\n        this.model = model\n    }\n\n    getDetails () {\n        return `Эта ${this.model} велосипеда имеет ${this.color} цвет.`\n    }\n}"
        },
        {
          "id": "nav-25-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/class",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "5730a8e9-f257-44ae-8eb3-c6c2aaccfef2",
      "title": "27. Что такое замыкание?",
      "data": [
        {
          "id": "text-26-1",
          "contentType": "text",
          "content": "Замыкание - это комбинация функции и ее лексического окружения. Проще говоря, замыкание - это когда внутренняя функция имеет доступ к переменным, объявленным во внешней функции. Замыкание имеет цепочку из трех областей видимости:"
        },
        {
          "id": "list-26-1",
          "contentType": "list",
          "content": [
            "Собственная область видимости",
            "Область видимости внешней функции",
            "Глобальная область видимости"
          ]
        },
        {
          "id": "code-26-1",
          "contentType": "code",
          "content": "const welcome = name => {\n    const greet = message => {\n        console.log(`${message}, ${name}!`)\n    }\n    return greet\n}\n\nconst fun = welcome('Ванька')\nfun('Привет') // Привет, Ванька!"
        },
        {
          "id": "nav-26-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/closure",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Closures",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "875a854e-0d11-476c-8017-1d01a4592a71",
      "title": "28. Что такое модуль?",
      "data": [
        {
          "id": "text-27-1",
          "contentType": "text",
          "content": "Модули - это небольшие части независимого переиспользуемого кода, лежащие в основе многих шаблонов проектирования. Большинство модулей экспортируется в качестве объектов, функций или конструкторов."
        },
        {
          "id": "nav-27-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/modules-intro",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Modules",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "7291dd3c-70e0-4141-831d-85cd156e59ef",
      "title": "29. Что такое область видимости?",
      "data": [
        {
          "id": "text-28-1",
          "contentType": "text",
          "content": "Область видимости определяет доступность переменных, функций и объектов в разных местах кода во время его выполнения. Другими словами, область видимости - это видимость переменных и других ресурсов в текущем контексте выполнения кода."
        },
        {
          "id": "nav-28-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Glossary/Scope",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "947e5e6f-bdec-436a-9a86-9e88178e3122",
      "title": "30. Что такое сервис-воркер (service worker)?",
      "data": [
        {
          "id": "text-29-1",
          "contentType": "text",
          "content": "Сервис-воркер - это скрипт, который выполняется независимо от веб-страницы, на которой он запущен, и действий пользователя. Фактически сервис-воркер выполняет роль прокси-сервера между приложением и браузером. Основными возможностями сервис-воркеров является следующее: обеспечение работы приложения в режиме оффлайн, периодическая фоновая синхронизация, пуш-уведомления, перехват и обработка сетевых запросов и программное управление кэшем."
        },
        {
          "id": "nav-29-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/ServiceWorker",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "474a5eb1-9e87-4cb8-8d4d-49e0be7ddf9f",
      "title": "31. Как взаимодействовать с объектной моделью документа (Document Object Model, DOM) с помощью сервис-воркеров?",
      "data": [
        {
          "id": "text-30-1",
          "contentType": "text",
          "content": "Сервис-воркеры не имеют прямого доступа к DOM. Однако, они могут взаимодействовать со страницей через интерфейс postMessage, а страница - может изменять DOM."
        },
        {
          "id": "nav-30-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/ServiceWorker",
              "title": "ServiceWorker"
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Client/postMessage",
              "title": "postMessage"
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "fff97c2d-67da-46f1-9d10-419f85dc33a7",
      "title": "32. Как повторно использовать информацию при перезапуске сервис-воркера?",
      "data": [
        {
          "id": "text-31-1",
          "contentType": "text",
          "content": "Одной из проблем сервис-воркеров является то, что их выполнение прекращается, когда они не используются, и повторно запускается при необходимости. Это не позволяет добавлять обработчики событий fetch и message глобально. Для повторного использования информации необходимо обеспечить взаимодействие сервис-воркеров с индексированной базой данных (IndexedDB) или локальным хранилищем (local storage)."
        },
        {
          "id": "nav-31-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/ServiceWorker",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "0c438abd-a46e-45c3-b167-61b69988209f",
      "title": "33. Что такое индексированная база данных (IndexedDB)?",
      "data": [
        {
          "id": "text-32-1",
          "contentType": "text",
          "content": "IndexedDB - это низкоуровневый прикладной интерфейс для хранения большого объема структурированных данных, включая файлы и blobs, на стороне клиента. Данный интерфейс использует индексы для повышения скорости поиска данных."
        },
        {
          "id": "nav-32-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/indexeddb",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/IndexedDB_API",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "f3b20f74-4843-4511-ba03-a87fd8b5d252",
      "title": "34. Что такое веб-хранилище (Web Storage)?",
      "data": [
        {
          "id": "text-33-1",
          "contentType": "text",
          "content": "Веб-хранилище - это интерфейс, позволяющий хранить данные в виде пар ключ/значение локально, т.е. в браузере пользователя, более удобным способом, чем при использовании куки. Веб-хранилище предоставляет два механизма хранения данных:"
        },
        {
          "id": "list-33-1",
          "contentType": "list",
          "content": [
            "Локальное хранилище (local stotage) - хранит данные текущего пользователя неограниченное количество времени",
            "Сессионное хранилище (session storage) - хранит данные на протяжении текущей сессии, т.е. при закрытии вкладки браузера данные будут потеряны"
          ]
        },
        {
          "id": "nav-33-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/localstorage",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "09f3b383-513f-4614-940c-27a4bdef116c",
      "title": "35. Что такое postMessage?",
      "data": [
        {
          "id": "text-34-1",
          "contentType": "text",
          "content": "postMessage - это способ коммуникации разных источников объекта window (например, страницы и генерируемого ею поп-апа (всплывающего окна) или страницы и встроенного в нее фрейма (iframe)). Обычно, скрипты одной страницы не имеют доступа к другой странице, если данная страница следует Политике общего происхождения или одного источника (источник - протокол, хост и порт)."
        },
        {
          "id": "nav-34-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Client/postMessage",
              "title": "postMessage"
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "0593d7c4-41a5-4022-af46-e43f237b8a50",
      "title": "36. Что такое куки (cookie)?",
      "data": [
        {
          "id": "text-35-1",
          "contentType": "text",
          "content": "Куки - это небольшой фрагмент данных, который сохраняется на компьютере пользователя для последующего использования браузером. Куки сохраняются в виде пар ключ/значение:"
        },
        {
          "id": "code-35-1",
          "contentType": "code",
          "content": "document.cookie = 'username=Ванька'"
        },
        {
          "id": "img-35-1",
          "contentType": "img",
          "content": "data:image/png;base64,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"
        },
        {
          "id": "nav-35-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/cookie",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Document/cookie",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "cb04d76d-71e6-4025-ae86-53900121c29d",
      "title": "37. Зачем нужны куки?",
      "data": [
        {
          "id": "text-36-1",
          "contentType": "text",
          "content": "Куки используются для сохранения информации о пользователе (не рекомендуется использовать для хранения конфиденциальной информации). Обычно, данный процесс состоит из двух этапов:"
        },
        {
          "id": "list-36-1",
          "contentType": "list",
          "content": [
            "При первом посещении страницы профиль пользователя сохраняется в куки",
            "При повторном посещении страницы профиль пользователя извлекается из куки"
          ]
        },
        {
          "id": "nav-36-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/cookie",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Document/cookie",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "ff1d5c9c-7601-4445-802f-59c9f3595935",
      "title": "38. Какими возможностями обладают куки?",
      "data": [
        {
          "id": "text-37-1",
          "contentType": "text",
          "content": "По умолчанию, куки удаляются при закрытии браузера, однако это можно изменить, установив время жизни (expires) в формате UTC:"
        },
        {
          "id": "code-37-1",
          "contentType": "code",
          "content": "document.cookie = 'username=Ванька; expires=Sat, 5 Sep 2020 12:00:00 UTC'"
        },
        {
          "id": "text-37-2",
          "contentType": "text",
          "content": "По умолчанию, куки принадлежат текущей странице, однако это также можно изменить, установив путь (path):"
        },
        {
          "id": "code-37-2",
          "contentType": "code",
          "content": "document.cookie = 'username=Ванька; path=/services'"
        },
        {
          "id": "nav-37-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/cookie",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Document/cookie",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "20c9c575-d136-4482-bb9f-2d982a5ab0b6",
      "title": "39. Как удалить куки?",
      "data": [
        {
          "id": "text-38-1",
          "contentType": "text",
          "content": "Удалить куки можно, установив прошедшее время в качестве времени жизни. В этом случае не нужно определять значение куки:"
        },
        {
          "id": "code-38-1",
          "contentType": "code",
          "content": "document.cookie = 'username=; expires=Sat, 05 Jun 2020 00:00:00 UTC; path=/;'"
        },
        {
          "id": "text-38-2",
          "contentType": "text",
          "content": "Обратите внимание, что в данном случае необходимо определить путь для удаления правильного куки. Некоторые браузеры не позволяют удалить куки без указания этого параметра."
        },
        {
          "id": "nav-38-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/cookie",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Document/cookie",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "8816334f-1ced-44d9-b853-9cbc127b53b2",
      "title": "40. В чем разница между куки, локальным и сессионным хранилищами?",
      "data": [
        {
          "id": "text-39-1",
          "contentType": "text",
          "content": "Основные отличия состоят в следующем:"
        },
        {
          "id": "table-39-1",
          "contentType": "table",
          "content": [
            [
              "Критерий",
              "Куки",
              "Локальное хранилище",
              "Сессионное хранилище"
            ],
            [
              "Доступность",
              "Как на сервере, так и на клиенте",
              "Только на клиенте",
              "Только на клиенте"
            ],
            [
              "Время жизни",
              "Устанавливается с помощью expires",
              "До удаления пользователем",
              "До закрытия вкладки браузера"
            ],
            [
              "Поддержка шифрования",
              "Поддерживается",
              "Не поддерживается",
              "Не поддерживается"
            ],
            [
              "Максимальный размер данных",
              "4 Кб",
              "Около 5 Мб (зависит от браузера)",
              "Около 5 Мб (зависит от браузера)"
            ]
          ]
        },
        {
          "id": "nav-39-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/cookie",
              "title": "Куки"
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Document/cookie",
              "title": "Cookie"
            },
            {
              "id": "subnav-1-2",
              "name": "jsr",
              "src": "https://learn.javascript.ru/localstorage",
              "title": "LocalStorage, SessionStotage"
            },
            {
              "id": "subnav-1-3",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API",
              "title": "Web Storage"
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "849566d2-7c76-4f02-a578-814da9eb0bf4",
      "title": "41. В чем главное отличие между локальным и сессионным хранилищами?",
      "data": [
        {
          "id": "text-40-1",
          "contentType": "text",
          "content": "Локальное хранилище - это тоже самое, что и сессионное хранилище, за исключением того, что в первом данные сохраняются даже при закрытии и перезагрузке браузера, а во втором данные удаляются по окончании сессии (закрытие вкладки браузера)."
        },
        {
          "id": "nav-40-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/localstorage",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "562e83aa-ce78-46c9-bb3d-54d5e1f5e42e",
      "title": "42. Как получить доступ к веб-хранилищу?",
      "data": [
        {
          "id": "text-41-1",
          "contentType": "text",
          "content": "Объект window предоставляет объекты WindowLocalStorage и WindowSessionStorage, которые имеют свойства localStorage и sessionStorage, соответственно. Эти свойства создают экземпляр объекта Storage, с помощью которого можно записывать, извлекать и удалять данные для определенного домена и типа хранилища (сессионное или локальное):"
        },
        {
          "id": "code-41-1",
          "contentType": "code",
          "content": "// сохраняем данные\nlocalStorage.setItem('data', document.querySelector('.data').value)\n// получаем данные\nlocalStorage.getItem('data')"
        },
        {
          "id": "nav-41-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/localstorage",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "a211f608-cf19-4565-a13b-5b08a9d048e3",
      "title": "43. Какие методы предоставляет сессионное хранилище?",
      "data": [
        {
          "id": "text-42-1",
          "contentType": "text",
          "content": "Сессионное хранилище предоставляет методы для чтения, записи и удаления данных:"
        },
        {
          "id": "code-42-1",
          "contentType": "code",
          "content": "// записываем данные\nsessionStorage.setItem('key', 'value')\n\n// получаем данные\nconst data = sessionStorage.getItem('key')\n\n// удаляем определенные данные\nsessionStorage.removeItem('key')\n\n// удаляем все данные\nsessionStorage.clear()"
        },
        {
          "id": "nav-42-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/localstorage",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "907c7ff0-5222-4a37-a1f4-dab196346a49",
      "title": "44. Какое событие возникает при работе с веб-хранилищем?",
      "data": [
        {
          "id": "text-43-1",
          "contentType": "text",
          "content": "При изменении хранилища в контексте другого документа возникает событие storage:"
        },
        {
          "id": "code-43-1",
          "contentType": "code",
          "content": "window.onstorage = function () {}"
        },
        {
          "id": "text-43-2",
          "contentType": "text",
          "content": "Пример обработки данного события:"
        },
        {
          "id": "code-43-2",
          "contentType": "code",
          "content": "window.onstorage = event => {\n    console.log(`${event.key} был изменен.\n    Старое значение: ${event.oldValue}.\n    Новое значение: ${event.newValue}.`)\n}"
        },
        {
          "id": "text-43-3",
          "contentType": "text",
          "content": "Данное событие позволяет реализовать своего рода чат."
        },
        {
          "id": "nav-43-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/localstorage",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "df9e4ca8-f101-4c85-b5f9-6ef04006779b",
      "title": "45. Для чего используется веб-хранилище?",
      "data": [
        {
          "id": "text-44-1",
          "contentType": "text",
          "content": "Веб-хранилище является более безопасным и может хранить больший объем данных, чем куки, что не влияет на производительность. Кроме того, данные не отправляются на сервер (в случае с куки данные включаются в заголовки запроса и ответа при каждом обращении клиента к серверу). Поэтому такой способ хранения данных является более предпочтительным, чем куки."
        },
        {
          "id": "nav-44-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/localstorage",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "cdf696a2-4bbd-48d3-9692-42a7e7a2ace2",
      "title": "46. Как определить поддержку веб-хранилища браузером?",
      "data": [
        {
          "id": "text-45-1",
          "contentType": "text",
          "content": "Перед использованием веб-хранилища рекомендуется проверить поддержку данного интерфейса браузерами:"
        },
        {
          "id": "code-45-1",
          "contentType": "code",
          "content": "if (contentTypeof(Storage) !== 'undefined') {\n    // код\n} else {\n    // веб-хранилище не поддерживается\n}\n\n// или\nif ('Storage' in window) {\n    console.log('ok')\n} else {\n    console.warn('не ok')\n}"
        },
        {
          "id": "text-45-2",
          "contentType": "text",
          "content": "По данным CanIUse поддержка веб-хранилища на сегодняшний день составляет 98%."
        },
        {
          "id": "nav-45-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/localstorage",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Web_Storage_API",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "79b44ed1-70e1-4199-a27e-01eb5112c747",
      "title": "47. Как определить поддержку сервис-воркеров браузером?",
      "data": [
        {
          "id": "text-46-1",
          "contentType": "text",
          "content": "Перед использованием сервис-воркеров рекомендуется проверить поддержку данного интерфейса браузерами:"
        },
        {
          "id": "code-46-1",
          "contentType": "code",
          "content": "if (contentTypeof(Worker) !== undefined) {\n    // код\n} else {\n    // сервис-воркеры не поддерживаются\n}\n// или\nif ('Worker' in window) {\n    console.log('ok')\n} else {\n    console.warn('не ok')\n}"
        },
        {
          "id": "text-46-2",
          "contentType": "text",
          "content": "По данным CanIUse поддержка сервис-воркеров на сегодняшний день составляет 94%."
        },
        {
          "id": "nav-46-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/ServiceWorker",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "8984ed09-b7c3-44ba-8def-7b2cb7408453",
      "title": "48. Приведите пример веб-воркера",
      "data": [
        {
          "id": "text-47-1",
          "contentType": "text",
          "content": "Для использования веб-воркера необходимости сделать следующее."
        },
        {
          "id": "text-47-2",
          "contentType": "text",
          "content": "Создать файл для воркера, например, get-current-time.js:"
        },
        {
          "id": "code-47-1",
          "contentType": "code",
          "content": "const getCurrentTime = () => {\n    let time = new Date().toLocaleTimeString()\n    postMessage(time)\n    setTimeout(() => getCurrentTime(), 1000)\n}\n\ngetCurrentTime()"
        },
        {
          "id": "text-47-3",
          "contentType": "text",
          "content": "Метод postMessage() используется для отправки сообщений странице."
        },
        {
          "id": "text-47-4",
          "contentType": "text",
          "content": "Создаем объект воркера:"
        },
        {
          "id": "code-47-2",
          "contentType": "code",
          "content": "const worker = new Worker('get-current-time.js')"
        },
        {
          "id": "text-47-5",
          "contentType": "text",
          "content": "После этого обрабатываем получение сообщений от воркера:"
        },
        {
          "id": "code-47-3",
          "contentType": "code",
          "content": "<output></output>\n<button>Стоп</button>\n\nworker\n    .addEventListener('message', event => document.querySelector('output')\n    .textContent = event.data)"
        },
        {
          "id": "text-47-6",
          "contentType": "text",
          "content": "Воркер будет продолжать обрабатывать событие message даже после того, как внешний скрипт выполнит свою работу, поэтому его нужно останавливать принудительно:"
        },
        {
          "id": "code-47-4",
          "contentType": "code",
          "content": "document.querySelector('button')\n    .addEventListener('click', () => worker.terminate())"
        },
        {
          "id": "text-47-7",
          "contentType": "text",
          "content": "Если присвоить воркеру значение undefined, его можно будет использовать повторно:"
        },
        {
          "id": "code-47-5",
          "contentType": "code",
          "content": "worker = undefined"
        },
        {
          "id": "nav-47-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Web_Workers_API",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "fedf7a10-481e-445d-8ded-be486708a440",
      "title": "49. Назовите ограничения веб-воркеров по работе с DOM",
      "data": [
        {
          "id": "text-48-1",
          "contentType": "text",
          "content": "Поскольку веб-воркеры создаются в отдельном файле, они не имеют доступа к следующим объектам:"
        },
        {
          "id": "list-48-1",
          "contentType": "list",
          "content": [
            "window",
            "Document",
            "Родительский объект - объект, запустивший воркер"
          ]
        },
        {
          "id": "nav-48-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Web_Workers_API",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "0d63bf9d-430e-48e4-93f8-b28a81fe0e34",
      "title": "50. Что такое промис (promise)?",
      "data": [
        {
          "id": "text-49-1",
          "contentType": "text",
          "content": "Промис (общание) - это объект, который либо выполняется с некоторым значением, либо отклоняется с ошибкой. Разрешение промиса происходит либо после истечения определенного времени, либо после возникновения определенного события. Промис может иметь одно из трех состояний: находится в режиме ожидания (pending), выполнен (fulfilled), отклонен (rejected)."
        },
        {
          "id": "text-49-2",
          "contentType": "text",
          "content": "Синтаксис промиса:"
        },
        {
          "id": "code-49-1",
          "contentType": "code",
          "content": "const promise = new Promise((resolve, reject) => {\n    // код\n})\n\n// или, когда мы уверены, что промис выполнится успешно\nconst promise = Promise.resolve(value)\npromise.then(value => {\n    // код\n})"
        },
        {
          "id": "text-49-3",
          "contentType": "text",
          "content": "Пример использования промиса:"
        },
        {
          "id": "code-49-2",
          "contentType": "code",
          "content": "const promise = new Promise(resolve => {\n    const timer = setTimeout(() => {\n        resolve('Привет от промиса!')\n        clearTimeout(timer)\n    }, 5000);\n}, reject => {\n    reject('Что-то пошло не так')\n})\n\npromise\n    .then(value => console.log(value))\n    .catch(error => console.error(error))\n    .finally(() => console.log('Мы закончили')) // в консоль будет выведено \"Привет от промиса!\" через 5 секунд и затем \"Мы закончили\""
        },
        {
          "id": "text-49-4",
          "contentType": "text",
          "content": "Алгоритм разрешения промиса:"
        },
        {
          "id": "img-49-1",
          "contentType": "img",
          "content": "data:image/png;base64,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"
        },
        {
          "id": "nav-49-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/promise-basics",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "665090ff-673c-4166-b93f-90d538d8bf81",
      "title": "51. Зачем нужны промисы?",
      "data": [
        {
          "id": "text-50-1",
          "contentType": "text",
          "content": "Промисы используются для работы с асинхронным кодом. Они представляют собой альтернативу функциям обратного вызова, позволяя избежать так называемого \"ада колбэков\", делают код более чистым и читаемым."
        },
        {
          "id": "nav-50-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/promise-basics",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "80c1c19d-88bd-4c52-995b-f1ac40f64bda",
      "title": "52. Назовите три возможных состояния промиса",
      "data": [
        {
          "id": "text-51-1",
          "contentType": "text",
          "content": "У промисов существует три состояния:"
        },
        {
          "id": "list-51-1",
          "contentType": "list",
          "content": [
            "Ожидание (pending): стадия перед началом выполнения операции",
            "Выполнен (fulfilled): успешное завершение операции",
            "Отклонен (rejected): неудачное выполнение операции. Выбрасывается исключение"
          ]
        },
        {
          "id": "nav-51-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/promise-basics",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "a881fac1-0b39-475b-ab66-395c12dec958",
      "title": "53. Что такое функция обратного вызова (колбэк)?",
      "data": [
        {
          "id": "text-52-1",
          "contentType": "text",
          "content": "Колбэк - это функция, которая передается другой функции в качестве аргумента. Данная функция (внутренняя) вызывается внутри родительской (внешней) для выполнения операции при возникновении определенного события. Рассмотрим простой пример:"
        },
        {
          "id": "code-52-1",
          "contentType": "code",
          "content": "function callback(name) {\n    alert(`Привет, ${name}!`)\n}\n\nfunction outer(cb) {\n    const name = prompt('Пожалуйста, введите свое имя')\n    cb(name)\n}\nouter(callback)"
        },
        {
          "id": "text-52-2",
          "contentType": "text",
          "content": "В приведенном примере функция outer запрашивает имя пользователя и записывает его в переменную name. Затем данная функция передает name функции callback, которая выводит приветствие с именем пользователя."
        },
        {
          "id": "nav-52-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/callbacks",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "97a8df07-c6a3-418a-828d-1aafd66257c3",
      "title": "54. Зачем нужны колбэки?",
      "data": [
        {
          "id": "text-53-1",
          "contentType": "text",
          "content": "Колбэки нужны, поскольку JavaScript - язык, управляемый событиями. Это означает, что, например, вместо ожидания получения ответа на запрос или завершения обработки определенного события, JavaScript продолжает реагировать на другие события. Рассмотрим пример, в котором одна функция обращается к интерфейсу, а другая - выводит сообщение в консоль:"
        },
        {
          "id": "code-53-1",
          "contentType": "code",
          "content": "function first () {\n    // имитируем обращение к API\n    setTimeout(() => console.log('Вызвана первая функция'), 1000)\n}\n\nfunction second () {\n    console.log('Вызвана вторая функция')\n}\n\nfirst()\nsecond()\n// сначала будет выведено \"Вызвана вторая функция\", затем \"Вызвана первая функция\""
        },
        {
          "id": "text-53-2",
          "contentType": "text",
          "content": "Как видите, JavaScript не ожидает завершения первой функции, а продолжает выполнение кода. Поэтому колбэки используются для имитации асинхронности, предотвращая блокировку основного потока выполнения программы."
        },
        {
          "id": "nav-53-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/callbacks",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "f3ed99d0-7292-4643-b256-3a28041ee781",
      "title": "55. Что такое ад колбэков?",
      "data": [
        {
          "id": "text-54-1",
          "contentType": "text",
          "content": "Ад колбэков - это антипаттерн, когда множество функций обратного вызова вложены друг в друга для реализации асинхронной логики. Такая структура кода сложна для восприятия и поддержки. Это может выглядеть так:"
        },
        {
          "id": "code-54-1",
          "contentType": "code",
          "content": "function first () {\n    return function second () {\n        return function third () {\n            return function fourth () {\n                // и т.д.\n            }\n        }\n    }\n}"
        },
        {
          "id": "text-54-2",
          "contentType": "text",
          "content": "Такой подход к написанию кода считается плохой практикой, кроме случаев каррирования, частичного применения или композиции функций."
        },
        {
          "id": "nav-54-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/callbacks",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "980b9712-d734-41df-87ab-fe1fc4680c21",
      "title": "56. Что такое события, отправляемые сервером (server-sent events, SSE)?",
      "data": [
        {
          "id": "text-55-1",
          "contentType": "text",
          "content": "События, отправляемые сервером - это технология пуш-уведомлений, позволяющая браузерам получать от сервера обновленные данные через HTTP-соединение без отправки запроса. Это один из способов коммуникации клиента и сервера, когда сообщения отправляются только сервером. Данная технология используется для обновления Facebook/Twitter, цен в магазинах, новостных лент и т.д."
        },
        {
          "id": "nav-55-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/server-sent-events",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Server-sent_events",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "1a446260-99f2-4078-9af0-d3a23f35fa7c",
      "title": "57. Как получать сообщения (уведомления или события), отправленные сервером?",
      "data": [
        {
          "id": "text-56-1",
          "contentType": "text",
          "content": "Для этого используется объект EventSource:"
        },
        {
          "id": "code-56-1",
          "contentType": "code",
          "content": "if('EventSource' in window) {\n    const source = new EventSource('sse.js')\n    source.addEventListener('message', event => document.querySelector('output')\n        .textContent = event.data)\n}"
        },
        {
          "id": "nav-56-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/server-sent-events",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/EventSource",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "45eeb599-aea3-4587-9438-fb4634d69744",
      "title": "58. Как проверить поддержку SSE браузером?",
      "data": [
        {
          "id": "text-57-1",
          "contentType": "text",
          "content": "Это делается так:"
        },
        {
          "id": "code-57-1",
          "contentType": "code",
          "content": "if (contentTypeof EventSource !== 'undefined') {\n    // код\n} else {\n    // SSE не поддерживается\n}\n\n// или\n('EventSource' in window)\n    ? console.log('ok')\n    : console.warn('!не ok')"
        },
        {
          "id": "text-57-2",
          "contentType": "text",
          "content": "По данным CanIUse на сегодняшний день SSE поддерживается 95% браузеров."
        },
        {
          "id": "nav-57-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/server-sent-events",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Server-sent_events",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "6763956d-e001-414b-a1cd-724d53022ec8",
      "title": "59. Какие события возникают при работе с SSE?",
      "data": [
        {
          "id": "text-58-1",
          "contentType": "text",
          "content": "Вот список этих событий:"
        },
        {
          "id": "table-58-1",
          "contentType": "table",
          "content": [
            [
              "Событие",
              "Описание"
            ],
            [
              "open",
              "Возникает при открытии соединения с сервером"
            ],
            [
              "message",
              "Возникает при получении сообщения от сервера"
            ],
            [
              "error",
              "Возникает при выбрасывании исключения"
            ]
          ]
        },
        {
          "id": "nav-58-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/server-sent-events",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Server-sent_events",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "7fd5e4e8-7aee-4b98-8ca9-6dcc4e37c0d9",
      "title": "60. Назовите основные правила работы с промисами",
      "data": [
        {
          "id": "text-59-1",
          "contentType": "text",
          "content": "Основными правилами работы с промисами является следующее:"
        },
        {
          "id": "list-59-1",
          "contentType": "list",
          "content": [
            "Промис - это объект, содержащий встроенный или стандартный метод then()",
            "Стадия ожидания промиса, обычно, заканчивается стадией его выполнения или отклонения",
            "Состояние выполненного или отклоненного промиса не должно меняться после его разрешения",
            "После разрешения промиса его значение также не должно меняться"
          ]
        },
        {
          "id": "nav-59-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/promise-basics",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "ed74b66e-c633-4f99-bfe8-8a7d4196e894",
      "title": "61. Что такое колбэк в колбэке?",
      "data": [
        {
          "id": "text-60-1",
          "contentType": "text",
          "content": "Вы можете вкладывать колбеки друг в друга с целью последовательного выполнения определенных операций:"
        },
        {
          "id": "code-60-1",
          "contentType": "code",
          "content": "loadScript('/script1.js', script => {\n    console.log(`Скрипт ${script} загружен`)\n\n    loadScript('/script2.js', script => {\n        console.log(`Скрипт ${script} загружен`)\n\n        loadScript('/script3.js', script => {\n            console.log(`Скрипт ${script} загружен`)\n        })\n    })\n})"
        },
        {
          "id": "nav-60-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/callbacks",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "e8e9bea7-1725-4673-86dc-8f566428ab0f",
      "title": "62. Что такое цепочка промисов?",
      "data": [
        {
          "id": "text-61-1",
          "contentType": "text",
          "content": "Последовательное выполнение нескольких асинхронных задач с помощью промисов называется цепочкой промисов. Рассмотрим пример:"
        },
        {
          "id": "code-61-1",
          "contentType": "code",
          "content": "new Promise((resolve, reject) => {\n    const id = setTimeout(() => {\n        resolve(1)\n        clearTimeout(id)\n    }, 1000)\n}).then(result => {\n    console.log(result) // 1\n    return result * 2\n}).then(result2 => {\n    console.log(result2) // 2\n    return result2 * 3\n}).then(result3 => {\n    console.log(result3) // 6\n}).catch(error => console.error(error))"
        },
        {
          "id": "text-61-2",
          "contentType": "text",
          "content": "Алгоритм выполнения:"
        },
        {
          "id": "list-61-1",
          "contentType": "list",
          "content": [
            "Первый промис разрешается со значением 1",
            "После этого, первый метод then() выводит это значение в консоль и возвращает его, умножая на 2",
            "Второй then() выводит результат первого then() в консоль (2) и возвращает результат, умножая его на 3",
            "Последний then() выводит результат второго then() в консоль (6)",
            "Блок catch служит для обработки ошибок"
          ]
        },
        {
          "id": "nav-61-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/promise-basics",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "7eb713cc-9ea1-431d-aa14-30f60d685b59",
      "title": "63. Что такое Promise.all()?",
      "data": [
        {
          "id": "text-62-1",
          "contentType": "text",
          "content": "Promise.all() - это промис, принимающий массив других промисов в качестве аргумента и возвращающий результаты выполненных промисов или ошибку при отклонении одного из них. Синтаксис:"
        },
        {
          "id": "code-62-1",
          "contentType": "code",
          "content": "Promise.all([Promise1, Promise2, Promise3])\n    .then(results => console.log(results))\n    .catch(error => console.error(error))"
        },
        {
          "id": "text-62-2",
          "contentType": "text",
          "content": "Помните, что порядок получения результатов зависит от порядка промисов в массиве."
        },
        {
          "id": "nav-62-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/promise-api",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise/all",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "3f64857c-f8d2-4403-880e-50215e2820f6",
      "title": "64. Что такое Promise.race()?",
      "data": [
        {
          "id": "text-63-1",
          "contentType": "text",
          "content": "Promise.race() возвращает результат первого выполненного или отклоненного промиса из переданных ему в виде массива промисов:"
        },
        {
          "id": "code-63-1",
          "contentType": "code",
          "content": "const promise1 = new Promise((resolve, reject) => setTimeout(resolve, 500, 'раз'))\n\nconst promise2 = new Promise((resolve, reject) => setTimeout(resolve, 100, 'два'))\n\nPromise.race([promise1, promise2]).then(value => console.log(value)) // \"два\""
        },
        {
          "id": "nav-63-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/promise-api",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise/race",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "bc9fc09d-fd8d-45cf-b908-1a4c5318e58a",
      "title": "65. Что такое строгий режим?",
      "data": [
        {
          "id": "text-64-1",
          "contentType": "text",
          "content": "Для включения строго режима используется инструкция 'use strict' (или \"use strict\") в начале всего кода или отдельной функции. Строгий режим был представлен в ES5. В данном режиме запрещены некоторые действия и выбрасывается больше исключений."
        },
        {
          "id": "nav-64-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/strict-mode",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "a270ca43-a27d-4f64-824f-a6178d1527d2",
      "title": "66. Зачем нужен строгий режим?",
      "data": [
        {
          "id": "text-65-1",
          "contentType": "text",
          "content": "Строгий режим позволяет писать более безопасный код, предотвращая возникновение многих ошибок. Например, он запрещает случайное создание глобальных переменных (без ключевого слова, variable = value), присваивание значения свойству, доступному только для чтения, свойству, которое можно получить только с помощью геттера, несуществующему свойству и несуществующей переменной или объекту. В нестрогом режиме во всех этих случаях исключение не выбрасывается."
        },
        {
          "id": "nav-65-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/strict-mode",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "c32dc41a-d4fa-4e1e-ba37-9cb5c10fca2c",
      "title": "67. Как включить строгий режим?",
      "data": [
        {
          "id": "text-66-1",
          "contentType": "text",
          "content": "Строгий режим включается с помощью инструкции 'use strict' (или \"use strict\") в начале кода или функции. Обычно, данная инструкция указывается в самом начале скрипта, т.е. в глобальном пространстве имен:"
        },
        {
          "id": "code-66-1",
          "contentType": "code",
          "content": "'use strict'\nx = 3.14 // ReferenceError: \"x\" is not defined"
        },
        {
          "id": "text-66-2",
          "contentType": "text",
          "content": "Если 'use strict' указывается в функции, то действие строгого режима распространяется только на эту функцию:"
        },
        {
          "id": "code-66-2",
          "contentType": "code",
          "content": "x = 3.14 // все в порядке\nf() // ReferenceError: \"y\" is not defined\n\nfunction f () {\n    'use strict'\n    y = 3.14\n}"
        },
        {
          "id": "nav-66-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/strict-mode",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "b01b27a8-1dde-4e9f-b927-ff72398b8d84",
      "title": "68. Для чего используется двойное отрицание?",
      "data": [
        {
          "id": "text-67-1",
          "contentType": "text",
          "content": "Двойное отрицание (!!) преобразует значение в логическое. Если значение является ложным, то возвращается false, иначе - true:"
        },
        {
          "id": "code-67-1",
          "contentType": "code",
          "content": "const x = 1\nconsole.log(x) // 1\nconsole.log(!!x) // true\nconst y = ''\nconsole.log(y) // ''\nconsole.log(!!str) // false"
        },
        {
          "id": "text-67-2",
          "contentType": "text",
          "content": "Обратите внимание: !! - это не отдельный оператор, а два оператора !."
        },
        {
          "id": "nav-67-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Logical_NOT",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "jsr",
              "src": "https://learn.javascript.ru/logical-ops",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "b27487da-22d6-42ea-8415-191a713f0d8b",
      "title": "69. Для чего используется оператор delete?",
      "data": [
        {
          "id": "text-68-1",
          "contentType": "text",
          "content": "Данный оператор служит для удаления свойств объектов и значений этих свойств:"
        },
        {
          "id": "code-68-1",
          "contentType": "code",
          "content": "'use strict'\nconst user = {\n    name: 'Ванька',\n    age: 30\n}\n\ndelete user.age\n\nconsole.log(user) // { name: \"Ванька\" }\n\ndelete user // SyntaxError: Delete of an unqualified identifier in strict mode"
        },
        {
          "id": "text-68-2",
          "contentType": "text",
          "content": "Обратите внимание, что в нестрогом режиме попытка удаления объекта тихо завершится ничем."
        },
        {
          "id": "text-68-3",
          "contentType": "text",
          "content": "Поскольку массив - это тоже объект, применение delete к элементу массива удалит его значение и запишет в него undefined, т.е. индекс удаленного элемента массива сохранится и длина массива не изменится."
        },
        {
          "id": "nav-68-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/object#literaly-i-svoystva",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/delete",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "388c321a-ff6e-44ea-86df-2de30fb08a1b",
      "title": "70. Для чего используется оператор contentTypeof?",
      "data": [
        {
          "id": "text-69-1",
          "contentType": "text",
          "content": "Данный оператор используется для определения типа переменной или выражения:"
        },
        {
          "id": "code-69-1",
          "contentType": "code",
          "content": "contentTypeof 1 // number\ncontentTypeof [] // object\ncontentTypeof 'Ванька' // string\ncontentTypeof (1 + 2) // number\n\ncontentTypeof null // object\ncontentTypeof NaN // number"
        },
        {
          "id": "nav-69-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/contentTypes#contentType-contentTypeof",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/contentTypeof",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "ecf70e02-e22d-4385-944d-025e751bd0ec",
      "title": "71. Что такое undefined?",
      "data": [
        {
          "id": "text-70-1",
          "contentType": "text",
          "content": "undefined - это неопределенное (но не отсутствующее) стандартное значение (значение по умолчанию) переменной, которой не было присвоено значение, а также необъявленной переменной. Это один из примитивных типов данных:"
        },
        {
          "id": "code-70-1",
          "contentType": "code",
          "content": "let name\nconsole.log(contentTypeof name) // undefined\nconsole.log(contentTypeof age) // undefined"
        },
        {
          "id": "text-70-2",
          "contentType": "text",
          "content": "Данное значение может присваиваться переменной явно:"
        },
        {
          "id": "code-70-2",
          "contentType": "code",
          "content": "user = undefined"
        },
        {
          "id": "nav-70-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/contentTypes#znachenie-undefined",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/undefined",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "962a1d9f-ab2e-4c1a-acdd-7887f6e823b2",
      "title": "72. Что такое null?",
      "data": [
        {
          "id": "text-71-1",
          "contentType": "text",
          "content": "null - значение, представляющее собой отсутствие значения, установленное явно. Это один из примитивных типов данных. С помощью null можно удалить значение переменной:"
        },
        {
          "id": "code-71-1",
          "contentType": "code",
          "content": "const user = null\nconsole.log(contentTypeof user) // object"
        },
        {
          "id": "nav-71-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/contentTypes#znachenie-null",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/null",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "1a0788e9-7d41-4c04-90d5-faef155cceea",
      "title": "73. В чем разница между null и undefined?",
      "data": [
        {
          "id": "text-72-1",
          "contentType": "text",
          "content": "Основные отличия состоят в следующем:"
        },
        {
          "id": "table-72-1",
          "contentType": "table",
          "content": [
            [
              "Null",
              "Undefined"
            ],
            [
              "Присваивается в качестве индикатора отсутствия значения",
              "Является значением по умолчанию для переменных, которым не было присвоено значение, или необъявленных переменных"
            ],
            [
              "Тип - object",
              "Тип - undefined"
            ],
            [
              "Примитивный тип, означающий нуль, отсутствие значения или ссылки",
              "Примитивный тип, означающий, что переменной не было присвоено значения"
            ],
            [
              "Указывает на отсутствие значения переменной",
              "Указывает на отсутствие переменной или неопределенность ее значения"
            ]
          ]
        },
        {
          "id": "nav-72-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/contentTypes#znachenie-undefined",
              "title": "undefined"
            },
            {
              "id": "subnav-1-1",
              "name": "jsr",
              "src": "https://learn.javascript.ru/contentTypes#znachenie-null",
              "title": "null"
            },
            {
              "id": "subnav-1-2",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/undefined",
              "title": "undefined"
            },
            {
              "id": "subnav-1-3",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/null",
              "title": "null"
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "6f5a2122-91ca-4710-a351-c4a9e7f1d1f6",
      "title": "74. Что такое eval?",
      "data": [
        {
          "id": "text-73-1",
          "contentType": "text",
          "content": "Функция eval() вычисляет переданную ей строку. Строка может быть выражением, переменной, одним или несколькими операторами:"
        },
        {
          "id": "code-73-1",
          "contentType": "code",
          "content": "console.log(eval('1 + 2')) // 3\n\n// пример с каррированием\nconst curryCalc = x => operator => y =>\n    new Promise((resolve, reject) =>\n        resolve(eval(`x${operator}y`))\n    ).then(\n        result => console.log(result),\n        error => console.error('Некорректная операция!')\n    )\n\ncurryCalc(1)('+')(2) // 3\ncurryCalc(4)('-')(3) // 1\ncurryCalc(5)('x')(6) // Некорректная операция!"
        },
        {
          "id": "text-73-2",
          "contentType": "text",
          "content": "Использовать не рекомендуется."
        },
        {
          "id": "nav-73-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/eval",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/eval",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "9eb45437-53cc-4a77-9e04-67c2263b798b",
      "title": "75. Как получить доступ к истории браузера?",
      "data": [
        {
          "id": "text-74-1",
          "contentType": "text",
          "content": "Информацию об истории перемещений между страницами в браузере содержит свойство history объекта window. Для перехода к предыдущей или следующей странице следует использовать методы back(), next() или go():"
        },
        {
          "id": "code-74-1",
          "contentType": "code",
          "content": "const goBack = () => {\n    history.back()\n    // или\n    history.go(-1)\n}\n\nconst goForward = () => history.forward()"
        },
        {
          "id": "nav-74-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/History",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "bdadd255-e44f-4a79-9bc7-1ebfe2de3b47",
      "title": "76. Какие типы данных существуют в JavaScript?",
      "data": [
        {
          "id": "text-75-1",
          "contentType": "text",
          "content": "В JavaScript есть 8 основных типов:"
        },
        {
          "id": "list-75-1",
          "contentType": "list",
          "content": [
            "number для любых чисел: целочисленных или чисел с плавающей точкой, целочисленные значения ограничены диапазоном ±253",
            "bigint для целых чисел произвольной длины",
            "string для строк. Строка может содержать один или больше символов, нет отдельного символьного типа",
            "boolean для true/false",
            "null для неизвестных значений – отдельный тип, имеющий одно значение null",
            "undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined",
            "object для более сложных структур данных",
            "symbol для уникальных идентификаторов"
          ]
        },
        {
          "id": "nav-75-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/contentTypes",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Data_structures",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "83d463eb-049a-4ac2-bf84-867f726ae9fc",
      "title": "77. Что делает isNaN()?",
      "data": [
        {
          "id": "text-76-1",
          "contentType": "text",
          "content": "Функция isNaN() преобразует значение в число и проверяет, является ли оно NaN."
        },
        {
          "id": "code-76-1",
          "contentType": "code",
          "content": "isNaN('hello') // true\nisNaN(100) // false"
        },
        {
          "id": "text-76-2",
          "contentType": "text",
          "content": "Более надежной версией данной функции является метод Number.isNaN(), представленный в ES6."
        },
        {
          "id": "nav-76-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/number",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/isNaN",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "e05d1940-40a7-4eb6-8a12-3c577a72742a",
      "title": "78. В чем разница между необъявленными и неопределенными переменными?",
      "data": [
        {
          "id": "text-77-1",
          "contentType": "text",
          "content": "Основные отличия заключаются в следующем:"
        },
        {
          "id": "table-77-1",
          "contentType": "table",
          "content": [
            [
              "Необъявленные",
              "Неопределенные"
            ],
            [
              "Не существуют в программе",
              "Были объявлены без присвоения значения"
            ],
            [
              "Попытка доступа заканчивается ошибкой",
              "При попытке получить доступ возвращается undefined"
            ],
            [
              "Поднимается (всплывает) в начало текущей области видимости",
              "Также поднимается, но без присвоенного значения, т.е. со значением undefined (поднимается только объявление, но не инициализация)"
            ]
          ]
        },
        {
          "id": "nav-77-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/variables",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/Variable",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "8a43af11-100b-4060-9425-3f5b7d890d02",
      "title": "79. Что такое глобальные переменные?",
      "data": [
        {
          "id": "text-78-1",
          "contentType": "text",
          "content": "В браузере глобальные функции и переменные, объявленные с помощью ключевого слова \"var\", или без использованию ключевого слова (в нестрогом режиме), становятся свойствами глобального объекта window (не работает в модулях). Такие переменные доступны из любого места программы. Использовать глобальные переменные не рекомендуется. При необходимости создания глобальной переменной лучше сделать это явно:"
        },
        {
          "id": "code-78-1",
          "contentType": "code",
          "content": "window.currentUser = {\n    name: 'Ванька'\n}\n\n// или\nglobalThis.currentUser = {\n    name: 'Ванька'\n}\n\nconsole.log(currentUser.name) // Ванька"
        },
        {
          "id": "nav-78-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/global-object",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "aa731352-362c-4a67-8586-c6ce32c8ac0f",
      "title": "80. Какие проблемы влечет за собой создание глобальных переменных?",
      "data": [
        {
          "id": "text-79-1",
          "contentType": "text",
          "content": "Создание глобальных переменных приводит к загрязнению глобального пространства имен, что может вызвать конфликт между названиями переменных. Это также усложняет отладку и тестирование кода."
        },
        {
          "id": "nav-79-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/global-object",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "058bd99f-c123-4848-9608-12885adbdc12",
      "title": "81. Что такое NaN?",
      "data": [
        {
          "id": "text-80-1",
          "contentType": "text",
          "content": "Глобальное свойство NaN является значением, представляющим собой не число (Not-a-Number). Точнее, NaN указывает на то, что значение является неправильным, но все-таки числом. Поэтому contentTypeof NaN возвращает number."
        },
        {
          "id": "code-80-1",
          "contentType": "code",
          "content": "parseInt('bla') // NaN\nMath.sqrt(-1) // NaN"
        },
        {
          "id": "nav-80-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/NaN",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "11dcdb1e-4237-41b4-9c9c-19cf864fc8fe",
      "title": "82. Что делает isFinite()?",
      "data": [
        {
          "id": "text-81-1",
          "contentType": "text",
          "content": "Глобальная функция isFinite() преобразует аргумент в число и возвращает true, если оно является обычным (конечным) числом, т.е. не NaN, Infinity (положительная бесконечность), -Infinity (отрицательная бесконечность). В противном случае, возвращается false."
        },
        {
          "id": "code-81-1",
          "contentType": "code",
          "content": "isFinite(Infinity) // false\nisFinite(-Infinity) // false\nisFinite(NaN) // false\n\nisFinite(100) // true"
        },
        {
          "id": "text-81-2",
          "contentType": "text",
          "content": "Также существует метод Number.isFinite(), который в отличие от isFinite() не преобразует аргумент в число перед проверкой."
        },
        {
          "id": "nav-81-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/isFinite",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "jsr",
              "src": "https://learn.javascript.ru/number",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "3a8874ca-1926-4916-8156-13f6268a23f3",
      "title": "83. Что такое поток или рспространение событий (event flow/propagation)?",
      "data": [
        {
          "id": "text-82-1",
          "contentType": "text",
          "content": "Поток событий (распространение событий) - это порядок, в котором событие возникает на странице. Когда вы кликаете по элементу, вложенному в другие элементы, перед тем как событие достигнет целевого элемента, оно последовательно пройдет через всех его предков, начиная от глобального объекта window. Существует три стадии распространения события:"
        },
        {
          "id": "list-82-1",
          "contentType": "list",
          "content": [
            "Сверху вниз - стадия захвата или погружения",
            "Целевая стадия",
            "Снизу вверх - стадия всплытия или поднятия (не путать с поднятием переменных - hoisting)"
          ]
        },
        {
          "id": "nav-82-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/bubbling-and-capturing",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "67981ff6-8421-444f-a06f-85da322e99a1",
      "title": "84. Что такое всплытие события?",
      "data": [
        {
          "id": "text-83-1",
          "contentType": "text",
          "content": "Всплытие - это стадия распространения события, когда событие сначала регистрируется на целевом элементе, а затем по цепочке из предков данного элемента поднимается до самого верхнего (внешнего) элемента - глобального объекта window."
        },
        {
          "id": "nav-83-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/bubbling-and-capturing",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "cd170374-5cbb-4ad8-830c-64d6d3c5b08f",
      "title": "85. Что такое погружение или захват события?",
      "data": [
        {
          "id": "text-84-1",
          "contentType": "text",
          "content": "Погружение - это стадия возникновения события, когда оно сначала регистрируется на самом верхнем (внешнем) элементе (глобальном объекте window), а затем спускается вниз по цепочке из предков до целевого элемента."
        },
        {
          "id": "nav-84-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/bubbling-and-capturing",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "bb3c0614-062f-4561-ac4f-ac4c245a5c4a",
      "title": "86. Как отправить форму на обработку?",
      "data": [
        {
          "id": "text-85-1",
          "contentType": "text",
          "content": "Это можно сделать разными способами:"
        },
        {
          "id": "code-85-1",
          "contentType": "code",
          "content": "function submitForm() {\n    document.forms[0].submit()\n}\n\nform.onsubmit = function(event) {\n    event.preventDefault()\n    // код\n}\n\nform.addEventListener('submit', event => {\n    event.preventDefault()\n    // код\n})"
        },
        {
          "id": "text-85-2",
          "contentType": "text",
          "content": "Любая кнопка в форме по умолчанию имеет тип submit, т.е. служит для отправки формы."
        },
        {
          "id": "nav-85-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/forms-submit",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/HTMLFormElement/submit",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "73d52dbb-4a6e-46b1-976c-11433c9f846a",
      "title": "87. Как получить информацию об операционной системе?",
      "data": [
        {
          "id": "text-86-1",
          "contentType": "text",
          "content": "Данную информацию содержит глобальный объект navigator. Некоторую часть этой информации можно получить через его свойство platform:"
        },
        {
          "id": "code-86-1",
          "contentType": "code",
          "content": "console.log(navigator.platform)"
        },
        {
          "id": "nav-86-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Navigator",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "c82cb292-dd9e-4e36-beda-32b3e6c6cb6c",
      "title": "88. В чем разница между событиями DOMContentLoaded и load?",
      "data": [
        {
          "id": "text-87-1",
          "contentType": "text",
          "content": "Событие DOMContentLoaded возникает, когда первоначальный HTML документ полностью загружен и разобран без ожидания полной загрузки таблиц стилей, изображений или фреймов. Событие load возникает после полной загрузки страницы, включая все дополнительные ресурсы."
        },
        {
          "id": "nav-87-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/onload-ondomcontentloaded",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Document/DOMContentLoaded_event",
              "title": "DOMContentLoaded"
            },
            {
              "id": "subnav-1-2",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/Events/load",
              "title": "load"
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "56c591a7-c963-4924-93e9-8b92dd1d29e7",
      "title": "89. В чем разница между нативными, хостовыми (принадлежащими среде выполнения кода) и пользовательскими объектами?",
      "data": [
        {
          "id": "text-88-1",
          "contentType": "text",
          "content": "Нативные объекты (native objects) являются частью языка и определяются в спецификации ECMAScript. Такими объектами являются, например, Number, String, Function, Object, Math, RegExp, Date и т.д. Хостовые объекты (host objects) предоставляются браузером или другой средой выполнения, например, Node.js. Такими объектами являются, например, window, document (DOM), XMLHttpRequest, Web API (стек вызовов - call stack, очередь задач - task queue) и др. Пользовательскими объектами (user objects) являются любые объекты, создаваемые в коде, например, объект, содержащий информацию о пользователе:"
        },
        {
          "id": "code-88-1",
          "contentType": "code",
          "content": "const user = {\n    name: 'Ванька',\n    age: 30\n}"
        },
        {
          "id": "nav-88-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/object",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "b4c5a9a2-2542-48a9-98c1-a8df48398ef0",
      "title": "90. Какие средства используются для откладки кода?",
      "data": [
        {
          "id": "text-89-1",
          "contentType": "text",
          "content": "Такими средствами являются:"
        },
        {
          "id": "list-89-1",
          "contentType": "list",
          "content": [
            "Инструменты разработчика в браузере, например, Chrome DevTools",
            "Выражение debugger",
            "Старый-добрый console.log()"
          ]
        },
        {
          "id": "nav-89-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/debugging-chrome",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/debugger",
              "title": "debugger"
            },
            {
              "id": "subnav-1-2",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Console",
              "title": "Console"
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "e275169e-51db-426b-9055-6044bdc72470",
      "title": "91. В чем заключаются преимущества и недостатки промисов по сравнению с колбэками?",
      "data": [
        {
          "id": "text-90-1",
          "contentType": "text",
          "content": "Преимущества:"
        },
        {
          "id": "list-90-1",
          "contentType": "list",
          "content": [
            "Предотвращают ад колбэков",
            "Позволяют выполнять асинхронный код последовательно с помощью then()",
            "Позволяют выполнять асинхронный код параллельно с помощью Promise.all()",
            "Решают многие проблемы колбэков (слишком поздний или слишком ранний вызов, несколько вызовов вместо одного, скрытие ошибок)"
          ]
        },
        {
          "id": "text-90-2",
          "contentType": "text",
          "content": "Недостатки"
        },
        {
          "id": "list-90-2",
          "contentType": "list",
          "content": [
            "Код становится сложнее писать",
            "Для обеспечения поддержки старыми браузерами нужен полифил (таких браузеров на сегодняшний день почти не осталось)"
          ]
        },
        {
          "id": "nav-90-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/promise-basics",
              "title": "Промисы"
            },
            {
              "id": "subnav-1-1",
              "name": "jsr",
              "src": "https://learn.javascript.ru/callbacks",
              "title": "Колбэки"
            },
            {
              "id": "subnav-1-2",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise",
              "title": "Promise"
            },
            {
              "id": "subnav-1-3",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_%D0%BE%D0%B1%D1%80%D0%B0%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%D0%B0",
              "title": "Callback"
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "3c257427-3ff6-430e-aced-740f95c46ff6",
      "title": "92. В чем разница между атрибутом и свойством элемента?",
      "data": [
        {
          "id": "text-91-1",
          "contentType": "text",
          "content": "Когда браузер загружает страницу, он разбирает HTML и генерирует из него DOM-объекты. Для узлов-элементов большинство стандартных HTML-атрибутов автоматически становятся свойствами DOM-объектов. Т.е. атрибут элемента указывается в разметке, а его свойство в DOM. Например, для тега body с атрибутом id=\"page\" у DOM-объекта будет свойство body.id=\"page\"."
        },
        {
          "id": "code-91-1",
          "contentType": "code",
          "content": "<input contentType=\"text\" value=\"Доброе утро!\">\n// данный элемент имеет два атрибута: contentType и value\n\nconst input = document.querySelector('input')\n// получаем атрибут\nconsole.log(input.getAttribute('value'))\n// получаем свойство\nconsole.log(input.value)\n\n// меняем значение атрибута\ninput.setAttribute('value', 'Добрый вечер!')\n// меняем значение свойства\ninput.value = 'Добрый вечер!'"
        },
        {
          "id": "text-91-2",
          "contentType": "text",
          "content": "Обратите внимание, что спецификация ECMAScript также определяет атрибуты свойств объекта - [[Value]], [[Writable]], [[Enumerable]] и [[Configurable]]."
        },
        {
          "id": "nav-91-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/dom-attributes-and-properties",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "070c40c9-f55d-48f0-95c5-22531c1587d5",
      "title": "93. Что такое политика общего происхождения (same-origin policy, SOP)?",
      "data": [
        {
          "id": "text-92-1",
          "contentType": "text",
          "content": "Политика общего происхождения (одинакового источника) блокирует доступ к данным из другого источника. Источником является сочетание протокола, хоста и порта. По умолчанию, совместное использование ресурсов (cross-origin resource sharing, CORS) запрещено, т.е. данные предоставляются только в ответ на запрос из того же источника, в котором они находятся. Это поведение можно изменить с помощью специальных HTTP-заголовков."
        },
        {
          "id": "nav-92-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/cross-window-communication",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/Security/Same-origin_policy",
              "title": "SOP"
            },
            {
              "id": "subnav-1-2",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/HTTP/CORS",
              "title": "CORS"
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "f1b444d1-e05d-452e-b0af-bbce91b81da6",
      "title": "94. Что делает void 0?",
      "data": [
        {
          "id": "text-93-1",
          "contentType": "text",
          "content": "Оператор void вычисляет переданное выражение и возвращает undefined. Обычно, когда мы кликаем по ссылке, браузер загружает новую сраницу или перезагружает текущую. С помощью выражения \"void(0)\" можно этого избежать:"
        },
        {
          "id": "code-93-1",
          "contentType": "code",
          "content": "<a href=\"javascript:void(0)\" onclick=\"alert('Привет!')\">Нажми на меня!\n</a>"
        },
        {
          "id": "text-93-2",
          "contentType": "text",
          "content": "Перезагрузку страницы также можно предотвратить с помощью простой заглушки:"
        },
        {
          "id": "code-93-2",
          "contentType": "code",
          "content": "<a href=\"#\">Битая ссылка</a>\n// в этом случае символ \"#\" добавляется к URL в адресной строке"
        },
        {
          "id": "nav-93-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/void",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "70c9de91-f99d-47de-a291-45d4903437ea",
      "title": "95. JavaScript - это компилируемый или интерпретируемый язык программирования?",
      "data": [
        {
          "id": "text-94-1",
          "contentType": "text",
          "content": "Сам по себе JavaScript - это интерпретируемый язык программирования. Движок (engine) разбирает код, интерпретирует каждую строку и выполняет ее. Однако, в современных браузерах используется технология под названием \"компиляция на лету\" (just-in-time, JIT compilation), когда код компилируется (оптимизируется) перед выполнением. Это увеличивает время подготовки к выполнению кода, но существенно ускоряет само выполнение. Например, в V8, движке, используемом в Chrome и Node.js, для разбора кода применяется интерпретатор Ignition, а для оптимизации кода - компилятор TurboFan."
        },
        {
          "id": "nav-94-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/intro",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "29966039-d203-4a5f-ad46-647cddc750b9",
      "title": "96. Чувствителен ли JavaScript к регистру?",
      "data": [
        {
          "id": "text-95-1",
          "contentType": "text",
          "content": "Да, JavaScript чувствителен к регистру. Поэтому ключевые слова, названия переменных, функций и объектов должны быть идентичными при их использовании. Например, const somename и const someName - это разные переменные, contentTypeof(1) - number, а contentTypeOf 1 - ReferenceError: contentTypeOf is not defined."
        },
        {
          "id": "nav-95-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/intro",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "4e94b2f6-fd30-43ed-aea6-86aa96c699ce",
      "title": "97. Связаны ли Java и JavaScript?",
      "data": [
        {
          "id": "text-96-1",
          "contentType": "text",
          "content": "Нет, это два разных языка программирования. Однако, они оба относятся к объектно-ориентированным языкам и, как и множество других языков, используют похожий синтаксис (if, else, for, switch, break, continue и т.д.). По сути, Java в JavaScript - это маркетинговый ход."
        },
        {
          "id": "nav-96-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/intro",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "2159a59d-7cfd-401c-91f5-7ea07a15a458",
      "title": "98. Что такое событие (event)?",
      "data": [
        {
          "id": "text-97-1",
          "contentType": "text",
          "content": "Событие - это реакция браузера на определенное действие. Таким действием может быть действие пользователя, например, нажатие кнопки или ввод текста, загрузка страницы, получение ответа на запрос и т.д. (действия, приводящие к возникновению событий, не обязательно зависят от пользователя). События регистрируются с целью их дальнейшей обработки."
        },
        {
          "id": "code-97-1",
          "contentType": "code",
          "content": "button.onclick = () => alert('Привет!')\n\ninput.addEventListener('change', function() {\n    p.textContent = this.value\n})\n\nwindow.onload = () => console.log('Страница полностью загружена')"
        },
        {
          "id": "nav-97-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Event",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "jsr",
              "src": "https://learn.javascript.ru/introduction-browser-events#event-object",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "a65a41cd-add7-4a10-a4ac-e535c4dd61aa",
      "title": "99. Кто придумал JavaScript?",
      "data": [
        {
          "id": "text-98-1",
          "contentType": "text",
          "content": "JavaScript был создан Бренданом Эйхом во время его работы в Netscape Communications. Первоначально язык назывался Mocha, затем был переименован в LiveScript и предназначался как для программирования на стороне клиента, так и для программирования на стороне сервера (там он должен был называться LiveWire)."
        },
        {
          "id": "nav-98-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/intro",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "68aa7949-438b-41e7-bb0c-cc054379a327",
      "title": "100. Для чего используется preventDefault()?",
      "data": [
        {
          "id": "text-99-1",
          "contentType": "text",
          "content": "Данный метод отключает стандартную обработку событий браузером. Например, с его помощью можно предотвратить отправку формы или открытие новой страницы при клике по ссылке."
        },
        {
          "id": "code-99-1",
          "contentType": "code",
          "content": "link.addEventListener('click', event => {\n    event.preventDefault()\n    // код\n})"
        },
        {
          "id": "text-99-2",
          "contentType": "text",
          "content": "Обратите внимание: не все события отменяемы."
        },
        {
          "id": "nav-99-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/default-browser-action",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Event/preventDefault",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "d9d48677-9c34-4c9c-8ef0-74bbc1481a63",
      "title": "101. Для чего используется stopPropagation()?",
      "data": [
        {
          "id": "text-100-1",
          "contentType": "text",
          "content": "Данный метод используется для предотвращения всплытия или поднятия события вверх по цепочке из предков целевого элемента. Другими словами, он прекращает передачу события от целевого элемента к его предкам. Рассмотрим пример:"
        },
        {
          "id": "code-100-1",
          "contentType": "code",
          "content": "<div onclick=\"f2()\">\n    <div onclick=\"f1()\"></div>\n</div>\n\nfunction f1(event) {\n    event.stopPropagation()\n    console.log('Внутренний контейнер')\n}\n\nfunction f2() {\n    console.log('Внешний контейнер')\n}"
        },
        {
          "id": "text-100-2",
          "contentType": "text",
          "content": "При клике по вложенному контейнеру в консоль выводится сообщение \"Внутренний контейнер\". Если убрать event.stopPropagation(), то при клике по вложенному контейнеру, в консоль будут выведены оба сообщения."
        },
        {
          "id": "nav-100-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/bubbling-and-capturing",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Event/stopPropagation",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "40786986-bcd8-450b-93c1-c2dbd5e246fb",
      "title": "102. Что делает инструкция return false?",
      "data": [
        {
          "id": "text-101-1",
          "contentType": "text",
          "content": "Данная инструкция используется в обработчиках событий для:"
        },
        {
          "id": "list-101-1",
          "contentType": "list",
          "content": [
            "Отмены стандартного поведения браузера",
            "Предотвращения распространения события по DOM",
            "Остановки выполнения колбэка и возврата управления вызвавшей его функции"
          ]
        },
        {
          "id": "text-101-2",
          "contentType": "text",
          "content": "Обратите внимание: без указания возвращаемого значения оператор return возвращает undefined."
        },
        {
          "id": "nav-101-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/default-browser-action",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/return",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "23d28ac4-f5bb-4d8a-b1ab-bb357303999a",
      "title": "103. Что такое BOM?",
      "data": [
        {
          "id": "text-102-1",
          "contentType": "text",
          "content": "BOM или (Browser Object Model - объектная модель браузера) позволяет JavaScript взаимодействовать с браузером. Данная модель включает в себя такие объекты, как navigator, location, history, screen, XMLHttpRequest и т.п. Другими словами, BOM - это дополнительные объекты, предоставляемые браузером, чтобы работать со всем, кроме документа."
        },
        {
          "id": "text-102-2",
          "contentType": "text",
          "content": "Обратите внимание: BOM не стандартизирована, поэтому ее реализация может отличаться в разных браузерах."
        },
        {
          "id": "img-102-1",
          "contentType": "img",
          "content": "data:image/png;base64,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"
        },
        {
          "id": "nav-102-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/browser-environment",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "adc99a6d-89f4-4058-826b-731a213ea594",
      "title": "104. Для чего используется setTimeout()?",
      "data": [
        {
          "id": "text-103-1",
          "contentType": "text",
          "content": "Данный метод используется для отложенного выполнения задачи. Другими словами, он позволяет запустить выполнение функции или вычисление выражения через определенное время (в миллисекундах). В следующем примере мы выводим сообщение в консоль через 2 секунды:"
        },
        {
          "id": "code-103-1",
          "contentType": "code",
          "content": "setTimeout(() => console.log('Привет!'), 2000)\n\n// во избежание утечек памяти, рекомендуется делать так\nconst timer = setTimeout(() => {\n    console.log('Привет!')\n    clearTimeout(timer)\n}, 2000)"
        },
        {
          "id": "nav-103-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/settimeout-setinterval",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/WindowTimers/setTimeout",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "7a1b5272-818f-447f-a417-e1ec19b74c3b",
      "title": "105. Для чего используется setInterval()?",
      "data": [
        {
          "id": "text-104-1",
          "contentType": "text",
          "content": "Данный метод используется для периодического выполнения задачи. Другим словами, он позволяет запускать выполнение функции или вычисление выражения через определенный промежуток времени (в миллисекундах). В следующем примере мы выводим сообщение в консоль каждые 2 секунды:"
        },
        {
          "id": "code-104-1",
          "contentType": "code",
          "content": "setInterval(() => console.log('Привет!'), 2000)\n\n// во избежание утечек памяти, не забывайте отключать таймер\n// после достижения поставленной цели\nlet i = 0\nconst timer = setInterval(() => {\n    console.log('Привет!')\n    i++\n\n    if (i == 2) {\n        clearInterval(timer)\n    }\n}, 2000)"
        },
        {
          "id": "text-104-2",
          "contentType": "text",
          "content": "Во втором примере сообщение \"Привет!\" выведется в консоль два раза, после чего таймер будет остановлен"
        },
        {
          "id": "nav-104-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/settimeout-setinterval",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/WindowOrWorkerGlobalScope/setInterval",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "340bfbfb-84a9-44b9-b4a1-24bc7aa639b3",
      "title": "106. Почему JavaScript называют однопоточным (single threated)?",
      "data": [
        {
          "id": "text-105-1",
          "contentType": "text",
          "content": "JavaScript является однопоточным или синхронным языком программирования. Это означает, что в один момент времени может выполняться только одна задача. Если задача является сложной, ее выполнение может занять продолжительное время и все это время основной поток выполнения кода будет заблокирован. Блокировка потока, в свою очередь, означает отсутствие интерактивности на странице. Браузер перестает реагировать на действия пользователя и другие события. Для решения данной проблемы применяются колбэки, промисы, async/await, воркеры и другие инструменты для работы с асинхронным кодом. В JavaScript в отличие, например, от Java, Go или C++ нет возможности создавать дополнительные потоки или процессы."
        },
        {
          "id": "nav-105-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/intro",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "e9d35ddf-48bc-4cdb-aa46-a966cea556a8",
      "title": "107. Что такое делегирование событий (event delegation)?",
      "data": [
        {
          "id": "text-106-1",
          "contentType": "text",
          "content": "Делегирование событий - это техника, при которой событие регистрируется на родительском элементе для обработки событий, вызываемых дочерними элементами."
        },
        {
          "id": "text-106-2",
          "contentType": "text",
          "content": "Часто применяется для обработки нажатия кнопок в группирующем контейнере или изменения полей для ввода текста в формах, например:"
        },
        {
          "id": "code-106-1",
          "contentType": "code",
          "content": "<form>\n    <input contentType=\"text\" class=\"first-input\">\n    <input contentType=\"text\" class=\"second-input\">\n</form>\n\n<div>\n    <button class=\"first-button\">click</button>\n    <button class=\"second-button\">click</button>\n</div>\n\nconst form = document.querySelector('form')\nconst buttons = document.querySelector('div')\n\nform.addEventListener('input', event => {\n    console.log(event.target.className)\n})\n\nbuttons.addEventListener('click', event => {\n    console.log(event.target.className)\n})"
        },
        {
          "id": "text-106-3",
          "contentType": "text",
          "content": "В приведенном примере вместо регистрации обработчиков на дочерних элементах, мы регистрируем их на родительских элементах. Ввод текста в поле или нажатие кнопки приводят к выводу названия класса соответствующего элемента в консоль."
        },
        {
          "id": "nav-106-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/event-delegation",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "d3266e96-ec80-4c09-9715-7088ce485b20",
      "title": "108. Что такое ECMAScript?",
      "data": [
        {
          "id": "text-107-1",
          "contentType": "text",
          "content": "ECMAScript - это язык программирования, лежащий в основе JavaScript. Это своего рода шаблон или схема, по которой \"строится\" JavaScript. ECMAScript стандартизирован в спецификации ECMA-262 организацией по стандартам Ecma International."
        },
        {
          "id": "nav-107-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/manuals-specifications",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Language_Resources",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "a9faa535-ab9f-442c-9306-8e8130ec89cd",
      "title": "109. Назовите особенности синтаксиса JSON",
      "data": [
        {
          "id": "text-108-1",
          "contentType": "text",
          "content": "Синтаксис JSON имеет следующие особенности:"
        },
        {
          "id": "list-108-1",
          "contentType": "list",
          "content": [
            "Данные представляют собой пары ключ/значение",
            "Ключ и значение оборачиваются в двойные кавычки, кроме случаев, когда значение является числом (\"key\": \"value\")",
            "Данные разделяются запятыми",
            "Объекты оборачиваются в фигурные скобки",
            "Массивы - в квадратные"
          ]
        },
        {
          "id": "nav-108-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/json",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "b6360644-930e-471c-81eb-b1bee5d2e706",
      "title": "110. Что делает JSON.stringify()?",
      "data": [
        {
          "id": "text-109-1",
          "contentType": "text",
          "content": "При отправке данных на сервер, они должны иметь специальный строковый формат. Для преобразования объекта в строку в формате JSON используется метод JSON.stringify():"
        },
        {
          "id": "code-109-1",
          "contentType": "code",
          "content": "const user = { name: 'Ванька', age: 30 }\nconst str = JSON.stringify(user)\nconsole.log(str) // {\"name\":\"Ванька\",\"age\":30}"
        },
        {
          "id": "nav-109-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/json",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "010b6f5d-2368-45e6-b396-7d29129157c8",
      "title": "111. Что делает JSON.parse()?",
      "data": [
        {
          "id": "text-110-1",
          "contentType": "text",
          "content": "При получении данных от сервера, они имеют специальный строковый формат. Для преобразования этих данных в JavaScript объект используется метод JSON.parse():"
        },
        {
          "id": "code-110-1",
          "contentType": "code",
          "content": "const str = { \"name\":\"Ванька\",\"age\":30 }\nconst user = JSON.parse(str)\nconsole.log(user) // {name: \"Ванька\", age: 30}"
        },
        {
          "id": "nav-110-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/json",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "e3010be3-c6f2-4eb7-9bdc-591550245232",
      "title": "112. Зачем нужен JSON?",
      "data": [
        {
          "id": "text-111-1",
          "contentType": "text",
          "content": "При обмене данными между клиентом и сервером, эти данные могут быть только строками. Поскольку JSON - это текст, он прекрасно для этого подходит. Также он может использоваться как формат для данных любым языком программирования, наряду с другими форматами, такими как XML или Protobuf."
        },
        {
          "id": "nav-111-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/json",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "57749bde-852c-4c5a-83eb-2e841705a2b1",
      "title": "113. Что такое PWA (Progressive Web Application - прогрессивное веб-приложение)?",
      "data": [
        {
          "id": "text-112-1",
          "contentType": "text",
          "content": "Если кратко, то PWA - это веб-сайты, которые ведут себя подобно нативным приложениям. Они могут быть установлены на телефон или компьютер, а также, как правило, работают в оффлайне. Для последнего используются сервис-воркеры и интерфейс кэширования. Преимуществом PWA перед мобильными приложениями является их размер и относительная легкость разработки. Также не нужно тратить ресурсы на создание двух приложений для одного сайта - веб и мобильного. При этом сохраняется хороший пользовательский опыт."
        },
        {
          "id": "nav-112-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/Progressive_web_apps",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "2c6298a5-e665-438a-8922-e18b3aee5d66",
      "title": "114. Для чего используется clearTimeout()?",
      "data": [
        {
          "id": "text-113-1",
          "contentType": "text",
          "content": "Данный метод используется для остановки таймера, запущенного с помощью setTimeout(). Для этого идентификатор таймера записывается в переменную, которая затем передается clearTimeout() в качестве аргумента."
        },
        {
          "id": "code-113-1",
          "contentType": "code",
          "content": "const timer = setTimeout(() => {\n    console.log('Привет!')\n    clearTimeout(timer)\n}, 2000)"
        },
        {
          "id": "text-113-2",
          "contentType": "text",
          "content": "В приведенном примере через две секунды в консоль выводится сообщение \"Привет!\", после чего таймер останавливается. Это делается для того, чтобы сборщик мусора мог удалить выполненный таймер."
        },
        {
          "id": "nav-113-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/settimeout-setinterval",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/WindowOrWorkerGlobalScope/clearTimeout",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "4aa7345e-b1be-41c2-9412-f8e5a90eca19",
      "title": "115. Для чего используется clearInterval()?",
      "data": [
        {
          "id": "text-114-1",
          "contentType": "text",
          "content": "Данный метод используется для остановки таймера, запущенного с помощью setInterval(). Для этого идентификатор таймера записывается в переменную, которая затем передается clearInterval() в качестве аргумента."
        },
        {
          "id": "code-114-1",
          "contentType": "code",
          "content": "let i = 1\nconst timer = setInterval(() => {\n    console.log(i)\n    i++\n\n    if (i === 3) clearInterval(timer)\n}, 1000)"
        },
        {
          "id": "text-114-2",
          "contentType": "text",
          "content": "В приведенном примере в консоль каждую секунду выводится значение переменной i, которое каждый раз увеличивается на 1 (1, 2). Когда значение i становится равным 3, таймер останавливается."
        },
        {
          "id": "nav-114-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/settimeout-setinterval",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/WindowOrWorkerGlobalScope/clearInterval",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "e1c23bea-6faa-4bf6-ad87-76252ca5525f",
      "title": "116. Как выполнить перенаправление?",
      "data": [
        {
          "id": "text-115-1",
          "contentType": "text",
          "content": "Для этого можно использовать свойство location объекта window:"
        },
        {
          "id": "code-115-1",
          "contentType": "code",
          "content": "location.href = 'newPage.html'\n// или\nlocation.replace('newPage.html')\n// или\nlocation.assign('newPage.html')"
        },
        {
          "id": "nav-115-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Location",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "dcb2fd96-6031-42d9-b6f3-bc98342e97d5",
      "title": "117. Как проверить, существует ли подстрока в строке?",
      "data": [
        {
          "id": "text-116-1",
          "contentType": "text",
          "content": "Существует, как минимум, три способа это сделать."
        },
        {
          "id": "text-116-2",
          "contentType": "text",
          "content": "String.protocontentType.includes()"
        },
        {
          "id": "code-116-1",
          "contentType": "code",
          "content": "const mainStr = 'hello'\nconst subStr = 'hel'\nmainStr.includes(subStr) // true"
        },
        {
          "id": "text-116-3",
          "contentType": "text",
          "content": "String.protocontentType.indexOf()"
        },
        {
          "id": "code-116-2",
          "contentType": "code",
          "content": "const mainStr = 'hello'\nconst subStr = 'hel'\nmainStr.indexOf(subStr) !== -1 // true"
        },
        {
          "id": "text-116-4",
          "contentType": "text",
          "content": "RegExp"
        },
        {
          "id": "code-116-3",
          "contentType": "code",
          "content": "const mainStr = 'hello'\nconst regex = /hel/\nregex.test(mainStr) // true"
        },
        {
          "id": "nav-116-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/string",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/includes",
              "title": "includes"
            },
            {
              "id": "subnav-1-2",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf",
              "title": "indexOf"
            },
            {
              "id": "subnav-1-3",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test",
              "title": "test"
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "6f0fe840-a222-4f20-b73f-1ca2c7b41fcd",
      "title": "118. Как проверить корректность адреса электронной почты?",
      "data": [
        {
          "id": "text-117-1",
          "contentType": "text",
          "content": "Это можно сделать средствами HTML, установив тип поля для ввода в значение email (<input contentType=\"email\">). Однако, данный способ считается не очень надежным. Поэтому, обычно, email валидируется с помощью регулярного выражения. Это рекомендуется делать на стороне сервера, поскольку на клиенте может быть отключен JavaScript:"
        },
        {
          "id": "code-117-1",
          "contentType": "code",
          "content": "const validateEmail = email =>\n    /S+@S+.S+/\n        .test(email.toString()\n        .toLowerCase())\nconst email = 'myemail@example.com'\nvalidateEmail(email) // true"
        },
        {
          "id": "text-117-2",
          "contentType": "text",
          "content": "В приведенном примере используется одно из самых простых регулярных выражений для валидации адреса электронной почты. Более надежное выражение выглядит так (RFC 2822): [a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?"
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "21306153-2c8f-43db-a3ea-88d9a01bc253",
      "title": "119. Как получить текущий URL?",
      "data": [
        {
          "id": "text-118-1",
          "contentType": "text",
          "content": "Для этого можно использовать свойство location объекта window или свойство URL объекта document:"
        },
        {
          "id": "code-118-1",
          "contentType": "code",
          "content": "console.log('Текущий URL', location.href)\nconsole.log('Текущий URL', document.URL) // в Chrome в пустой вкладке получаем \"Текущий URL chrome-search://local-ntp/local-ntp.html\""
        },
        {
          "id": "nav-118-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Location",
              "title": "location"
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Document/URL",
              "title": "document.URL"
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "43bea27b-8d58-446c-ac4c-263a1f23a6b8",
      "title": "120. Какие свойства имеет объект location?",
      "data": [
        {
          "id": "text-119-1",
          "contentType": "text",
          "content": "Свойства объекта location могут использоваться для получения частей URL текущей страницы:"
        },
        {
          "id": "list-119-1",
          "contentType": "list",
          "content": [
            "href - полный URL",
            "origin - протокол, хост и порт (источник, используется в Политике общего происхождения (SOP) и Совместном использовании ресурсов (CORS))",
            "protocol",
            "host - хост и порт",
            "hostname - хост",
            "port",
            "pathname - путь",
            "search - строка запроса после ?",
            "hash - строка запроса после # (якоря)",
            "username - имя пользователя перед доменом",
            "password - пароль перед доменом"
          ]
        },
        {
          "id": "nav-119-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Location",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "de5c1a4c-8edd-4881-8249-20f7fb7b4592",
      "title": "121. Как получить строку запроса?",
      "data": [
        {
          "id": "text-120-1",
          "contentType": "text",
          "content": "Для этого можно использовать конструктор URL:"
        },
        {
          "id": "code-120-1",
          "contentType": "code",
          "content": "const url = new URL('https://example.com?foo=1&bar=2')\nconsole.log(url.search) // ?foo=1&bar=2\nconsole.log(url.searchParams.get('foo')) // 1"
        },
        {
          "id": "nav-120-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Document/URL",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "2a5dffb5-0723-4eb0-acaa-38ea84eaf0d9",
      "title": "122. Как проверить, существует ли свойство в объекте?",
      "data": [
        {
          "id": "text-121-1",
          "contentType": "text",
          "content": "Для этого существует, как минимум, три способа."
        },
        {
          "id": "text-121-2",
          "contentType": "text",
          "content": "Оператор in"
        },
        {
          "id": "code-121-1",
          "contentType": "code",
          "content": "const user = { name: 'Ванька' }\nconsole.log('name' in user) // true\nconsole.log(!('age' in user)) // true"
        },
        {
          "id": "text-121-3",
          "contentType": "text",
          "content": "Метод hasOwnProperty()"
        },
        {
          "id": "code-121-2",
          "contentType": "code",
          "content": "const user = { name: 'Ванька' }\nconsole.log(user.hasOwnProperty('name')) // true\nconsole.log(!user.hasOwnProperty('age')) // true"
        },
        {
          "id": "text-121-4",
          "contentType": "text",
          "content": "Сравнение с undefined"
        },
        {
          "id": "code-121-3",
          "contentType": "code",
          "content": "const user = { name: 'Ванька' }\nconsole.log(user.name !== undefined) // true\nconsole.log(user.age === undefined) // true"
        },
        {
          "id": "nav-121-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/object",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/for...in",
              "title": "for...in"
            },
            {
              "id": "subnav-1-2",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty",
              "title": "hasOwnProperty"
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "8dfed84b-ea98-40a3-a76b-082165439b53",
      "title": "123. Как перебрать перечисляемые свойства объекта?",
      "data": [
        {
          "id": "text-122-1",
          "contentType": "text",
          "content": "Для этого можно использовать цикл for...in совместно с методом hasOwnProperty() для исключения унаследованных свойств."
        },
        {
          "id": "code-122-1",
          "contentType": "code",
          "content": "const user = {\n    name: 'Ванька',\n    age: 30\n}\n\nfor (key in user) {\n    if (user.hasOwnProperty(key)) {\n        console.log(`${key}: ${user[key]}`) // name: Ванька age: 30\n    }\n}"
        },
        {
          "id": "nav-122-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/object",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/for...in",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "e02e8e32-bf96-4dd9-8a06-5dee90b2e855",
      "title": "124. Как проверить, что объект является пустым?",
      "data": [
        {
          "id": "text-123-1",
          "contentType": "text",
          "content": "Для этого существует, как минимум, три способа."
        },
        {
          "id": "text-123-2",
          "contentType": "text",
          "content": "Метод Object.entries()"
        },
        {
          "id": "code-123-1",
          "contentType": "code",
          "content": "const obj = {}\nconsole.log(Object.entries(obj).length === 0) // true\n// для исключения из проверки объекта Date\nconst obj2 = new Date()\nconsole.log(Object.entries(obj2).length === 0 && obj2.constructor === Object) // false"
        },
        {
          "id": "text-123-3",
          "contentType": "text",
          "content": "Метод Object.keys()"
        },
        {
          "id": "code-123-2",
          "contentType": "code",
          "content": "const obj = {}\nconsole.log(Object.keys(obj).length === 0) // true\n// для исключения из проверки объекта Date\nconst obj2 = new Date()\nconsole.log(Object.keys(obj2).length === 0 && obj2.constructor === Object) // false"
        },
        {
          "id": "text-123-4",
          "contentType": "text",
          "content": "Цикл for...in и метод Object.hasOwnProperty()"
        },
        {
          "id": "code-123-3",
          "contentType": "code",
          "content": "const obj = {}\nconst obj2 = {key: 'value'}\n\nconst isEmpty = obj => {\n    for (key in obj) {\n        if (obj.hasOwnProperty(key)) return false\n    }\n    return true\n}\n\nconsole.log(isEmpty(obj)) // true\nconsole.log(isEmpty(obj2)) // false"
        },
        {
          "id": "nav-123-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/object",
              "title": "Объекты"
            },
            {
              "id": "subnav-1-1",
              "name": "jsr",
              "src": "https://learn.javascript.ru/keys-values-entries",
              "title": "Object.keys, values, entries"
            },
            {
              "id": "subnav-1-2",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/entries",
              "title": "Object.entries"
            },
            {
              "id": "subnav-1-3",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/keys",
              "title": "Object.keys"
            },
            {
              "id": "subnav-1-4",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/for...in",
              "title": "for...in"
            },
            {
              "id": "subnav-1-5",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty",
              "title": "Object.hasOwnProperty"
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "6f4462bd-d5c3-4768-aa2d-4172b7fdba55",
      "title": "125. Что такое объект arguments?",
      "data": [
        {
          "id": "text-124-1",
          "contentType": "text",
          "content": "arguments - это массивоподобный объект (псевдомассив), содержащий переданные функции аргументы:"
        },
        {
          "id": "code-124-1",
          "contentType": "code",
          "content": "function sum () {\n    let total = 0\n    for (let i = 0; i < arguments.length; i++) {\n        total += arguments[i]\n    }\n    return total\n\n    // или\n    let total = 0\n    for (const i of arguments) {\n        total += i\n    }\n    return total\n\n    // или\n    return Array.from(arguments).reduce((acc, cur) => acc + cur)\n\n}\n\nsum(1, 2, 3) // 6"
        },
        {
          "id": "text-124-2",
          "contentType": "text",
          "content": "Обратите внимание, что стрелочные функции не имеют arguments. Вместо arguments рекомендуется использовать оператор rest ... (прочие параметры), который работает как в обычных, так и в стрелочных функциях:"
        },
        {
          "id": "code-124-2",
          "contentType": "code",
          "content": "const sum = (...rest) => rest.reduce((acc, cur) => acc + cur)\n\nsum(1, 2, 3) // 6"
        },
        {
          "id": "nav-124-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/arguments-pseudoarray",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/arguments",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "bb8d1474-da41-4f55-8cc8-80389861707f",
      "title": "126. Как сделать первую букву строки заглавной?",
      "data": [
        {
          "id": "text-125-1",
          "contentType": "text",
          "content": "Это можно сделать с помощью методов charAt(), toUpperCase() и slice():"
        },
        {
          "id": "code-125-1",
          "contentType": "code",
          "content": "String.protocontentType.capitilize = function () {\n    return this.charAt(0).toUpperCase() + this.slice(1)\n}\n\nconsole.log('hello'.capitilize()) // Hello"
        },
        {
          "id": "nav-125-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/string",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/charAt",
              "title": "charAt"
            },
            {
              "id": "subnav-1-2",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/toUpperCase",
              "title": "toUpperCase"
            },
            {
              "id": "subnav-1-3",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/slice",
              "title": "slice"
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "4f81b949-05d9-4be4-b167-bb34ab20e82d",
      "title": "127. Как получить текущую дату?",
      "data": [
        {
          "id": "text-126-1",
          "contentType": "text",
          "content": "Это можно сделать с помощью объекта Date или конструктора Intl.DateTimeFormat:"
        },
        {
          "id": "code-126-1",
          "contentType": "code",
          "content": "console.log(new Date().toLocaleDateString()) // 02.09.2020\n\nconsole.log(new Intl.DateTimeFormat(\n    'ru-Ru',\n    {\n        weekday: 'long',\n        day: 'numeric',\n        month: 'long',\n        year: 'numeric'\n    }\n).format(new Date())) // среда, 2 сентября 2020 г."
        },
        {
          "id": "nav-126-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/date",
              "title": "Date"
            },
            {
              "id": "subnav-1-1",
              "name": "jsr",
              "src": "https://learn.javascript.ru/intl",
              "title": "Intl"
            },
            {
              "id": "subnav-1-2",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date",
              "title": "Date"
            },
            {
              "id": "subnav-1-3",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat",
              "title": "Intl.DateTimeFormat"
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "36a35bb4-5d61-4204-80d6-48bc31dd9869",
      "title": "128. Как сравнить два объекта Date?",
      "data": [
        {
          "id": "text-127-1",
          "contentType": "text",
          "content": "Для этого следует сравнивать не сами объекты, а, например, значения, возвращаемые методом getTime():"
        },
        {
          "id": "code-127-1",
          "contentType": "code",
          "content": "const d1 = new Date()\nconst d2 = new Date(d1)\n\nconsole.log(d1.getTime() === d2.getTime()) // true\nconsole.log(d1 === d2) // false"
        },
        {
          "id": "nav-127-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/date",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "cc751b44-d93e-44ab-a887-266dcfce2d50",
      "title": "129. Как проверить, что строка начинается с другой строки?",
      "data": [
        {
          "id": "text-128-1",
          "contentType": "text",
          "content": "Для этого можно использовать встроенный метод startsWith():"
        },
        {
          "id": "code-128-1",
          "contentType": "code",
          "content": "console.log('Good morning'.startsWith('Good')) // true\nconsole.log('Good morning'.startsWith('morning')) // false"
        },
        {
          "id": "text-128-2",
          "contentType": "text",
          "content": "По данным CanIUse данный метод поддерживает почти 94% браузеров"
        },
        {
          "id": "nav-128-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/string",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "f77f3607-dff3-4c24-a49c-b9a978c12604",
      "title": "130. Как удалить проблемы в строке?",
      "data": [
        {
          "id": "text-129-1",
          "contentType": "text",
          "content": "Для этого можно использовать встроенные методы trimStart() (начало строки), trimEnd() (конец строки) и trim() (начало и конец строки):"
        },
        {
          "id": "code-129-1",
          "contentType": "code",
          "content": "console.log('  hello world   '.trim()) // hello world"
        },
        {
          "id": "text-129-2",
          "contentType": "text",
          "content": "trim не работает для пробелов между словами. В этом случае можно воспользоваться методом replace() и регулярным выражением:"
        },
        {
          "id": "code-129-2",
          "contentType": "code",
          "content": "console.log('hello   world'.replace(/s+/, ' ')) // hello world\n// можно уточнить количество пробелов\nconsole.log('hello   world'.replace(/s{2,}/, ' ')) // hello world\nconsole.log('key   value'.replace(/s{2,}/, ' -> ')) // key -> value"
        },
        {
          "id": "text-129-3",
          "contentType": "text",
          "content": "По данным CanIUse методы trimStart() и trimEnd() поддерживает 93% браузеров."
        },
        {
          "id": "nav-129-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String/Trim",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "90bf14b7-4e8e-4245-aa6f-696004d7c440",
      "title": "131. Как добавить новое свойство в объект?",
      "data": [
        {
          "id": "text-130-1",
          "contentType": "text",
          "content": "Существует два способа это сделать. Предположим, что у нас есть такой объект:"
        },
        {
          "id": "code-130-1",
          "contentType": "code",
          "content": "const obj = {\n    name: 'Ванька',\n    age: 30\n}"
        },
        {
          "id": "text-130-2",
          "contentType": "text",
          "content": "Мы можем добавить в него новое свойство, использую либо точечную, либо скобочную нотацию:"
        },
        {
          "id": "code-130-2",
          "contentType": "code",
          "content": "obj.job = 'разработчик'\nobj['job'] = 'разработчик'"
        },
        {
          "id": "text-130-3",
          "contentType": "text",
          "content": "Одним из отличий указанных методов является то, что при использовании скобочной нотации добавляемый ключ может быть числом:"
        },
        {
          "id": "code-130-3",
          "contentType": "code",
          "content": "const obj = {}\nobj[1] = 'один'\nconsole.log(obj) // { 1: 'один' }\nobj.2 = 'два' // SyntaxError: Unexpected number"
        },
        {
          "id": "nav-130-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/object",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "ad691d27-ddeb-4eaf-9156-e2f6be92a189",
      "title": "132. Является ли выражение !-- специальным оператором?",
      "data": [
        {
          "id": "text-131-1",
          "contentType": "text",
          "content": "Нет, не является. Это комбинация двух операторов: оператора ! (логическое не) и оператора -- (декремент). Если использовать указанное выражение с каким-либо значением, то сначала это значение будет уменьшено на единицу, затем преобразовано в логический тип и инвертировано:"
        },
        {
          "id": "code-131-1",
          "contentType": "code",
          "content": "const fun = val => !--val\nconst a = 1\nconst b = 2\nconsole.log(fun(a)) // !0 -> not false -> true\nconsole.log(fun(b)) // !1 -> not true -> false"
        },
        {
          "id": "nav-131-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/operators",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Logical_NOT",
              "title": "Logical NOT"
            },
            {
              "id": "subnav-1-2",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Decrement",
              "title": "Decrement"
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "b436f9cd-a3cd-42bb-8c04-26380cb92c8c",
      "title": "133. Как присвоить переменной значение по умолчанию?",
      "data": [
        {
          "id": "text-132-1",
          "contentType": "text",
          "content": "Для этого можно использовать оператор || (логическое или):"
        },
        {
          "id": "code-132-1",
          "contentType": "code",
          "content": "const a = b || 'default'"
        },
        {
          "id": "text-132-2",
          "contentType": "text",
          "content": "В данном случае переменной a будет присвоено значение default в случае, если значение переменной b будет ложным (false, undefined, null, NaN, 0, '')."
        },
        {
          "id": "text-132-3",
          "contentType": "text",
          "content": "Если речь идет о стандартных значениях параметров функции, то их можно присвоить следующим образом:"
        },
        {
          "id": "code-132-2",
          "contentType": "code",
          "content": "const greet = (name = 'незнакомец') => `Привет, ${name}!`\nconsole.log(greet('Ванька')) // Привет, Ванька!\nconsole.log(greet()) // Привет, незнакомец!"
        },
        {
          "id": "text-132-4",
          "contentType": "text",
          "content": "Более того, последующие параметры могут использовать значения предыдущих в качестве стандартных значений:"
        },
        {
          "id": "code-132-3",
          "contentType": "code",
          "content": "const sum = (a = 1, b = a + 2) => a + b\nconsole.log(sum()) // 4"
        },
        {
          "id": "nav-132-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/operators",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Logical_OR",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "2a7c93dd-f683-4e93-ac2c-d414b5a926dc",
      "title": "134. Как создать многострочную строку?",
      "data": [
        {
          "id": "text-133-1",
          "contentType": "text",
          "content": "Раньше это делали примерно так (конкатенация и управляющие символы переноса строки):"
        },
        {
          "id": "code-133-1",
          "contentType": "code",
          "content": "const str =\n    'Аз есмь' + ' ' +\n    'очень длинная' + ' ' +\n    'строка!'\n\n// или\nconst str = 'Аз есмь a\n очень длинная\n строка!'\nconsole.log(str)\n/*\n    Аз есмь\n    очень длинная\n    строка!\n*/"
        },
        {
          "id": "text-133-2",
          "contentType": "text",
          "content": "Сейчас это делают так (шаблонный литерал):"
        },
        {
          "id": "code-133-2",
          "contentType": "code",
          "content": "const str =\n    `Аз есмь\n    очень длинная\n    строка!`"
        },
        {
          "id": "nav-133-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/string",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/template_strings",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "c41a97a0-b83d-4a73-a3c9-e305c07c9533",
      "title": "135. Можем ли мы добавлять свойства функциям?",
      "data": [
        {
          "id": "text-134-1",
          "contentType": "text",
          "content": "Поскольку функции - это тоже объекты, мы вполне можем добавлять им свойства. Значением свойства функции может быть другая функция:"
        },
        {
          "id": "code-134-1",
          "contentType": "code",
          "content": "function someFun () {}\nsomeFun.somePropName = 'somePropValue'\n\nconsole.log(someFun.somePropName) // somePropValue\n// дефолтное свойство\nconsole.log(someFun.name) // someFun\n\nconst sum = (x, y) => x + y\nconsole.log(sum(1, 2)) // 3\n\nsum.curry = x => y => x + y\nconsole.log(sum.curry(1)(2)) // 3"
        },
        {
          "id": "nav-134-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/function-basics",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "e8e4f6ce-8e59-46ad-8577-7d1e90c1bf26",
      "title": "136. Как узнать, сколько аргументов ожидает получить функция?",
      "data": [
        {
          "id": "text-135-1",
          "contentType": "text",
          "content": "Для этого можно использовать свойство length:"
        },
        {
          "id": "code-135-1",
          "contentType": "code",
          "content": "const sum = (a, b, c) => +a + +b + +c\nconsole.log(sum(1, '1', true)) // 3\nconsole.log(sum(0, '', [])) // 0\n\nconsole.log(sum.length) // 3"
        },
        {
          "id": "nav-135-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/length",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "35eaa6c9-a020-40f9-bd1f-a69b9c3857db",
      "title": "137. Что такое полифил (polyfill)?",
      "data": [
        {
          "id": "text-136-1",
          "contentType": "text",
          "content": "Полифилы используются для обеспечения работы современного JavaScript-кода в старых браузерах. Это делается за счет реализации новых возможностей языка на старом синтаксисе. Сам процесс преобразования нового кода в старый называется транспиляцией. Самым популярным транспилятором JavaScript-кода является Babel."
        },
        {
          "id": "text-136-2",
          "contentType": "text",
          "content": "Например, одной из последних возможностей JavaScript является метод Promise.allSettled(), который, в отличие от Promise.all(), не завершается при отклонении любого из переданных ему промисов."
        },
        {
          "id": "text-136-3",
          "contentType": "text",
          "content": "Однако, на сегодняшний день его поддержка браузерами по данным CanIUse составляет 80%, поэтому нужен полифил:"
        },
        {
          "id": "code-136-1",
          "contentType": "code",
          "content": "const promise1 = Promise.resolve('promise1')\nconst promise2 = Promise.reject('promise2')\nconst promise3 = Promise.resolve('promise3')\n\n// вот как выглядит встроенный Promise.allSettled()\nPromise\n    .allSettled([promise1, promise2, promise3])\n    .then(console.log)\n/*\n    [\n        {status: \"fulfilled\", value: \"promise1\"},\n        {status: \"rejected\", reason: \"promise2\"},\n        {status: \"fulfilled\", value: \"promise3\"},\n    ]\n*/\n\n// а вот его полифил\n// поддержка Promise.all() = 94%\nconst allSettled = promises => {\n    const wrappedPromises = promises\n        .map(p => Promise.resolve(p)\n        .then(\n            val => ({\n                status: 'fulfilled',\n                value: val\n            }),\n            err => ({\n                status: 'rejected',\n                reason: err\n            })))\n    return Promise.all(wrappedPromises)\n}\nallSettled([promise1,promise2,promise3])\n    .then(console.log)"
        },
        {
          "id": "nav-136-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/polyfills",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Glossary/Polyfill",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "617a67e8-507c-4466-b288-a55e57b21eae",
      "title": "138. Для чего используются операторы continue и break?",
      "data": [
        {
          "id": "text-137-1",
          "contentType": "text",
          "content": "Оператор break используется для выхода из цикла. После остановки итерации код выполняется дальше:"
        },
        {
          "id": "code-137-1",
          "contentType": "code",
          "content": "const obj = {\n    1: 'Everything',\n    2: 'is',\n    3: 'impossible'\n}\n\nfor (key in obj) {\n    if (obj[key] === 'impossible') break\n\n    console.log(obj[key]) // Everything is\n}\n\nconsole.log('possible') // possible"
        },
        {
          "id": "text-137-2",
          "contentType": "text",
          "content": "Оператор continue используется для пропуска итерации:"
        },
        {
          "id": "code-137-2",
          "contentType": "code",
          "content": "const obj = {\n    1: 'Everything',\n    2: 'is',\n    3: 'impossible',\n    4: 'possible'\n}\n\nfor (key in obj) {\n    if (obj[key] === 'impossible') continue\n\n    console.log(obj[key]) // Everything is possible\n}"
        },
        {
          "id": "nav-137-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/break",
              "title": "break"
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/continue",
              "title": "continue"
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "f236653c-3284-423b-98a4-5dc0a0e3ba19",
      "title": "139. Что такое метка (label)?",
      "data": [
        {
          "id": "text-138-1",
          "contentType": "text",
          "content": "Метки позволяют именовать циклы и блоки кода. Они могут использоваться, например, для выхода из цикла или в качестве условия выполнения кода:"
        },
        {
          "id": "code-138-1",
          "contentType": "code",
          "content": "loop1:\nfor (let i = 0; i < 3; i++) {\n    loop2:\n    for (let j = 0; j < 3; j++) {\n        if (i === j) continue loop1\n\n        console.log(`i = ${i}, j = ${j}`)\n    }\n}\n\n/*\n    i = 1, j = 0\n    i = 2, j = 0\n    i = 2, j = 1\n*/"
        },
        {
          "id": "text-138-2",
          "contentType": "text",
          "content": "Использование меток считается плохой практикой."
        },
        {
          "id": "nav-138-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/label",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "cf079c60-62d4-4553-ba68-61786e73ae45",
      "title": "140. В чем заключаются преимущества объявления переменных в начале кода?",
      "data": [
        {
          "id": "text-139-1",
          "contentType": "text",
          "content": "Рекомендуется объявлять переменные в начала каждого скрипта или фукнции. Это дает следующие преимущества:"
        },
        {
          "id": "list-139-1",
          "contentType": "list",
          "content": [
            "Делает код чистым",
            "Все переменные находятся в одном месте",
            "Позволяет избежать случайного создания глобальных переменных",
            "Предотвращает нежелательное переопределение переменных"
          ]
        },
        {
          "id": "nav-139-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/variables",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/Variable",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "c18a608b-1bf1-42ed-a1fe-483a3f58a09b",
      "title": "141. В чем заключаются преимущества инициализации переменной при объявлении?",
      "data": [
        {
          "id": "text-140-1",
          "contentType": "text",
          "content": "Рекомендуется инициализировать все переменные в момент объявления. Это дает следующие преимущества:"
        },
        {
          "id": "list-140-1",
          "contentType": "list",
          "content": [
            "Делает код чистым",
            "Переменные и их значения находятся в одном месте",
            "Предотвращает присвоение неинициализированным переменным значения undefined"
          ]
        },
        {
          "id": "nav-140-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/variables",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/Variable",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "32571f44-6df6-42cf-af58-4aa83b22b245",
      "title": "142. Назовите основные рекомендации по созданию объекта",
      "data": [
        {
          "id": "text-141-1",
          "contentType": "text",
          "content": "Для создания объекта вместо конструктора объекта new Object() рекмондуется использовать скобочную нотацию {}. Также в зависимости от типа значения, рекомендуется использовать следующее:"
        },
        {
          "id": "list-141-1",
          "contentType": "list",
          "content": [
            "строку, например, '' вместо new String()",
            "число, например, 0 вместо new Number()",
            "логическое значение, например, false вместо new Boolean()",
            "[] вместо new Array()",
            "// вместо new RegExp()",
            "function (){} вместо new Function()"
          ]
        },
        {
          "id": "nav-141-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/object",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "d9e9da38-a3b1-46c8-b2ae-f4382643555e",
      "title": "143. Как определить массив в формате JSON?",
      "data": [
        {
          "id": "text-142-1",
          "contentType": "text",
          "content": "JSON-массив представляет собой массив JSON-объектов, например:"
        },
        {
          "id": "code-142-1",
          "contentType": "code",
          "content": "[\n    { \"name\": \"Ванька\", \"age\": 30 },\n    { \"name\": \"Петька\", \"age\": 20 }\n]"
        },
        {
          "id": "nav-142-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/json",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "30d7b42c-4bf3-4714-b2eb-f36bdd2dbd38",
      "title": "144. Как реализовать функцию, возвращающую случайное целое число в заданном диапазоне?",
      "data": [
        {
          "id": "text-143-1",
          "contentType": "text",
          "content": "Такую функцию можно реализовать с помощью методов Math.random() и Math.floor() объекта Math:"
        },
        {
          "id": "code-143-1",
          "contentType": "code",
          "content": "const getRandomInteger = (min, max) => Math.floor(min + Math.random() * (max + 1 - min))"
        },
        {
          "id": "nav-143-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/number",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math/random",
              "title": "Math.random()"
            },
            {
              "id": "subnav-1-2",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Math/floor",
              "title": "Math.floor()"
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "af7adf5b-8058-4d8a-b8d7-b3e86c3756eb",
      "title": "145. Что такое tree shaking (встряхивание дерева)?",
      "data": [
        {
          "id": "text-144-1",
          "contentType": "text",
          "content": "Tree shaking - это удаление кода неиспользуемых модулей. Такие модули не включаются в окончательную сборку (бандл). Для того, чтобы сборщик модулей (бандлер) мог определить, какие модули используются, а какие нет, структура программы должна быть основана на ES6 модулях. Данная техника была популяризована бандлером Rollup."
        },
        {
          "id": "nav-144-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Glossary/Tree_shaking",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "a43f07cf-f7fe-45e5-acd5-ee27f9a98140",
      "title": "146. Для чего используется tree shaking (встряхивание дерева)?",
      "data": [
        {
          "id": "text-145-1",
          "contentType": "text",
          "content": "Tree shaking может существенно уменьшить размер сборки (бандла) за счет удаления из нее кода неиспользуемых модулей. Чем меньше размер сборки, тем выше производительность приложения. Tree shaking реализован в таких сборщиках модулей, как Rollup и Webpack."
        },
        {
          "id": "nav-145-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Glossary/Tree_shaking",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "d40dab94-c5a0-4980-805a-cd021761a1b5",
      "title": "147. Что такое регулярное выражение?",
      "data": [
        {
          "id": "text-146-1",
          "contentType": "text",
          "content": "Регулярное выражение - это последовательность символов, формирующая поисковый шаблон. Этот шаблон может использоваться для поиска данных в тексте, например, подстроки в строке. Регулярные выражения широко используются многими языками программирования для операций поиска и замены текста. Общий шаблон регулярного выражения выглядит так:"
        },
        {
          "id": "code-146-1",
          "contentType": "code",
          "content": "/шаблон/модификатор"
        },
        {
          "id": "text-146-2",
          "contentType": "text",
          "content": "Пример:"
        },
        {
          "id": "code-146-2",
          "contentType": "code",
          "content": "const regex = /java/i\nconst str = 'JavaScript'\nconsole.log(regex.test(str)) // true"
        },
        {
          "id": "text-146-3",
          "contentType": "text",
          "content": "Также для создания регулярного выражения можно использовать конструктор RegExp:"
        },
        {
          "id": "code-146-3",
          "contentType": "code",
          "content": "const regex = new RegExp('java', 'i')\nconst str = 'JavaScript'\nconsole.log(regex.test(str)) // true"
        },
        {
          "id": "nav-146-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/regexp-methods",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "80044bf1-6573-4ac6-93da-4517d537f13d",
      "title": "148. Какие методы используются в регулярных выражениях?",
      "data": [
        {
          "id": "text-147-1",
          "contentType": "text",
          "content": "В регулярных выражениях используется два основных метода: exec() и test()."
        },
        {
          "id": "text-147-2",
          "contentType": "text",
          "content": "Метод exec() ищет совпадение с регулярным выражением в переданной ему в качестве аргумента строке. Поведение данного метода зависит от того, имеет ли регулярное выражение флаг g. Если нет, то возвращается первое совпадение. Если флаг g есть, то:"
        },
        {
          "id": "list-147-1",
          "contentType": "list",
          "content": [
            "Вызов exec() возвращает первое совпадение и запоминает позицию после него в свойстве lastIndex.",
            "Следующий такой вызов начинает поиск с позиции lastIndex, возвращает следующее совпадение и запоминает позицию после него в lastIndex.",
            "Если совпадений больше нет, то exec() возвращает null, а для lastIndex устанавливается значение 0."
          ]
        },
        {
          "id": "code-147-1",
          "contentType": "code",
          "content": "const str = 'Java и JavaScript - разные языки программирования'\nconst regex = /Java/g\n\nlet result\nwhile (result = regex.exec(str)) {\n    console.log(\n        `Найдено ${result[0]} на позиции ${result.index}`\n    )\n}\n/*\n    Найдено Java на позиции 0\n    Найдено Java на позиции 7\n*/"
        },
        {
          "id": "text-147-3",
          "contentType": "text",
          "content": "Метод test() возвращает логическое значение в зависимости от того, найдено ли совпадение в строке:"
        },
        {
          "id": "code-147-2",
          "contentType": "code",
          "content": "const str = 'Я люблю JavaScript'\n\nconsole.log(\n    /Я люблю/.test(str) // true\n)"
        },
        {
          "id": "nav-147-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/regexp-methods",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "7c840fdd-4d32-4224-91ed-ba52b16d0982",
      "title": "149. Какие флаги используются в регулярных выражениях?",
      "data": [
        {
          "id": "table-148-1",
          "contentType": "table",
          "content": [
            [
              "Флаг",
              "Описание"
            ],
            [
              "g",
              "глобальное сопоставление"
            ],
            [
              "i",
              "игнорирование регистра при сопоставлении"
            ],
            [
              "m",
              "сопоставление по нескольким строкам"
            ]
          ]
        },
        {
          "id": "code-148-1",
          "contentType": "code",
          "content": "const regex = /([а-яё]+)s([а-яё]+)/i\nconst str = 'Иван Иванов'\nconst newStr = str.replace(regex, '$2 $1')\nconsole.log(newStr) // Иванов Иван"
        },
        {
          "id": "nav-148-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/regexp-methods",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "2e10bd03-bafc-4b58-ae8a-b8243ccfad80",
      "title": "150. Какие специальные символы используются в регулярных выражениях?",
      "data": [
        {
          "id": "text-149-1",
          "contentType": "text",
          "content": "Специальные символы, используемые в регулярных выражениях, можно разделить на несколько групп."
        },
        {
          "id": "text-149-2",
          "contentType": "text",
          "content": "Основные символьные классы:"
        },
        {
          "id": "table-149-1",
          "contentType": "table",
          "content": [
            [
              "Символ",
              "Значение"
            ],
            [
              "\\.",
              "любой символ, за некоторым исключением"
            ],
            [
              "\\d",
              "цифра"
            ],
            [
              "\\D",
              "не цифра"
            ],
            [
              "\\w",
              "символ латиницы и нижнее подчеркивание"
            ],
            [
              "\\W",
              "не символ латиницы и нижнее подчеркивание"
            ],
            [
              "\\s",
              "пробельный символ"
            ],
            [
              "\\S",
              "не пробельный символ"
            ],
            [
              "\\","экранирование, например,\\.-этоточка"
            ]
          ]
        },
        {
          "id":"text-149-3",
          "contentType":"text",
          "content":"Наборысимволов: "
        },
        {
          "id":"table-149-2",
          "contentType":"table",
          "content":[
            ["Символ","Значение"],
            ["[а-яёА-ЯЁ]","любая буква русского алфавита"],
            ["[^а-яёА-ЯЁ]","любойсимвол, кроме букв русского алфавита"]
          ]
        },
        {
          "id":"text-149-4",
          "contentType":"text",
          "content":"Границы: "
        },
        {
          "id":"table-149-3",
          "contentType":"table",
          "content":[
            ["Символ","Значение"],
            ["^","началостроки"],
            ["$","конецстроки"],
            ["\\b","границаслованулевойширины"],
            ["\\B","границаслованенулевойширины"]
          ]
        },
        {
          "id":"text-149-5",
          "contentType":"text",
          "content":"Группировка: "
        },
        {
          "id":"table-149-4",
          "contentType":"table",
          "content":[
            ["Символ","Значение"],
            ["(x)","сопоставляется с x, сопоставление запоминается"],
            ["(?: x)","сопоставляется с x, сопоставление не запоминается"]
          ]
        },
        {
          "id":"text-149-6",
          "contentType":"text",
          "content":"Квантификаторы: "
        },
        {
          "id":"table-149-5",
          "contentType":"table",
          "content":[
            ["Символ","Значение"],
            ["*","ноль и более символов"],
            ["+","один и более символов"],
            ["*?и+?","аналогично * и +, но ищется минимальное совпадение"],
            ["?","ноль или один символ"],
            ["x(?=y)","сопоставляется с x, если за x следует y"],
            ["x(?!y)","сопоставляется с x, если за x не следует y"],
            ["(?<=y)x","сопоставляется с x, если x предшествует y"],
            ["(?!y)x","сопоставляется с x, если x не предшествует y"],
            ["x|y","x или y"],
            ["x{n}","n-точное количество x"],
            ["x{n,}","n-минимальное количество x"],
            ["x{n,m}","n-минимальное количество x, m-максимальное (от,до)"]
          ]
        },
        {
          "id":"nav-149-1",
          "contentType":"nav",
          "content":[
            {
              "id":"subnav-1-0",
              "name":"jsr",
              "src":"https://learn.javascript.ru/regexp-methods",
              "title":""
            },
            {
              "id":"subnav-1-1",
              "name":"mdn",
              "src":"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
              "title":""
            }
          ]
        }
      ],
      "tags":[]
    },
    {
      "id":"178e0b06-4629-49a2-8b8d-91c1acb79223",
      "title":"151.Как изменить стили HTML-элемента?",
      "data":[
        {
          "id":"text-150-1",
          "contentType":"text",
          "content":"Это можно сделать либо с помощью свойства style, либо присвоив элементу соответствующий класс: "
        },
        {
          "id":"code-150-1",
          "contentType":"code",
          "content":"document\n.querySelector(selector)\n.style.property=value\ndocument\n.querySelector('title')\n.fontSize='2rem'\n\ndocument.querySelector(selector)\n.className='class-name'\ndocument.querySelector(selector)\n.classList.add('class-name')\ndocument.querySelector('button')\n.classList.add('active')"
        },
        {
          "id":"nav-150-1",
          "contentType":"nav",
          "content":[
            {
              "id":"subnav-1-0",
              "name":"jsr",
              "src":"https://learn.javascript.ru/styles-and-classes",
              "title":""
            },
            {
              "id":"subnav-1-1",
              "name":"mdn",
              "src":"https://developer.mozilla.org/ru/docs/Web/HTML/Global_attributes/style",
              "title":"style"
            },
            {
              "id":"subnav-1-2",
              "name":"mdn",
              "src":"https://developer.mozilla.org/ru/docs/Web/API/Element/className",
              "title":"className"
            },
            {
              "id":"subnav-1-3",
              "name":"mdn",
              "src":"https://developer.mozilla.org/ru/docs/Web/API/Element/classList",
              "title":"classList"
            }
          ]
        }
      ],
      "tags":[]
    },
    {
      "id":"0f01c6f2-f666-49bc-a2a2-c3453817a563",
      "title":"152.Что такое debugger(отладчик)?",
      "data":[
        {
          "id":"text-151-1",
          "contentType":"text",
          "content":"Выражение debugger открывает доступ к любому доступному в конкретном окружении отладочному функционалу, например, к установке контрольных точек(точек останова, брекпойнтов).Если функционал отладки в среде выполнения не доступен, данное выражение не будет иметь никакого эффекта: "
        },
        {
          "id":"code-151-1",
          "contentType":"code",
          "content":"const fun=()=>{\n//магия\ndebugger//вэтом месте выполнение функции будет приостановлено\n//магия\n}"
        },
        {
          "id":"nav-151-1",
          "contentType":"nav",
          "content":[
            {
              "id":"subnav-1-0",
              "name":"jsr",
              "src":"https://learn.javascript.ru/debugging-chrome",
              "title":""
            },
            {
              "id":"subnav-1-1",
              "name":"mdn",
              "src":"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/debugger",
              "title":""
            }
          ]
        }
      ],
      "tags":[]
    },
    {
      "id":"1242d4ef-5581-4ba5-9b93-8ae823bc70e3",
      "title":"153.Для чего используются контрольные точки debugger(отладчика)?",
      "data":[
        {
          "id":"text-152-1",
          "contentType":"text",
          "content":"Контрольные точки используются для приостановки выполнения функции или другого кода в определенном месте с целью выяснения причин неправильной работы программы. После остановки выполнение функции может быть продолжено."
        },
        {
          "id":"nav-152-1",
          "contentType":"nav",
          "content":[
            {
              "id":"subnav-1-0",
              "name":"jsr",
              "src":"https://learn.javascript.ru/debugging-chrome",
              "title":""
            },
            {
              "id":"subnav-1-1",
              "name":"mdn",
              "src":"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/debugger",
              "title":""
            }
          ]
        }
      ],
      "tags":[]
    },
    {
      "id":"0b62e0f1-14cb-4f88-829a-edaaa4d14d7d",
      "title":"154. Можно ли использовать зарезервированные слова в качестве идентификаторов?",
      "data":[
        {
          "id":"text-153-1",
          "contentType":"text",
          "content":"Нет, использовать зарезервированные слова в качестве названий переменных, меток, функций или объектов нельзя: "
        },
        {
          "id":"code-153-1",
          "contentType":"code",
          "content":"const class='Первый раз в первый класс'//SyntaxError: Unexpectedtoken'class'"
        }
      ],
      "tags":[]
    },{
      "id":"2f820c48-820e-48ef-b2be-52221264a57a",
      "title":"155. Как определить ширину и высоту изображения?",
      "data":[
        {
          "id":"text-154-1",
          "contentType":"text",
          "content":"Это можно сделать разными способами. Вот один из них: "
        },
        {
          "id":"code-154-1",
          "contentType":"code",
          "content":"const getImgSize = src=> {\nconst img = new Image()\n img.src = src\nimg.addEventListener('load',() => console.log(`${img.width}x${img.height}`))//276x110\ndocument.body.append(img)\n}\ngetImgSize('http://www.google.com/ intl/en_ALL/images/logo.gif')"
        },
        {
          "id":"nav-154-1",
          "contentType":"nav",
          "content":[
            {
              "id":"subnav-1-0",
              "name":"mdn",
              "src":"https://developer.mozilla.org/ru/docs/Web/API/HTMLImageElement/Image",
              "title":""
            }
          ]
        }
      ],
      "tags":[]
    },
    {
      "id":"f4ee1e0a-d082-448e-9f46-1e39d447642d",
      "title":"156. Как отправить синхронный HTTP-запрос?",
      "data":[
        {
          "id":"text-155-1",
          "contentType":"text",
          "content":"Для этого можно использовать объект XMLHttpRequest, передав его методу open() третий опциональный аргумент со значением false: "
        },
        {
          "id":"code-155-1",
          "contentType":"code",
          "content":"const getUsers = url => {\nconst xhr = new XMLHttpRequest()\nxhr.open('GET',url, false)\nxhr.send()\nconsole.table(xhr.response)\n\nconst response = JSON.parse(xhr.response)\nconst template=`\n<table>\n${response.reduce((html,user) => html += `\n<tr>\n<td>${user.name}</td>\n<td>${user.username}</td>\n<td>${user.email}</td>\n</tr>`,'')}\n<table>\n`\ndocument.body\n.insertAdjacentHTML('beforeend', template)\n}\n\ngetUsers('https://jsonplaceholder.typicode.com/users')"
        },
        {
          "id":"nav-155-1",
          "contentType":"nav",
          "content":[
            {
              "id":"subnav-1-0",
              "name":"jsr",
              "src":"https://learn.javascript.ru/xmlhttprequest",
              "title":""
            },
            {
              "id":"subnav-1-1",
              "name":"mdn",
              "src":"https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/XHR_(XMLHttpRequest)",
              "title":""
            }
          ]
        }
      ],
      "tags":[]
    },
    {
      "id":"cff4f099-5779-4ef5-986e-5f383f426671",
      "title":"157. Как сделать асинхронный HTTP-запрос?",
      "data":[
        {
          "id":"text-156-1",
          "contentType":"text",
          "content":"Для этого можно использовать метод fetch(): "
        },
        {
          "id":"code-156-1",
          "contentType":"code",
          "content":"const getUsers = async url => {\nconst response = await fetch(url)\nconst data = await response.json()\nconsole.table(data)\n\nconst template=`\n<table>\n${data.reduce((html, user) => html += `\n<tr>\n<td>${user.name}</td>\n<td>${user.username}</td>\n<td>${user.email}</td>\n</tr>`,'')}\n<table>\n`\ndocument.body.insertAdjacentHTML('beforeend', template)\n}\n\ngetUsers('https://jsonplaceholder.typicode.com/users')"
        },
        {
          "id":"nav-156-1",
          "contentType":"nav",
          "content":[
            {
              "id":"subnav-1-0",
              "name":"jsr",
              "src":"https://learn.javascript.ru/fetch",
              "title":""
            },
            {
              "id":"subnav-1-1",
              "name":"mdn",
              "src":"https://developer.mozilla.org/ru/docs/Web/API/Fetch_API",
              "title":""
            }
          ]
        }
      ],
      "tags":[]
    },
    {
      "id":"b50ec6ab-ebb5-440b-b4de-dd116475e0db",
      "title":"158. Как получить дату в нужном формате?",
      "data":[
        {
          "id":"text-157-1",
          "contentType":"text",
          "content":"Для этого можно использовать метод toLocaleString(): "
        },
        {
          "id":"code-157-1",
          "contentType":"code",
          "content":"console.log(\nnewDate().toLocaleString('ru-Ru',{\nweekday: 'long',\nyear: 'numeric',\nmonth: 'long',\nday: 'numeric'\n})\n)//воскресенье, 6сентября2020г."
        },
        {
          "id":"nav-157-1",
          "contentType":"nav",
          "content":[
            {
              "id":"subnav-1-0",
              "name":"mdn",
              "src":"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString",
              "title":""
            }
          ]
        }
      ],
      "tags":[]
    },
    {
      "id":"1f054d39-bf6f-40fd-8faa-d72906d8b964",
      "title":"159. Как получить максимальные размеры страницы?",
      "data":[
        {
          "id":"text-158-1",
          "contentType":"text",
          "content":" Для этого нужно найти максимальные значения свойств scrollWidth, offsetWidth, clientWidth и scrollHeight, offsetHeight, clientHeight объектов document.body и document.documentElement: "
        },
        {
          "id":"code-158-1",
          "contentType":"code",
          "content":"const pageWidth = Math.max(\ndocument.body.scrollWidth, document.documentElement.scrollWidth,\ndocument.body.offsetWidth, document.documentElement.offsetWidth,\ndocument.body.clientWidth, document.documentElement.clientWidth\n)\nconst pageHeight = Math.max(\ndocument.body.scrollHeight, document.documentElement.scrollHeight,\ndocument.body.offsetHeight, document.documentElement.offsetHeight,\ndocument.body.clientHeight, document.documentElement.clientHeight\n)\nconst pageSize = {\nwidth: pageWidth,\nheigth: pageHeight\n}\nconsole.log(pageSize)\n\nconst pageCenter = {\ncenterX: pageWidth/2,\ncenterY: pageHeight/2\n}\nconsole.log(pageCenter)"
        },
        {
          "id":"nav-158-1",
          "contentType":"nav",
          "content":[
            {
              "id":"subnav-1-0",
              "name":"jsr",
              "src":"https://learn.javascript.ru/size-and-scroll",
              "title":""
            }
          ]
        }
      ],
      "tags":[]
    },
    {
      "id":"c2ab5a75-dee6-474c-af1c-4331353a3a26",
      "title":"160. Что такое условный или тернарный оператор?",
      "data":[
        {
          "id":"text-159-1",
          "contentType":"text",
          "content":"Тернарный оператор является сокращенным способом записи блока if...else: "
        },
        {
          "id":"code-159-1",
          "contentType":"code",
          "content":"let accesAllowed\nconst age = propmt('Сколько вам лет?')\n\n//if...else\nif(age>18){\naccesAllowed = true\n}else{\naccessAllowed = false\n}\n\n//тернарный оператор\n(age>18)\n?accesAllowed = true\n: accessAllowed = false"
        },
        {
          "id":"nav-159-1",
          "contentType":"nav",
          "content":[
            {
              "id":"subnav-1-0",
              "name":"jsr",
              "src":"https://learn.javascript.ru/ifelse",
              "title":""
            },
            {
              "id":"subnav-1-1",
              "name":"mdn",
              "src":"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%BD%D1%8B%D0%B9_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80",
              "title":""
            }
          ]
        }
      ],
      "tags":[]
    },
    {
      "id":"0dd59484-fab4-4ac9-86aa-3287b1d4ad5a",
      "title":"161. Можно ли использовать цепочку из тернарных операторов?",
      "data":[
        {
          "id":"text-160-1",
          "contentType":"text",
          "content":"Да, в этом случае тернарный оператор является альтернативой блока if...else if...else: "
        },
        {
          "id":"code-160-1",
          "contentType":"code",
          "content":"let accessAllowed\nconst getAge = () => prompt('Сколько вам лет?')\n\n//это всего лишь пример - не надо так делать\n//if...else if...else\nconst checkAge = (age = getAge () ) => {\nconsole.log(age)\nif(isNaN(age)){\nPromise.resolve(alert('Возраст должен быть числом')).then(accessAllowed = false).then(checkAge)\n}else if(age===null||age===''){\nPromise.resolve(alert('Введите ваш возраст')).then(accessAllowed = false).then(checkAge)\n}else if(age < 0){\nPromise.resolve(alert('Возраст не может быть меньше 0')).then(accessAllowed = false).then(checkAge)\n}else if(age > 100){\nPromise.resolve(alert('Возраст не может быть больше 100')).then(accessAllowed = false).then(checkAge)\n}else if(age < 18){\nPromise.resolve(alert('Извините, вы слишком молоды')).then(accessAllowed = false)\n}else{\nPromise.resolve(alert('Добро пожаловать!')).then(accessAllowed = true)\n}\nconsole.log(accessAllowed)\n}\n\n//тернарный оператор\nconst checkAge = (age = getAge()) => {\nisNaN(age)\n?Promise.resolve(alert('Возраст должен быть числом')).then(accessAllowed = false).then(checkAge)\n: (age===null||age==='')\n?Promise.resolve(alert('Введите ваш возраст')).then(accessAllowed = false).then(checkAge)\n: (age < 0)\n?Promise.resolve(alert('Возраст не может быть меньше 0')).then(accessAllowed = false).then(checkAge)\n: (age > 100)\n?Promise.resolve(alert('Возраст не может быть больше 100')).then(accessAllowed = false).then(checkAge)\n: (age<18)\n?Promise.resolve(alert('Извините, вы слишком молоды')).then(accessAllowed = false)\n: Promise.resolve(alert('Добро пожаловать!')).then(accessAllowed = true)\nconsole.log(accessAllowed)\n}"
        },
        {
          "id":"nav-160-1",
          "contentType":"nav",
          "content":[
            {
              "id":"subnav-1-0",
              "name":"jsr",
              "src":"https://learn.javascript.ru/ifelse",
              "title":""
            },
            {
              "id":"subnav-1-1",
              "name":"mdn",
              "src":"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%BD%D1%8B%D0%B9_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80",
              "title":""
            }
          ]
        }
      ],
      "tags":[]
    },
    {
      "id":"5853f27b-6555-4293-a004-1b81a5dae5ad",
      "title":"162. Как начать выполнение кода после полной загрузки страницы?",
      "data":[
        {
          "id":"text-161-1",
          "contentType":"text",
          "content":"Это можно сделать несколькими способами."
        },
        {
          "id":"text-161-2",
          "contentType":"text",
          "content":"Разместить тег script перед закрывающим тегом body или добавить ему атрибут defer: "
        },
        {
          "id":"code-161-1",
          "contentType":"code",
          "content":"<body>\n...\n<script src=\"script.js\"></script>\n</body>\n\n\n<head>\n    ...\n    <script src=\"script.js\" defer></script>\n</head>"
        },
        {
          "id": "text-161-3",
          "contentType": "text",
          "content": "Если ваш скрипт - это модуль, то вместо атрибута defer, нужно указать атрибут contentType со значением module:"
        },
        {
          "id": "code-161-2",
          "contentType": "code",
          "content": "<script src=\"script.js\" contentType=\"module\"></script>"
        },
        {
          "id": "text-161-4",
          "contentType": "text",
          "content": "Добавить тегу body атрибут onload:"
        },
        {
          "id": "code-161-3",
          "contentType": "code",
          "content": "<body onload=\"script()\"></body>"
        },
        {
          "id": "text-161-5",
          "contentType": "text",
          "content": "Добавить код в качестве обработчика события load объекта window:"
        },
        {
          "id": "code-161-4",
          "contentType": "code",
          "content": "window.onload = () => console.log('Страница полностью загружена')\n\n// или\nwindow.addEventListener('load', () => console.log('Страница полностью загружена'))"
        },
        {
          "id": "text-161-6",
          "contentType": "text",
          "content": "Сделать тоже самое для document.body:"
        },
        {
          "id": "code-161-5",
          "contentType": "code",
          "content": "document.body.onload = () => console.log('Страница полностью загружена')"
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "947430c5-a402-400d-bd1a-6e0f46adc34f",
      "title": "163. В чем разница между __proto__ и protocontentType?",
      "data": [
        {
          "id": "text-162-1",
          "contentType": "text",
          "content": "Свойство __proto__ (внутреннее скрытое свойство [[ProtocontentType]]) - это объект, от которого экземпляр наследует поля и методы. А protocontentType - это объект, который используется для создания __proto__ при создании экземпляра с помощью ключевого слова new:"
        },
        {
          "id": "code-162-1",
          "contentType": "code",
          "content": "class Person {\n    constructor(firstName, secondName) {\n        this.firstName = firstName\n        this.secondName = secondName\n    }\n    getFullName() {\n        return `${this.firstName} ${this.secondName}`\n    }\n\n}\n\nconst user = new Person('Иван', 'Иванов')\nconsole.log(user.getFullName()) // Иван Иванов\nconsole.log(user.__proto__.getFullName === Person.protocontentType.getFullName) // true\nconsole.log(Person.protocontentType) // {constructor: ƒ, getFullName: ƒ}\nconsole.log(user.protocontentType === undefined) // true"
        },
        {
          "id": "nav-162-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/protocontentType-inheritance",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Inheritance_and_the_protocontentType_chain",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "b5b0fa56-b15e-455b-9f1d-b9c4ebac2df3",
      "title": "164. Приведите пример обязательного использования точки с запятой",
      "data": [
        {
          "id": "text-163-1",
          "contentType": "text",
          "content": "Одним из случаев обязательного использования точки запятой является использование IIFE (Immediately Invoked Fuction Expression - немедленно вызываемого функционального выражения):"
        },
        {
          "id": "text-163-2",
          "contentType": "text",
          "content": "Например, следующий код:"
        },
        {
          "id": "code-163-1",
          "contentType": "code",
          "content": "try {\n    const x = 'Быть'\n\n    (() => {\n        console.log(x)\n    })()\n} catch {\n    console.log('Не быть')\n}"
        },
        {
          "id": "text-163-3",
          "contentType": "text",
          "content": "Будет интерпретирован так:"
        },
        {
          "id": "code-163-2",
          "contentType": "code",
          "content": "try {\n    const x = 'Быть'(() => {\n        console.log(x)\n    })()\n} catch {\n    console.log('Не быть')\n}"
        },
        {
          "id": "text-163-4",
          "contentType": "text",
          "content": "Поэтому в блоке try мы получаем ошибку contentTypeError: \"Быть\" is not a function, управление передается блоку catch, и в консоль выводится \"Не быть\"."
        },
        {
          "id": "text-163-5",
          "contentType": "text",
          "content": "Для того, чтобы код работал, как ожидается, он должен выглядеть так:"
        },
        {
          "id": "code-163-3",
          "contentType": "code",
          "content": "try {\n    // точку с запятой нужно поставить либо здесь\n    const x = 'Быть';\n    // либо здесь\n    ;(() => {\n        console.log(x)\n    })()\n} catch {\n    console.log('Не быть')\n}"
        },
        {
          "id": "text-163-6",
          "contentType": "text",
          "content": "Также не забывайте про случаи автоматического расставления точек с запятой."
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "80c03404-d5f0-412d-bc67-ab3df055522e",
      "title": "165. Для чего используется метод freeze()?",
      "data": [
        {
          "id": "text-164-1",
          "contentType": "text",
          "content": "Данный метод, как следует из его названия, служит для \"замораживания\" объекта. Замороженный объект является неизменяемым (иммутабельным). Это означает, что в такой объект нельзя добавлять новые свойства, удалять или изменять существующие. Также этот метод устанавливает configurable: false и writable: false для существующих свойств. Метод возвращает замороженный объект."
        },
        {
          "id": "code-164-1",
          "contentType": "code",
          "content": "'use strict'\nconst obj = {\n    mission: 'possible'\n}\n\nObject.freeze(obj)\nobj.mission = 'impossible' // contentTypeError: Cannot assign to read only property 'mission' of object '#<Object>'\n\ndelete obj.mission // contentTypeError: Cannot delete property 'mission' of #<Object>"
        },
        {
          "id": "text-164-2",
          "contentType": "text",
          "content": "Обратите внимание, что в нестрогом режиме исключение не выбрасывается, код просто не выполняется."
        },
        {
          "id": "nav-164-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/property-descriptors",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "221812af-79ca-4234-a133-605b9661a189",
      "title": "166. Зачем нужен метод freeze()?",
      "data": [
        {
          "id": "text-165-1",
          "contentType": "text",
          "content": "Парадигма объектно-ориентированного программирования гласит, что интерфейс, содержащий определенное количество элементов, должен быть иммутабельным, т.е. должна быть исключена возможность его расширения, модификации или использования элементов за пределами текущего контекста. Данный метод является алиасом ключевого слова final в некоторых других языках программирования."
        },
        {
          "id": "nav-165-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/property-descriptors",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "fa256af2-2d99-456b-bbfb-d471ca28a105",
      "title": "167. Как сделать первую букву каждого слова в строке заглавной?",
      "data": [
        {
          "id": "text-166-1",
          "contentType": "text",
          "content": "Одним из способов это сделать является следующий:"
        },
        {
          "id": "code-166-1",
          "contentType": "code",
          "content": "const capitilize = str => str.replace(\n    /[а-яё]S+/gi,\n    txt => txt[0].toUpperCase() + txt.slice(1).toLowerCase()\n)\n\nconsole.log(capitilize('аПтека, улИца, фонАрь')) // Аптека, Улица, Фонарь"
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "45928e46-0417-45c7-991b-442ce60d4c1f",
      "title": "168. Как узнать, что на странице отключен JavaScript?",
      "data": [
        {
          "id": "text-167-1",
          "contentType": "text",
          "content": "Для этого можно использовать тег noscript. Код внутри этого тега будет выполнен только в случае, если на странице отключен JavaScript:"
        },
        {
          "id": "code-167-1",
          "contentType": "code",
          "content": "console.log('JavaScript включен')\n\n<noscript>\n    <p>Включите JavaScript, или ничего не получится</p>\n</noscript>"
        },
        {
          "id": "text-167-2",
          "contentType": "text",
          "content": "Для того, чтобы отключить JavaScript в Chrome, заходим в настройки -> раздел \"Конфиденциальность и безопасность\" -> Настройки сайтов -> раздел \"Контент\" -> JavaScript."
        },
        {
          "id": "nav-167-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/HTML/Element/noscript",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "34d4a2cc-7233-4ea0-bb9d-187705ed37e3",
      "title": "169. Какие операторы поддерживаются JavaScript?",
      "data": [
        {
          "id": "text-168-1",
          "contentType": "text",
          "content": "Операторы служат для работы со значениями или операндами. JavaScript поддерживает следующие операторы:"
        },
        {
          "id": "list-168-1",
          "contentType": "list",
          "content": [
            "Арифметические: + (сложение, приведение к числу, конкатенация), - (вычитание), * (умножение), / (деление), % (деление по модулю, с остатком), ++ (инкремент), -- (декремент), ** (возведение в степень)",
            "операторы сравнения: == (абстрактное, нестрогое равенство), != (абстрактное неравенство), === (строгое равенство, проверка на идентичность), !== (строгое неравенство), >, >=, <, <=",
            "логические: && (и), || (или), ! (не) (!! (двойное отрицание) не является отдельным оператором)",
            "операторы присваивания: =, +=, -=, *=, /=, %=",
            "тернарный: ?...: (if...else)",
            "оператор contentTypeof: определяет тип операнда",
            "побитовые: & (и), | (или), ^ (исключающее или), ~ (не), << (левый сдвиг), >> (правый сдвиг), >>> (правый сдвиг с заполнением нулями)",
            "новые: ?. (опциональная цепочка), ?? (слияние с null)"
          ]
        },
        {
          "id": "code-168-1",
          "contentType": "code",
          "content": "// опциональная цепочка\nconst obj = {\n    foo: {\n        baz: {\n            qux: 'bar'\n        }\n    }\n}\n\n// тогда\nconsole.log(obj.foo.bar.baz.qux) // contentTypeError: Cannot read property 'baz' of undefined\n\nif (\n    obj.foo !== undefined &&\n    obj.foo.bar !== undefined &&\n    obj.foo.bar.baz !== undefined\n) {\n    console.log(obj.foo.bar.baz.qux) // ошибки не будет\n}\n\n// сейчас\nconsole.log(obj?.foo?.bar?.baz?.qux) // undefined\n\n// слияние с null\nconsole.log(\n    0 || 'default null', // 'default null'\n    0 ?? 'default null', // 0\n    '' || 'default string', // default string\n    '' ?? 'default string', // ''\n)"
        },
        {
          "id": "nav-168-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/operators",
              "title": "Операторы"
            },
            {
              "id": "subnav-1-1",
              "name": "jsr",
              "src": "https://learn.javascript.ru/logical-operators",
              "title": "Логические операторы"
            },
            {
              "id": "subnav-1-2",
              "name": "jsr",
              "src": "https://learn.javascript.ru/comparison",
              "title": "Операторы сравнения"
            },
            {
              "id": "subnav-1-3",
              "name": "jsr",
              "src": "https://learn.javascript.ru/ifelse",
              "title": "Условные операторы"
            },
            {
              "id": "subnav-1-4",
              "name": "jsr",
              "src": "https://learn.javascript.ru/bitwise-operators",
              "title": "Побитовые операторы"
            },
            {
              "id": "subnav-1-5",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Optional_chaining",
              "title": "Оператор опциональной последовательности"
            },
            {
              "id": "subnav-1-6",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Nullish_Coalescing_Operator",
              "title": "Оператор нулевого слияния"
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "7ead44dc-8639-42d9-a742-29b3555151e8",
      "title": "170. Для чего используется оператор rest ... (прочие параметры)?",
      "data": [
        {
          "id": "text-169-1",
          "contentType": "text",
          "content": "Оператор rest является альтернативой объекта arguments и возвращает массив из переданных функции аргументов:"
        },
        {
          "id": "code-169-1",
          "contentType": "code",
          "content": "const sum = (...rest) => rest.reduce((acc, cur) => acc + cur)\n\nconsole.log(sum(1, 2, 3)) // 6"
        },
        {
          "id": "text-169-2",
          "contentType": "text",
          "content": "Обратите внимание, что оператор rest должен передаваться в качестве последнего аргумента:"
        },
        {
          "id": "code-169-2",
          "contentType": "code",
          "content": "const fun = (x, ...rest, y) => console.log(rest) // SyntaxError: Rest parameter must be last formal parameter"
        },
        {
          "id": "nav-169-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/destructuring-assignment",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/rest_parameters",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "1639124c-eebb-4e51-9450-2bae307c34a6",
      "title": "171. Для чего используется оператор spread ... (оператор распространения)?",
      "data": [
        {
          "id": "text-170-1",
          "contentType": "text",
          "content": "Оператор spread используется для расширения (распаковки, разворачивания) итерируемых сущностей (массивов, строк). Распаковка означает преобразование, например, массива из чисел в набор простых значений:"
        },
        {
          "id": "code-170-1",
          "contentType": "code",
          "content": "const sum = (x, y, z) => x + y + z\n\nconst nums = [1, 2, 3]\n\nconsole.log(sum(...nums)) // 6"
        },
        {
          "id": "nav-170-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/destructuring-assignment",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Spread_syntax",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "24936513-1ee9-4880-8309-27b1aecec80b",
      "title": "172. Как определить, заморожен ли объект?",
      "data": [
        {
          "id": "text-171-1",
          "contentType": "text",
          "content": "Для того, чтобы определить, заморожен ли объект, т.е. является ли он неизменяемым (иммутабельным), используется метод isFrozen():"
        },
        {
          "id": "code-171-1",
          "contentType": "code",
          "content": "const obj = {\n    prop: 'Добро пожаловать в мир JavaScript!'\n}\n\nObject.freeze(obj)\n\nconsole.log(Object.isFrozen(obj)) // true"
        },
        {
          "id": "nav-171-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "644263f0-df59-4ffa-a9cc-7812eb04101a",
      "title": "173. Как определить равенство значений, используя объект?",
      "data": [
        {
          "id": "text-172-1",
          "contentType": "text",
          "content": "Для этого можно использовать метод is():"
        },
        {
          "id": "code-172-1",
          "contentType": "code",
          "content": "Object.is('двое из ларца', 'двое из ларца') // true\nObject.is(0.1 + 0.2, 0.3) // false\nObject.is(window, window) // true\nObject.is(+0, -0) // false\n\nconst objA = {}\nconst objB = objA\nObject.is(objA, objB) // true\nObject.is({}, {}) // false"
        },
        {
          "id": "text-172-2",
          "contentType": "text",
          "content": "Значения являются равными, если:"
        },
        {
          "id": "list-172-1",
          "contentType": "list",
          "content": [
            "оба являются undefined",
            "оба являются null",
            "оба являются true или false",
            "оба являются строками одинаковой длины с одинаковыми символами",
            "оба ссылаются на один объект",
            "оба являются числами, +0, -0 или NaN"
          ]
        },
        {
          "id": "nav-172-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/object",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/is",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "d9906e35-1f5a-4504-9479-f62e1e9777a5",
      "title": "174. Как создать копию объекта?",
      "data": [
        {
          "id": "text-173-1",
          "contentType": "text",
          "content": "Одним из самых надежных способов это сделать является использование метода assign():"
        },
        {
          "id": "code-173-1",
          "contentType": "code",
          "content": "const objA = {a: 1, b: 2}\nconst objB = Object.assign(objA)\n\nconsole.log(objB) // {a: 1, b: 2}\n\nconsole.log(objA === objB) // true"
        },
        {
          "id": "text-173-2",
          "contentType": "text",
          "content": "Также данный метод позволяет объединять объекты, исключая дубликаты:"
        },
        {
          "id": "code-173-2",
          "contentType": "code",
          "content": "const objA = {a: 1, b: 2}\nconst objB = {b: 2, c: 3}\n\nconst objC = Object.assign(objA, objB)\nconsole.log(objC) {a: 1, b: 2, c: 3}"
        },
        {
          "id": "text-173-3",
          "contentType": "text",
          "content": "Для копирования простых объектов можно использовать связку JSON.parse-JSON.stringify:"
        },
        {
          "id": "code-173-3",
          "contentType": "code",
          "content": "const objA = {a: 1, b: 2}\n\nconst objB = JSON.parse(JSON.stringify(objA))\n\nconsole.log(objB) // {a: 1, b: 2}"
        },
        {
          "id": "nav-173-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/object",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/assign",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "c007208a-0830-43bd-bbb0-5329864bf2d2",
      "title": "175. Что такое прокси?",
      "data": [
        {
          "id": "text-174-1",
          "contentType": "text",
          "content": "Объект Proxy «оборачивается» вокруг другого объекта и может перехватывать (и, при желании, самостоятельно обрабатывать) разные действия с ним, например чтение/запись свойств и другие."
        },
        {
          "id": "code-174-1",
          "contentType": "code",
          "content": "const handler = {\n    get: (obj, prop) => prop in obj\n        ? obj[prop]\n        : 0\n}\n\n// new Proxy(цель, обработчик)\nconst p = new Proxy({}, handler)\n\np.a = 1\np.b = true\n\nconsole.log(p.a, p.b) // 1 true\nconsole.log( 'c' in p, p.c) // false 0"
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "daded43e-c75d-4d69-9763-6b601af1db52",
      "title": "176. Для чего используется метод seal()?",
      "data": [
        {
          "id": "text-175-1",
          "contentType": "text",
          "content": "Данный метод \"запечатывает\" объект, запрещая добавлять/удалять свойства. Он также устанавливает configurable: false для всех существующих свойств. Однако, значения свойств такого объекта можно менять. Для проверки, является ли объект запечатанным, используется метод isSealed()."
        },
        {
          "id": "code-175-1",
          "contentType": "code",
          "content": "'use strict'\nconst obj = {\n    prop: 'Добро пожаловать в мир JavaScript!'\n}\n\nObject.seal(obj)\n\nobj.prop = 'Оставь надежду, всяк сюда входящий'\nconsole.log(Object.isSealed(obj)) // true\ndelete obj.prop // contentTypeError: Cannot delete property 'prop' of #<Object>\nconsole.log(obj.prop) // Оставь надежду, всяк сюда входящий"
        },
        {
          "id": "text-175-2",
          "contentType": "text",
          "content": "Обратите внимание, что в нестрогом режиме попытка удаления свойства запечатанного объекта тихо завершится ничем."
        },
        {
          "id": "nav-175-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/property-descriptors",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/seal",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "2a604ec4-2740-4e58-b214-65ee36001d1c",
      "title": "177. В чем разница между методами freeze() и seal()?",
      "data": [
        {
          "id": "text-176-1",
          "contentType": "text",
          "content": "Метод Object.seal() в отличие от метода Object.freeze() позволяет изменять существующие свойства объекта."
        },
        {
          "id": "code-176-1",
          "contentType": "code",
          "content": "'use strict'\nconst objA = {\n    prop: 'Быть'\n}\nObject.freeze(objA)\nobjA.prop = 'Не быть' // contentTypeError: Cannot assign to read only property 'prop' of object '#<Object>'\n\nconst objB = {\n    prop: 'Не быть'\n}\nObject.seal(objB)\nobjB.prop = 'Быть'\nconsole.log(objB.prop) // Быть"
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "006de352-d4a2-479d-9741-c7711e14c287",
      "title": "178. Как получить перечисляемые пары ключ/значение объекта?",
      "data": [
        {
          "id": "text-177-1",
          "contentType": "text",
          "content": "Метод Object.entries() возвращает массив из перечисляемых пар ключ/значение объекта в виде подмассивов в том же порядке, что и цикл for...in:"
        },
        {
          "id": "code-177-1",
          "contentType": "code",
          "content": "const obj = {\n    x: 1,\n    y: 2\n}\n\nconsole.log(Object.entries(obj)) // [[\"x\", 1], [\"y\", 2]]\n\nfor (let [key, value] of Object.entries(obj)) {\n    console.log(`${key}: ${value}`) // x: 1 y: 2\n}"
        },
        {
          "id": "nav-177-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/keys-values-entries",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/entries",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "b8b240d4-6764-4882-9f60-eee0e64a0a96",
      "title": "179. В чем главное отличие методов Object.keys(), Object.values() и Object.entries()?",
      "data": [
        {
          "id": "text-178-1",
          "contentType": "text",
          "content": "Метод Object.keys() возвращает ключи объекта, метод Object.values() - значения его свойств, а Object.entries() массив из пар ключ/значение:"
        },
        {
          "id": "code-178-1",
          "contentType": "code",
          "content": "const user = {\n    name: 'Ванька',\n    age: 30\n}\n\nconsole.log(Object.keys(user)) // [\"name\", \"age\"]\nconsole.log(Object.values(user)) // [\"Ванька\", 30]\nconsole.log(Object.entries(user)) // [[\"name\", \"Ванька\"], [\"age\", 30]]"
        },
        {
          "id": "nav-178-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/keys-values-entries",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/keys",
              "title": "Object.keys()"
            },
            {
              "id": "subnav-1-2",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/values",
              "title": "Object.values()"
            },
            {
              "id": "subnav-1-3",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/entries",
              "title": "Object.entries()"
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "8a34d9b9-2590-49bd-ad8c-0629db5b076b",
      "title": "180. Как создать объект с определенным прототипом, не используя функцию-конструктор и классы?",
      "data": [
        {
          "id": "text-179-1",
          "contentType": "text",
          "content": "Для этого можно использовать метод Object.create():"
        },
        {
          "id": "code-179-1",
          "contentType": "code",
          "content": "const firstUser = {\n    name: 'Ванька',\n    sayHi() {\n        console.log(`Привет, меня зовут ${this.name}!`)\n    }\n}\n\nconst secondUser = Object.create(firstUser)\n\nsecondUser.name = 'Петька'\nsecondUser.sayHi() // Привет, меня зовут Петька!"
        },
        {
          "id": "nav-179-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/protocontentType-inheritance",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/create",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "76323e45-15b1-4329-9f5b-8d24fbae4f1d",
      "title": "181. Для чего используется WeakSet?",
      "data": [
        {
          "id": "text-180-1",
          "contentType": "text",
          "content": "WeakSet используется для хранения коллекции объектов со слабыми ссылками. Другими словами, он служит дополнительным хранилищем объектов, используемых другим кодом. Такие объекты автоматически удаляются сборщиком мусора, когда становятся недостижимыми (неиспользуемыми), т.е. когда от объекта остается только ключ в WeakSet."
        },
        {
          "id": "code-180-1",
          "contentType": "code",
          "content": "const ws = new WeakSet()\nlet user = {}\n\nws.add(user)\nconsole.log(ws.has(user)) // true\n\nuser = null\nconsole.log(ws.has(user)) // false, структура была очищена автоматически"
        },
        {
          "id": "nav-180-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/weakmap-weakset",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "4a60ec75-009f-486f-98cd-80954a2abbe9",
      "title": "182. В чем разница между Set и WeakSet?",
      "data": [
        {
          "id": "text-181-1",
          "contentType": "text",
          "content": "Их основным отличием является то, что объекты, хранящиеся в WeakSet, имеют слабые ссылки, т.е. автоматически удаляются, как только становятся недостижимыми. Другие отличия состоят в следующем:"
        },
        {
          "id": "list-181-1",
          "contentType": "list",
          "content": [
            "В Set могут храниться любые значения, а в WeakSet - только объекты",
            "WeakSet не имеет свойства size",
            "WeakSet не имеет методов clear(), keys(), values(), forEach()",
            "WeakSet не является итерируемой сущностью"
          ]
        },
        {
          "id": "nav-181-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/weakmap-weakset",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "5baeeb07-0222-43c1-955a-e2fbb366abfe",
      "title": "183. Какие методы доступны в WeakSet?",
      "data": [
        {
          "id": "text-182-1",
          "contentType": "text",
          "content": "WeakSet обладает следующими методами:"
        },
        {
          "id": "list-182-1",
          "contentType": "list",
          "content": [
            "add(): добавляет объект в коллекцию",
            "delete(): удаляет объект из коллекции",
            "has(): определяет наличие объекта в коллекции",
            "length(): возвращает длину коллекции"
          ]
        },
        {
          "id": "code-182-1",
          "contentType": "code",
          "content": "const ws = new WeakSet()\nconst objA = {}\nconst objB = {}\n\nws.add(objA)\nws.add(objB)\nconsole.log(ws.has(objA)) // true\nconsole.log(ws.lenghth()) // 2\nws.delete(objA)\nconsole.log(ws.has(objA)) // false"
        },
        {
          "id": "nav-182-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/weakmap-weakset",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "8dc388f5-6fae-41a7-a08a-742f9554294a",
      "title": "184. Для чего используется WeakMap?",
      "data": [
        {
          "id": "text-183-1",
          "contentType": "text",
          "content": "WeakMap используется для хранения пар ключ/значение, в которых ключи имеют слабые ссылки. Другими словами, он служит дополнительным хранилищем ключей, используемых другим кодом. Такие ключи автоматически удаляются сборщиком мусора, когда становятся недостижимыми (неиспользуемыми), т.е. когда от них остается только ключ в WeakMap."
        },
        {
          "id": "code-183-1",
          "contentType": "code",
          "content": "const wm = new WeakMap()\nlet user = {}\nwm.set(user, 'user')\nconsole.log(wm.has(user)) // true\nuser = null\nconsole.log(wm.has(user)) // false, структура была очищена автоматически"
        },
        {
          "id": "nav-183-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/weakmap-weakset",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "276991ba-7a6b-4c4a-8a7b-7f0c45695bc8",
      "title": "185. В чем разница между Map и WeakMap?",
      "data": [
        {
          "id": "text-184-1",
          "contentType": "text",
          "content": "Их основным отличием является то, что ключи, хранящиеся в WeakMap, имеют слабые ссылки, т.е. автоматически удаляются как только становятся недостижимыми. Другие отличия состоят в следующем:"
        },
        {
          "id": "list-184-1",
          "contentType": "list",
          "content": [
            "В Map в качестве ключей могут использоваться любые значения, а в WeakMap - только объекты",
            "WeakMap не имеет свойства size",
            "WeakMap не имеет методов clear(), keys(), values(), entries(), forEach()",
            "WeakMap не является итерируемой сущностью"
          ]
        },
        {
          "id": "nav-184-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/weakmap-weakset",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "f9370872-3b2f-42ef-85f0-064ffff136f1",
      "title": "186. Какие методы доступны в WeakMap?",
      "data": [
        {
          "id": "text-185-1",
          "contentType": "text",
          "content": "WeakMap обладает следующими методами:"
        },
        {
          "id": "list-185-1",
          "contentType": "list",
          "content": [
            "set(): добавляет пару ключ/значение в объект",
            "delete(): удаляет значение по ключу",
            "has(): определяет наличие значения по ключу",
            "get(): возвращает значение по ключу"
          ]
        },
        {
          "id": "code-185-1",
          "contentType": "code",
          "content": "const wm = new WeakMap()\nconst firstUser = {}\nconst secondUser = {}\n\nwm.set(firstUser, 'Ванька')\nwm.set(secondUser, 'Петька')\nconsole.log(wm.has(firstUser)) // true\nconsole.log(wm.get(firstUser)) // Ванька\nwm.delete(secondUser)\nconsole.log(wm.has(secondUser)) // false"
        },
        {
          "id": "nav-185-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/weakmap-weakset",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "c99132d6-8a3b-4109-a7ec-49d0f2f7fc1f",
      "title": "187. Как закодировать URL?",
      "data": [
        {
          "id": "text-186-1",
          "contentType": "text",
          "content": "Для этого можно использовать метод encodeURI(). Данный метод преобразует все специальные символы, кроме , / ? : @ = + $ #"
        },
        {
          "id": "code-186-1",
          "contentType": "code",
          "content": "const url = 'https://ru.wikipedia.org/wiki/Лермонтов,_Михаил_Юрьевич'\nconst encoded = encodeURI(url)\nconsole.log(encoded) // https://ru.wikipedia.org/wiki/%D0%9B%D0..."
        },
        {
          "id": "nav-186-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/url",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/encodeURI",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "2ab538f8-bfde-420c-9bd2-5d203567e48b",
      "title": "188. Как раскодировать URL?",
      "data": [
        {
          "id": "text-187-1",
          "contentType": "text",
          "content": "Для этого можно использовать метод decodeURI():"
        },
        {
          "id": "code-187-1",
          "contentType": "code",
          "content": "const url = 'https://ru.wikipedia.org/wiki/%D0%9B%D0...'\nconst decoded = decodeURI(url)\nconsole.log(decoded) // https://ru.wikipedia.org/wiki/Лермонтов,_Михаил_Юрьевич"
        },
        {
          "id": "nav-187-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/url",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/decodeURI",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "ca8ab70b-5401-4064-ad53-113a49634063",
      "title": "189. Как вывести содержимое страницы на печать?",
      "data": [
        {
          "id": "text-188-1",
          "contentType": "text",
          "content": "Для этого можно использовать глобальный метод print(). Данный метод открывает специальное диалоговое окно с настройками печати:"
        },
        {
          "id": "code-188-1",
          "contentType": "code",
          "content": "<button>Печать</button>\n\ndocument.querySelector('button')\n    .addEventListener('click', () => print())"
        },
        {
          "id": "nav-188-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/API/Window/print",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "3f7acc35-9e6c-44b1-833a-ce0519595059",
      "title": "190. Что такое анонимная функция?",
      "data": [
        {
          "id": "text-189-1",
          "contentType": "text",
          "content": "Анонимная функция - это функция без названия. Такие функции часто присваиваются переменным, а также используются в качестве колбэков:"
        },
        {
          "id": "code-189-1",
          "contentType": "code",
          "content": "const sayHi = function () {\n    console.log('Привет')\n}\nsayHi() // Привет\n// или\nconst sayBye = () => console.log('Пока')\nsayBye() // Пока\n\nwindow.addEventListener('click', function () {\n    console.log('Не буди лихо, пока оно тихо')\n})\n// или\nwindow.addEventListener('contextmenu', e => {\n    e.preventDefault()\n    console.log('Контекстное меню - детям не игрушка')\n})"
        },
        {
          "id": "nav-189-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/function-basics",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "339a3c1d-180f-496b-846a-f7b8d14f6e9d",
      "title": "191. Каков приоритет использования локальных и глобальных переменных?",
      "data": [
        {
          "id": "text-190-1",
          "contentType": "text",
          "content": "Локальные переменные имеют приоритет над одноименными глобальными переменными:"
        },
        {
          "id": "code-190-1",
          "contentType": "code",
          "content": "let question = 'Не быть'\n\nfunction toBe () {\n    question = 'Быть'\n    console.log(question)\n}\ntoBe() // Быть"
        },
        {
          "id": "nav-190-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/variables",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/Variable",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "3d4b91f0-c397-4cbc-93c2-f7224adcdd4e",
      "title": "192. Что такое аксессоры?",
      "data": [
        {
          "id": "text-191-1",
          "contentType": "text",
          "content": "Аксессоры или вычисляемые свойства - это геттеры и сеттеры. Геттеры используются для получения значений свойств объекта, а сеттеры - для их установки:"
        },
        {
          "id": "code-191-1",
          "contentType": "code",
          "content": "class User {\n    constructor (name, age) {\n        this.name = name\n        this.age = age\n    }\n\n    #access = false\n\n    get access () {\n        return this.#access\n    }\n\n    set access (bool) {\n        this.#access = bool\n    }\n}\n\nconst user = new User('Ванька', 30)\nconsole.log(user.#access) // SyntaxError: Private field '#access' must be declared in an enclosing class\n\nconsole.log(user.access) // false\nuser.access = true\nconsole.log(user.access) // true"
        },
        {
          "id": "text-191-2",
          "contentType": "text",
          "content": "Геттеры и сеттеры - это свойства, а методы - функции:"
        },
        {
          "id": "code-191-2",
          "contentType": "code",
          "content": "class User {\n    constructor (name, age) {\n        this.name = name\n        this.age = age\n    }\n\n    #access = false\n\n    getAccess () {\n        return this.#access\n    }\n\n    setAccess(bool) {\n        this.#access = bool\n    }\n}\n\nconst user = new User('Ванька', 30)\nconsole.log(user.#access) // SyntaxError: Private field '#access' must be declared in an enclosing class\n\nconsole.log(user.getAccess()) // false\nuser.setAccess(true)\nconsole.log(user.getAccess()) // true"
        },
        {
          "id": "nav-191-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/property-accessors",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "0026c226-60a0-4fd5-8bc7-0a490ed8f1ac",
      "title": "193. Как определить свойство в конструкторе объекта?",
      "data": [
        {
          "id": "text-192-1",
          "contentType": "text",
          "content": "Для этого можно использовать метод Object.defineProperty(). Данный метод позволяет добавлять новые свойства к объекту и модифицировать существующие, а также изменять настройки доступа к объекту:"
        },
        {
          "id": "code-192-1",
          "contentType": "code",
          "content": "'use strict'\nconst obj = {}\n\nObject.defineProperty(obj, 'prop', {\n    value: 1,\n    writable: false\n})\n\nconsole.log(obj.prop) // 1\nobj.prop = 2 // contentTypeError: Cannot assign to read only property 'prop' of object '#<Object>'"
        },
        {
          "id": "text-192-2",
          "contentType": "text",
          "content": "В нестрогом режиме попытка изменить свойство только для чтения тихо завершится ничем."
        },
        {
          "id": "nav-192-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/property-descriptors",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "be9bfdfd-6f0b-4db2-a5ba-c444bbac9ebb",
      "title": "194. В чем заключаются особенности геттеров и сеттеров?",
      "data": [
        {
          "id": "text-193-1",
          "contentType": "text",
          "content": "Основными особенностями геттеров и сеттеров является следующее:"
        },
        {
          "id": "list-193-1",
          "contentType": "list",
          "content": [
            "Они имеют более простой по сравнению с методами синтаксис",
            "Используются для определения вычисляемых свойств - аксессоров",
            "Позволяют обеспечить одинаковые отношения между свойствами и методами",
            "Могут обеспечивать более высокое качество данных",
            "Позволяют выполнять задачи за сценой, когда речь идет об инкапсуляции"
          ]
        },
        {
          "id": "nav-193-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/property-accessors",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "c5185a15-e4ea-4e66-88c3-1a0340a10aa8",
      "title": "195. Можно ли добавить к объекту геттеры и сеттеры с помощью метода Object.defineProperty()?",
      "data": [
        {
          "id": "text-194-1",
          "contentType": "text",
          "content": "Вполне:"
        },
        {
          "id": "code-194-1",
          "contentType": "code",
          "content": "const obj = {counter: 0}\n\nObject.defineProperty(obj, 'increment', {\n    get() {return ++this.counter}\n})\nObject.defineProperty(obj, 'decrement', {\n    get() {return --this.counter}\n})\n\nObject.defineProperty(obj, 'sum', {\n    set(val) {return this.counter += val}\n})\nObject.defineProperty(obj, 'sub', {\n    set(val) {return this.counter -= val}\n})\n\nobj.sum = 10\nobj.sub = 5\nconsole.log(obj) // {counter: 5}\nconsole.log(obj.increment) // 6\nconsole.log(obj.decrement) // 5"
        },
        {
          "id": "nav-194-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/property-descriptors",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "608fd663-c1fd-43c7-88e3-2e102f8442b4",
      "title": "196. Для чего используется switch...case?",
      "data": [
        {
          "id": "text-195-1",
          "contentType": "text",
          "content": "switch...case является альтернативой if...else и представляет собой более наглядный способ выполнения кода в зависимости от переданного условия:"
        },
        {
          "id": "code-195-1",
          "contentType": "code",
          "content": "const calc = (x, y, operator) => {\n    let result\n\n    try {\n        switch (operator) {\n            case '+':\n                result = x + y\n                break\n            case '-':\n                result = x - y\n                break\n            case '*':\n                result = x * y\n                break\n            case '/':\n                result = x / y\n                break\n            default:\n                throw new Error('Некорректная операция')\n        }\n\n        if (isNaN(result)) {\n            throw new Error('Операнды должны быть числами')\n        }\n\n        console.log(result)\n        return result\n    } catch (e) {\n        console.error(e.message)\n    }\n}\n\ncalc(1, 2, '+') // 3\ncalc(3, 4, '*') // 12\ncalc('a', 1, '-') // Операнды должны быть числами\ncalc(5, 6, 'x') // Некорректная операция"
        },
        {
          "id": "nav-195-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/switch",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/switch",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "a80dc433-3481-48e8-8055-661c6411610b",
      "title": "197. Назовите правила использования switch...case",
      "data": [
        {
          "id": "text-196-1",
          "contentType": "text",
          "content": "При использовании конструкции switch...case необходимо придерживаться следующих правил:"
        },
        {
          "id": "list-196-1",
          "contentType": "list",
          "content": [
            "условие может быть числом или строкой",
            "не допускается дублирование значений",
            "инструкция default является опциональной. Если ни для одного блока case не найдено совпадения, выполняется блок default",
            "break используется для остановки цикла",
            "break также является опциональным, но без него выполнение цикла продолжится"
          ]
        },
        {
          "id": "nav-196-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "jsr",
              "src": "https://learn.javascript.ru/switch",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/switch",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "c32a3e1c-7fbb-4f8a-b56c-49a2bbe713b0",
      "title": "198. Назовите примитивные типы данных.",
      "data": [
        {
          "id": "text-197-1",
          "contentType": "text",
          "content": "Примитивными типами данных (\"примитивами\") в JavaScript являются следующие значения:"
        },
        {
          "id": "list-197-1",
          "contentType": "list",
          "content": [
            "number для любых чисел: целочисленных или чисел с плавающей точкой, целочисленные значения ограничены диапазоном ±253",
            "bigint для целых чисел произвольной длины",
            "string для строк. Строка может содержать один или больше символов, нет отдельного символьного типа",
            "boolean для true/false",
            "null для неизвестных значений – отдельный тип, имеющий одно значение null",
            "undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined",
            "symbol для уникальных идентификаторов"
          ]
        },
        {
          "id": "nav-197-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "",
              "src": "https://learn.javascript.ru/contentTypes",
              "title": ""
            },
            {
              "id": "subnav-1-1",
              "name": "mdn",
              "src": "https://developer.mozilla.org/ru/docs/%D0%A1%D0%BB%D0%BE%D0%B2%D0%B0%D1%80%D1%8C/contentType",
              "title": ""
            }
          ]
        }
      ],
      "tags": [

      ]
    },
    {
      "id": "ea12fb10-8c3b-4672-bd22-ac4e26dd4889",
      "title": "Дополнительная литература",
      "data": [
        {
          "id": "nav-198-1",
          "contentType": "nav",
          "content": [
            {
              "id": "subnav-1-0",
              "name": "hab",
              "src": "https://habr.com/ru/company/ruvds/blog/482472/",
              "title": "Из чего сделан JavaScript?"
            },
            {
              "id": "subnav-1-1",
              "name": "hab",
              "src": "https://habr.com/ru/company/ruvds/blog/477284/",
              "title": "Зачем в JavaScript нужен строгий режим?"
            },
            {
              "id": "subnav-1-2",
              "name": "нас",
              "src": "https://medium.com/devschacht/javascript-coercions-9a36505c1370",
              "title": "ько JavaScript сильный?"
            },
            {
              "id": "subnav-1-3",
              "name": "med",
              "src": "https://medium.com/nmc-techblog/advanced-javascript-es6-temporal-dead-zone-default-parameters-and-let-vs-var-deep-dive-ca588fcde21b",
              "title": "- Advanced JavaScript ES6 — Temporal Dead Zone, Default Parameters And Let vs Var — Deep dive!"
            },
            {
              "id": "subnav-1-4",
              "name": "jav",
              "src": "https://habr.com/ru/post/517338/",
              "title": "ript: область видимости простыми словами"
            },
            {
              "id": "subnav-1-5",
              "name": "дел",
              "src": "https://medium.com/@stasonmars/%D0%B4%D0%B5%D0%BB%D0%B5%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B8%CC%86-%D0%B2-javascript-d91cbdd8916a",
              "title": "рование событий в JavaScript"
            },
            {
              "id": "subnav-1-6",
              "name": "med",
              "src": "https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D0%BC-%D0%B7%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B2-javascript-%D1%80%D0%B0%D0%B7-%D0%B8-%D0%BD%D0%B0%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-c211805b6898",
              "title": "- Понимаем замыкания в JavaScript. Раз и навсегда"
            },
            {
              "id": "subnav-1-7",
              "name": "hab",
              "src": "https://habr.com/ru/company/ruvds/blog/513764/",
              "title": "Дэн Абрамов о замыканиях в JavaScript"
            },
            {
              "id": "subnav-1-8",
              "name": "med",
              "src": "https://medium.com/madhash/understanding-protocontentTypes-in-javascript-e466244da086",
              "title": "- Understanding ProtocontentTypes in JavaScript"
            },
            {
              "id": "subnav-1-9",
              "name": "med",
              "src": "https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%BE-%D0%BE-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0%D1%85-apply-call-%D0%B8-bind-%D0%BD%D0%B5%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B8%D0%BC%D1%8B%D1%85-%D0%BA%D0%B0%D0%B6%D0%B4%D0%BE%D0%BC%D1%83-javascript-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D1%83-ddd5f9b06290",
              "title": "- Подробно о методах apply(), call() и bind(), необходимых каждому JavaScript разработчику"
            },
            {
              "id": "subnav-1-10",
              "name": "jav",
              "src": "https://habr.com/ru/post/518386/",
              "title": "ript: полное руководство по классам"
            },
            {
              "id": "subnav-1-11",
              "name": "med",
              "src": "https://medium.com/javascript-in-plain-english/javascript-classes-an-in-depth-look-part-1-47d8f4e77cbd",
              "title": "- JavaScript Classes: An In-Depth look (Part 1)"
            },
            {
              "id": "subnav-1-12",
              "name": "med",
              "src": "https://medium.com/@stasonmars/%D1%80%D0%B0%D0%B7%D0%B1%D0%B8%D1%80%D0%B0%D0%B5%D0%BC%D1%81%D1%8F-%D1%81-%D0%BF%D1%83%D1%82%D0%B0%D0%BD%D0%B8%D1%86%D0%B5%D0%B9-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-javascript-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0%D0%BC%D0%B8-slice-splice-%D0%B8-split-6e72363baf1d",
              "title": "- Разбираемся с путаницей между JavaScript методами slice(), splice() и split()"
            },
            {
              "id": "subnav-1-13",
              "name": "коп",
              "src": "https://medium.com/@stasonmars/%D0%BA%D0%BE%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%B2-javascript-d25c261a7aff",
              "title": "вание объектов в JavaScript"
            },
            {
              "id": "subnav-1-14",
              "name": "нач",
              "src": "https://habr.com/ru/company/ruvds/blog/480354/",
              "title": "работы с методами JavaScript-массивов .map(), .filter() и .reduce()"
            },
            {
              "id": "subnav-1-15",
              "name": "как",
              "src": "https://medium.com/@stasonmars/%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-reduce-%D0%B2-javascript-%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-%D0%B5%D0%B3%D0%BE-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D1%8F%D1%82%D1%8C-%D0%B8-%D0%BA%D0%B0%D0%BA%D0%B8%D0%B5-%D0%BA%D1%80%D1%83%D1%82%D1%8B%D0%B5-%D0%B2%D0%B5%D1%89%D0%B8-%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE-%D1%81-%D0%BD%D0%B8%D0%BC-b650c397bee6",
              "title": "ботает reduce() в JavaScript"
            },
            {
              "id": "subnav-1-16",
              "name": "раб",
              "src": "https://medium.com/@stasonmars/%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D0%BC-%D1%81-%D0%B0%D1%81%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%BD%D0%BE%D0%B8%CC%86-%D0%B8%D1%82%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B5%D0%B8%CC%86-%D0%B2-ecmascript-2019-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D1%8F-for-of-cc0baa81cdd8",
              "title": "ем с асинхронной итерацией в ECMAScript 2019, используя for-of"
            },
            {
              "id": "subnav-1-17",
              "name": "нов",
              "src": "https://habr.com/ru/company/ruvds/blog/504586/",
              "title": "тва ES2020, которые мне очень нравятся"
            },
            {
              "id": "subnav-1-18",
              "name": "dig",
              "src": "https://www.digitalocean.com/community/tutorials/understanding-map-and-set-objects-in-javascript-ru",
              "title": "lOcean - Знакомство с объектами map и set в JavaScript"
            },
            {
              "id": "subnav-1-19",
              "name": "med",
              "src": "https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%BD%D0%B8%D0%BC%D0%B0%D0%B5%D0%BC-%D0%BA%D0%B0%D1%80%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B2-javascript-5ec4a1d88827",
              "title": "- Понимаем каррирование в JavaScript"
            },
            {
              "id": "subnav-1-20",
              "name": "med",
              "src": "https://medium.com/@mike_wong/what-is-memoization-in-javascript-5c6cdef49ad2",
              "title": "- What is Memoization in Javascript?"
            },
            {
              "id": "subnav-1-21",
              "name": "red",
              "src": "https://redd.one/blog/debounce-vs-throttle",
              "title": "Debounce vs Throttle: Definitive Visual Guide"
            },
            {
              "id": "subnav-1-22",
              "name": "пут",
              "src": "https://habr.com/ru/company/ruvds/blog/511590/",
              "title": "пониманию шаблонных литералов в JavaScript"
            },
            {
              "id": "subnav-1-23",
              "name": "hab",
              "src": "https://habr.com/ru/post/491252/",
              "title": "5 малоизвестных возможностей JSON.stringify()"
            },
            {
              "id": "subnav-1-24",
              "name": "hab",
              "src": "https://habr.com/ru/post/501198/",
              "title": "Понимание (всех) «модульных» форматов и инструментов JavaScript"
            },
            {
              "id": "subnav-1-25",
              "name": "hab",
              "src": "https://habr.com/ru/company/ruvds/blog/466537/",
              "title": "Использование JavaScript-модулей в продакшне: современное состояние дел. Часть 1"
            },
            {
              "id": "subnav-1-26",
              "name": "hab",
              "src": "https://habr.com/ru/post/491840/",
              "title": "Визуализация работы сервис-воркеров"
            },
            {
              "id": "subnav-1-27",
              "name": "goo",
              "src": "https://developers.google.com/web/fundamentals/primers/service-workers",
              "title": "Developers - Service Workers: an Introduction"
            },
            {
              "id": "subnav-1-28",
              "name": "hab",
              "src": "https://habr.com/ru/post/500834/",
              "title": "Хранилище для веба"
            },
            {
              "id": "subnav-1-29",
              "name": "web",
              "src": "https://webdevblog.ru/izuchaem-indexeddb/",
              "title": "Blog - Изучаем IndexedDB"
            },
            {
              "id": "subnav-1-30",
              "name": "goo",
              "src": "https://developers.google.com/web/ilt/pwa/working-with-indexeddb",
              "title": "Developers - Working with IndexedDB"
            },
            {
              "id": "subnav-1-31",
              "name": "hab",
              "src": "https://habr.com/ru/post/496348/",
              "title": "Web Storage API: примеры использования"
            },
            {
              "id": "subnav-1-32",
              "name": "hab",
              "src": "https://habr.com/ru/company/ruvds/blog/479268/",
              "title": "Прослушиватели событий и веб-воркеры"
            },
            {
              "id": "subnav-1-33",
              "name": "med",
              "src": "https://medium.com/young-coder/a-simple-introduction-to-web-workers-in-javascript-b3504f9d9d1c",
              "title": "- A Simple Introduction to Web Workers in JavaScript"
            },
            {
              "id": "subnav-1-34",
              "name": "hab",
              "src": "https://habr.com/ru/post/484466/",
              "title": "Распространенные ошибки при работе с промисами в JavaScript, о которых должен знать каждый"
            },
            {
              "id": "subnav-1-35",
              "name": "hab",
              "src": "https://habr.com/ru/post/501702/",
              "title": "Визуализация промисов и Async/Await"
            },
            {
              "id": "subnav-1-36",
              "name": "hab",
              "src": "https://habr.com/ru/post/514684/",
              "title": "Политика общего происхождения и CORS: визуальное руководство"
            }
          ]
        }
      ],
      "tags": [

      ]
    }
  ],
  "js-practice": [
    {
      "id": "b5dccc43-f414-48e7-99ff-f753af1a9c83",
      "code": "function sayHi() {\n    console.log(name);\n    console.log(age);\n    var name = \"Lydia\";\n    let age = 21;\n}\n\nsayHi();",
      "answers": {
        "A": "A: Lydia и undefined",
        "B": "B: Lydia и ReferenceError",
        "C": "C: ReferenceError и 21",
        "D": "D: undefined и ReferenceError"
      },
      "right_answer": "D",
      "details": "В функции мы сначала определяем переменную name с помощью ключевого слова var. Это означает, что name поднимется в начало функции. Name будет иметь значение undefined до тех пор, пока выполнение кода не дойдет до строки, где ей присваивается значение Lydia. Мы не определили значение name, когда пытаемся вывести ее в консоль, поэтому будет выведено undefined. Переменные, определенные с помощью ключевого слова let (и const), также поднимаются, но в отличие от var, не инициализируются. Доступ к ним до инициализации невозможен. Это называется 'временной мертвой зоной'. Когда мы пытаемся обратиться к переменным до их определения, JavaScript выбрасывает исключение ReferenceError."
    },
    {
      "id": "3dd2a48a-863d-4193-8911-43f3be3c800e",
      "code": "for (var i = 0; i < 3; i++) {\n    setTimeout(() => console.log(i), 1);\n}\n\nfor (let i = 0; i < 3; i++) {\n    setTimeout(() => console.log(i), 1);\n}",
      "answers": {
        "A": "A: 0 1 2 и 0 1 2",
        "B": "B: 0 1 2 и 3 3 3",
        "C": "C: 3 3 3 и 0 1 2",
        "D": "D: 3 3 3 и 3 3 3"
      },
      "right_answer": "C",
      "details": "Из-за очереди событий в JavaScript функция setTimeout вызывается после завершения цикла. Так как переменная i в первом цикле определяется с помощью ключевого слова var, она является глобальной. В цикле мы каждый раз увеличиваем значение i на 1, используя оператор ++. К моменту выполнения setTimeout в первом примере значение i равняется 3. Во втором цикле i определяется с помощью let. Такие переменные (а также переменные, объявленные с помощью const) имеют блочную область видимости (блок - это код внутри {}). На каждой итерации i будет иметь новое значение, и это значение будет замкнуто в области видимости внутри цикла."
    },
    {
      "id": "85b049c0-daad-4ef4-8335-44bd48a44c37",
      "code": "const shape = {\n    radius: 10,\n    diameter() {\n        return this.radius * 2;\n    },\n    perimeter: () => 2 * Math.PI * this.radius\n};\n\nconsole.log(shape.diameter());\nconsole.log(shape.perimeter());",
      "answers": {
        "A": "A: 20 и 62.83185307179586",
        "B": "B: 20 и NaN",
        "C": "C: 20 и 63",
        "D": "D: NaN и 63"
      },
      "right_answer": "B",
      "details": "Обратите внимание, что diameter - это обычная функция, а perimeter - стрелочная. У стрелочных функций, в отличие от обычных, значение this указывает на лексическое окружение. Это значит, что при вызове perimeter ее this указывает не на объект shape, а на внешнюю область видимости (объект window). У этого объекта нет свойства radius, поэтому возвращается undefined."
    },
    {
      "id": "797d9b81-d8a7-4a6e-a227-955cef7a0972",
      "code": "console.log(+true);\nconsole.log(!\"Lydia\");",
      "answers": {
        "A": "A: 1 и false",
        "B": "B: 0 и true",
        "C": "C: false и NaN",
        "D": "D: false и false"
      },
      "right_answer": "A",
      "details": "Унарный плюс приводит операнд к числу. true - это 1, а false - 0. Строка 'Lydia' - это истинное значение. Мы спрашиваем, является ли это истинное значение ложным? Ответ: false."
    },
    {
      "id": "1a063c50-f8d3-4865-bf58-992a3f482e18",
      "code": "let c = { greeting: \"Hey!\" };\nlet d;\n\nd = c;\nc.greeting = \"Hello\";\nconsole.log(d.greeting);",
      "answers": {
        "A": "A: Hello",
        "B": "B: Hey!",
        "C": "C: undefined",
        "D": "D: ReferenceError"
      },
      "right_answer": "A",
      "details": "В JavaScript все объекты являются 'ссылочными' типами данных, т.е. значения объектов передаются по ссылке. Сначала в переменной 'c' создается ссылка на объект. Затем мы указываем переменной 'd' ссылаться на тот же объект, что и 'c'. При изменении объекта меняются значения всех указывающих на него ссылок."
    },
    {
      "id": "76b44351-c9cb-4fdf-823d-0c278539f408",
      "code": "let a = 3;\nlet b = new Number(3);\nlet c = 3;\n\nconsole.log(a == b);\nconsole.log(a === b);\nconsole.log(b === c);",
      "answers": {
        "A": "A: true false true",
        "B": "B: false false true",
        "C": "C: true false false",
        "D": "D: false true true"
      },
      "right_answer": "C",
      "details": "new Number() - это встроенный конструктор функции. И хотя он выглядит как число, это не настоящее число: у него есть ряд дополнительных возможностей, это объект. Оператор == разрешает приведение типов, он проверяет равенство значений. Оба значения равны 3, поэтому возвращается true. При использовании оператора === значение и тип должны совпадать. В данном случае это не так: new Number() это не число, а объект. Поэтому два последних сравнения возвращают false."
    },
    {
      "id": "4fb0dd08-79ee-4060-932d-1512d4c09e5c",
      "code": "class Chameleon {\n    static colorChange(newColor) {\n        this.newColor = newColor;\n        return this.newColor;\n    }\n\n    constructor({ newColor = \"green\" } = {}) {\n            this.newColor = newColor;\n        }\n    }\n\nconst freddie = new Chameleon({ newColor: \"purple\" });\nfreddie.colorChange(\"orange\");",
      "answers": {
        "A": "A: orange",
        "B": "B: purple",
        "C": "C: green",
        "D": "D: TypeError"
      },
      "right_answer": "D",
      "details": "Функция colorChange() является статичной. Статичные методы не имеют доступа к экземплярам класса. Так как freddie - это экземпляр, статичный метод в нем не доступен. Поэтому выбрасывается исключение TypeError."
    },
    {
      "id": "75092a44-5354-448b-a5b6-423b51e3ac31",
      "code": "let greeting;\ngreetign = {}; // опечатка\nconsole.log(greetign);",
      "answers": {
        "A": "A: {}",
        "B": "B: ReferenceError: greetign is not defined",
        "C": "C: undefined",
        "D": "D: ''"
      },
      "right_answer": "A",
      "details": "С помощью greetign = {} мы создаем новый глобальный пустой объект, который и выводится в консоль. Когда мы вместо greeting написали greetign, компилятор выполнил global.greetign = {} в Node.js (или window.greetign = {} в браузере). В строгом режиме ('use strict') будет выброшено исключение ReferenceError: greetign is not defined."
    },
    {
      "id": "4fc70a6b-4acf-4d9e-80d2-7d0712d73281",
      "code": "function bark() {\n    console.log(\"Woof!\");\n}\n\nbark.animal = \"dog\";\n\nconsole.log(bark.animal);",
      "answers": {
        "A": "A: 'dog'",
        "B": "B: SyntaxError",
        "C": "C: undefined",
        "D": "D: ReferenceError"
      },
      "right_answer": "A",
      "details": "В JavaScript такое возможно, т.к. функции - это объекты. Точнее, функция — это специальный тип объекта, который можно вызывать. Кроме того, функция — это объект со свойствами. Свойства такого объекта нельзя вызывать, поскольку они не являются функциями."
    },
    {
      "id": "630926af-4a38-48d1-a10e-5aa6f2c7af82",
      "code": "function Person(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n}\n\nconst member = new Person(\"Lydia\", \"Hallie\");\nPerson.getFullName = function () {\n    return `${this.firstName} ${this.lastName}`;\n}\n\nconsole.log(member.getFullName());",
      "answers": {
        "A": "A: TypeError",
        "B": "B: SyntaxError",
        "C": "C: Lydia Hallie",
        "D": "D: undefined undefined"
      },
      "right_answer": "A",
      "details": "Нельзя добавлять свойства к конструктору как к обычному объекту. Если необходимо добавить свойство или метод всем экземплярам, то следует использовать прототипы. В данном случае Person.prototype.getFullName = function () { return `${this.firstName} ${this.lastName}` } сделает метод member.getFullName() рабочим. В чем тут преимущество? Предположим, что мы добавили этот метод к конструктору. Возможно, не каждому экземпляру Person нужен этот метод. Это приведет к большим потерям памяти, т.к. все экземпляры будут иметь указанное свойство. Напротив, если мы добавим данный метод к прототипу, у нас будет только одно место в памяти, к которому смогут обращаться все экземпляры."
    },
    {
      "id": "2afd874d-d7fb-42e5-b4d0-a5cb02b7b199",
      "code": "function Person(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n}\n\nconst lydia = new Person(\"Lydia\", \"Hallie\");\nconst sarah = Person(\"Sarah\", \"Smith\");\n\nconsole.log(lydia);\nconsole.log(sarah);",
      "answers": {
        "A": "A: Person {firstName: 'Lydia', lastName: 'Hallie'} и undefined",
        "B": "B: Person {firstName: 'Lydia', lastName: 'Hallie'} и Person {firstName: 'Sarah', lastName: 'Smith'}",
        "C": "C: Person {firstName: 'Lydia', lastName: 'Hallie'} и {}",
        "D": "D: Person {firstName: 'Lydia', lastName: 'Hallie'} и ReferenceError"
      },
      "right_answer": "A",
      "details": "Мы создаем объект sarah без ключевого слова new. Использование new приводит к созданию нового объекта (экземпляра). Без new создается глобальный объект. Мы указали, что this.firstName равняется 'Sarah' и this.lastName - 'Smith'. На самом деле, мы определили global.firstName = 'Sarah' и global.lastName = 'Smith'. sarah = undefined, поскольку мы не возвращаем значение из Person."
    },
    {
      "id": "5df1caa9-ee14-4920-8f8c-29488f955700",
      "code": "function sum(a, b) {\n    return a + b;\n}\n\nconsole.log(sum(1, \"2\"));",
      "answers": {
        "A": "A: NaN",
        "B": "B: TypeError",
        "C": "C: '12'",
        "D": "D: 3"
      },
      "right_answer": "C",
      "details": "JavaScript - это динамически типизированный язык (язык со слабой типизацией): мы не определяем тип данных. Значения переменных могут быть автоматически преобразованы из одного типа в другой без нашего участия, что называется неявным приведением типов. Приведение - это преобразование данных из одного типа в другой. В примере JavaScript конвертировал число 1 в строку, чтобы операция в функции имела смысл и вернула хоть какое-то значение. Во время сложения числа (1) и строки ('2') число преобразовывается в строку. Мы можем конкатенировать (объединять) строки так: 'Hello' + 'World'. Таким образом, 1 + '2' возвращает '12'."
    },
    {
      "id": "cd159db9-5df4-49cf-af61-295d4881275e",
      "code": "let number = 0;\nconsole.log(number++);\nconsole.log(++number);\nconsole.log(number);",
      "answers": {
        "A": "A: 1 1 2",
        "B": "B: 1 2 2",
        "C": "C: 0 2 2",
        "D": "D: 0 1 2"
      },
      "right_answer": "C",
      "details": "Постфиксный оператор ++:<br> Возвращает значение (0)<br> Инкрементирует (увеличивает) значение (теперь number = 1)<br> Префиксный оператор ++:<br> Инкрементирует значение (теперь number = 2)<br> Возвращает значение (2)<br> Результат: 0 2 2."
    },
    {
      "id": "90d6ece0-d5bc-4f8d-945a-a7ebbe79117e",
      "code": "function getPersonInfo(one, two, three) {\n    console.log(one);\n    console.log(two);\n    console.log(three);\n}\n\nconst person = \"Lydia\";\nconst age = 21;\n\ngetPersonInfo`${person} is ${age} years old`;",
      "answers": {
        "A": "A: 'Lydia' 21 ['', ' is ', ' years old']",
        "B": "B: ['', ' is ', ' years old'] 'Lydia' 21",
        "C": "C: 'Lydia' ['', ' is ', ' years old'] 21",
        "D": "D: undefined"
      },
      "right_answer": "B",
      "details": "При использовании тегированных шаблонных (строковых) литералов первым аргументом является массив строковых значений. Прочими аргументами являются переданные значения."
    },
    {
      "id": "52f366dc-def0-47d6-b158-cafef1fcad14",
      "code": "function checkAge(data) {\n    if (data === { age: 18 }) {\n        console.log(\"Ты взрослый!\");\n    } else if (data == { age: 18 }) {\n        console.log(\"Ты по-прежнему взрослый.\");\n    } else {\n        console.log(\"Хм... Кажется, у тебя нет возраста.\");\n    }\n}\n\ncheckAge({ age: 18 });",
      "answers": {
        "A": "A: Ты взрослый!",
        "B": "B: Ты по-прежнему взрослый.",
        "C": "C: Хм... Кажется, у тебя нет возраста.",
        "D": "D: undefined"
      },
      "right_answer": "C",
      "details": "В операциях сравнения примитивы сравниваются по значениям, а объекты - по ссылкам. JavaScript проверяет, чтобы объекты указывали на одну и ту же область памяти. Сравниваемые объекты в примере не такие: объект, переданный в качестве параметра, указывает на другую область памяти, нежели объекты, используемые в сравнениях. Поэтому { age: 18 } === { age: 18 } и { age: 18 } == { age: 18 } возвращают false."
    },
    {
      "id": "05b217b8-7681-49ec-8b48-5a002a197224",
      "code": "function getAge(...args) {\n    console.log(typeof args);\n}\n\ngetAge(21);",
      "answers": {
        "A": "A: 'number'",
        "B": "B: 'array'",
        "C": "C: 'object'",
        "D": "D: 'NaN'"
      },
      "right_answer": "C",
      "details": "Оператор распространения (spread) ...args возвращает массив с аргументами. Массив - это объект, поэтому typeof args возвращает 'object'."
    },
    {
      "id": "3b2b52e5-e040-4380-bb26-0bacb8e7901c",
      "code": "function getAge() {\n    \"use strict\";\n    age = 21;\n    console.log(age);\n}\n\ngetAge();",
      "answers": {
        "A": "A: 21",
        "B": "B: undefined",
        "C": "C: ReferenceError",
        "D": "D: TypeError"
      },
      "right_answer": "C",
      "details": "'use strict' позволяет избежать случайного объявления глобальных переменных. Мы не объявляли переменную age, поэтому в строгом режиме выбрасывается исключение ReferenceError. В нестрогом режиме ошибки не возникнет, а переменная age станет свойством глобального объекта."
    },
    {
      "id": "e461c4ea-2c61-4b92-9599-269ede7ae239",
      "code": "const sum = eval(\"10*10+5\");\n\nconsole.log(sum);",
      "answers": {
        "A": "A: 105",
        "B": "B: '105'",
        "C": "C: TypeError",
        "D": "D: '10*10+5'"
      },
      "right_answer": "A",
      "details": "eval выполняет код, переданный в виде строки. Если это выражение (как в данном случае), то оно вычисляется (оценивается). Выражение 10 * 10 + 5 возвращает число 105. Использовать eval в настоящее время не рекомендуется."
    },
    {
      "id": "a0d480b2-c372-43e8-8bd9-4ece8130c5dd",
      "code": "var num = 8;\nvar num = 10;\n\nconsole.log(num);",
      "answers": {
        "A": "A: 8",
        "B": "B: 10",
        "C": "C: SyntaxError",
        "D": "D: ReferenceError"
      },
      "right_answer": "B",
      "details": "С помощью ключевого слова var можно определять любое количество одноименных переменных. Переменная будет хранить последнее присвоенное значение. Но такой трюк нельзя проделать с let и const, т.к. они имеют блочную область видимости."
    },
    {
      "id": "f06b6223-60fc-44db-9d99-e859659e7aff",
      "code": "const obj = { 1: \"a\", 2: \"b\", 3: \"c\" };\nconst set = new Set([1, 2, 3, 4, 5]);\n\nconsole.log(obj.hasOwnProperty(\"1\"));\nconsole.log(obj.hasOwnProperty(1));\nconsole.log(set.has(\"1\"));\nconsole.log(set.has(1));",
      "answers": {
        "A": "A: false true false true",
        "B": "B: false true true true",
        "C": "C: true true false true",
        "D": "D: true true true true"
      },
      "right_answer": "C",
      "details": "Ключи объектов (кроме Symbol) являются строками, даже если заданы не в виде строк. Поэтому obj.hasOwnProperty('1') также возвращает true. Однако, это не работает применительно к set. Значение '1' отсутствует в set: set.has('1') возвращает false, а set.has(1) = true."
    },
    {
      "id": "0aba35f4-30b8-41f0-a2ce-080b5a8dd224",
      "code": "const obj = { a: \"one\", b: \"two\", a: \"three\" };\nconsole.log(obj);",
      "answers": {
        "A": "A: { a: 'one', b: 'two' }",
        "B": "B: { b: 'two', a: 'three' }",
        "C": "C: { a: 'three', b: 'two' }",
        "D": "D: SyntaxError"
      },
      "right_answer": "C",
      "details": "Если имеется два ключа с одинаковым именем, то ключ перезаписывается. Его позиция сохраняется, но значением является последнее из присвоенных."
    },
    {
      "id": "180997e2-3938-4f16-b493-e85baafdbc4b",
      "code": "for (let i = 1; i < 5; i++) {\n    if (i === 3) continue;\n    console.log(i);\n}",
      "answers": {
        "A": "A: 1 2",
        "B": "B: 1 2 3",
        "C": "C: 1 2 4",
        "D": "D: 1 3 4"
      },
      "right_answer": "C",
      "details": "Оператор continue пропускает итерацию, если условие является истинным."
    },
    {
      "id": "8b07cdd8-8498-4b6e-8be3-625697c1b52a",
      "code": "String.prototype.giveLydiaPizza = () => {\n    return \"Just give Lydia pizza already!\";\n};\n\nconst name = \"Lydia\";\n\nconsole.log(name.giveLydiaPizza());",
      "answers": {
        "A": "A: 'Just give Lydia pizza already!'",
        "B": "B: TypeError: name.giveLydiaPizza is not a function",
        "C": "C: SyntaxError",
        "D": "D: undefined"
      },
      "right_answer": "A",
      "details": "String - это встроенный конструктор, к которому можно добавлять свойства. Мы добавили метод к его прототипу. Строки-примитивы автоматически конвертируются (преобразуются) в строки-объекты. Поэтому все строки (объекты) имеют доступ к указанному методу."
    },
    {
      "id": "290c6ae0-751f-4abe-9734-f56bff5d3aeb",
      "code": "const a = {};\nconst b = { key: \"b\" };\nconst c = { key: \"c\" };\n\na[b] = 123;\na[c] = 456;\n\nconsole.log(a[b]);",
      "answers": {
        "A": "A: 123",
        "B": "B: 456",
        "C": "C: undefined",
        "D": "D: ReferenceError"
      },
      "right_answer": "B",
      "details": "Ключи объекта автоматически преобразуются в строки. Мы пытаемся добавить объект в качестве ключа к объекту 'a' со значением 123. Однако, когда мы приводим объект к строке, он превращается в '[object Object]'. Таким образом, мы говорим, что a['object Object'] = 123. Затем мы повторяем процедуру. 'c' - это другой объект, который мы неявно приводим к строке. Поэтому a['object Object'] = 456. Наконец, когда мы выводим a[b] в консоль, мы на самом деле выводим a['object Object']. Поэтому в консоль выводится 456."
    },
    {
      "id": "eec63f35-2f20-4cf8-9215-b12ddeae81a2",
      "code": "const foo = () => console.log(\"First\");\nconst bar = () => setTimeout(() => console.log(\"Second\"));\nconst baz = () => console.log(\"Third\");\n\nbar();\nfoo();\nbaz();",
      "answers": {
        "A": "A: First Second Third",
        "B": "B: First Third Second",
        "C": "C: Second First Third",
        "D": "D: Second Third First"
      },
      "right_answer": "B",
      "details": "Сначала мы вызываем функцию setTimeout. Однако, она выводится в консоль последней. Это происходит из-за того, что в браузерах у нас есть не только движок для запуска (выполнения) кода, но и WebAPI. WebAPI предоставляет нам функцию setTimeout и множество других возможностей. Например, DOM. После того, как колбек отправляется в WebAPI, функция setTimeout (но не колбек!) удаляется из стека вызовов (call stack). После этого вызывается foo, и 'First' выводится в консоль. foo удаляется из стека и вызывается baz. 'Third' выводится в консоль. WebAPI отправляет функцию обратного вызова в очередь событий (event loop). Event loop проверяет стек вызовов и очередь (макро)задач. Если стек является пустым, то в него помещается первый элемент из очереди. Вызывается bar и в консоль выводится 'Second'."
    },
    {
      "id": "6527fda3-2f18-429d-aac0-f2f884c944dc",
      "code": "<div onclick=\"console.log('div')\">\n    <p onclick=\"console.log('p')\">\n        Нажми на меня!\n    </p>\n</div>",
      "answers": {
        "A": "A: p div",
        "B": "B: div p",
        "C": "C: p",
        "D": "D: div"
      },
      "right_answer": "A",
      "details": "После клика по 'p' в консоль будет выведено 'p' и 'div'. Цикл события имеет три фазы: захват, цель и всплытие. По умолчанию обработчики событий выполняются на фазе всплытия (если не установлен useCapture: true). Всплытие идет от самого глубоко вложенного элемента до самого внешнего."
    },
    {
      "id": "d3a1abb8-6191-44b0-8551-a1330150c3d4",
      "code": "const person = { name: \"Lydia\" };\n\nfunction sayHi(age) {\n    console.log(`${this.name} is ${age}`);\n}\n\nsayHi.call(person, 21);\nsayHi.bind(person, 21);",
      "answers": {
        "A": "A: undefined is 21 Lydia is 21",
        "B": "B: function function",
        "C": "C: Lydia is 21 Lydia is 21",
        "D": "D: Lydia is 21 function"
      },
      "right_answer": "D",
      "details": "В обоих случаях мы передаем объект, на который будет указывать this. Но call() выполняется сразу, а bind() возвращает копию функции с привязанным контекстом. Ее следует вызывать отдельно или можно сделать так: sayHi.bind(person, 21)()."
    },
    {
      "id": "18ed116c-e91d-4f93-84f3-ab095c15a41b",
      "code": "function sayHi() {\n    return (() => 0)();\n}\n\nconsole.log(typeof sayHi());",
      "answers": {
        "A": "A: 'object'",
        "B": "B: 'number'",
        "C": "C: 'function'",
        "D": "D: 'undefined'"
      },
      "right_answer": "B",
      "details": "Функция sayHi возвращает значение немедленно вызываемого функционального выражения (IIFE). Результатом является 0 типа number. Для информации: в JS имеется 8 встроенных типов данных: null, undefined, boolean, number, string, object, symbol и bigint. function не является отдельным типом, функции - это объекты."
    },
    {
      "id": "3f1504d2-8092-48e0-9ff3-5857cd923f54",
      "code": "console.log(typeof typeof 1);",
      "answers": {
        "A": "A: 'number'",
        "B": "B: 'string'",
        "C": "C: 'object'",
        "D": "D: 'undefined'"
      },
      "right_answer": "B",
      "details": "typeof 1 возвращает 'number'. typeof 'number' возвращает 'string'."
    },
    {
      "id": "d23a6bc6-671e-4018-a161-73e7ce20b5d2",
      "code": "const numbers = [1, 2, 3];\nnumbers[10] = 11;\nconsole.log(numbers);",
      "answers": {
        "A": "A: [1, 2, 3, 7 x null, 11]",
        "B": "B: [1, 2, 3, 11]",
        "C": "C: [1, 2, 3, 7 x empty, 11]",
        "D": "D: SyntaxError"
      },
      "right_answer": "C",
      "details": "Когда в массив добавляется значение, которое выходит за пределы длины массива, JavaScript создает 'пустые ячейки'. На самом деле они имеют значения undefined, но в консоль выводятся как [1, 2, 3, 7 x empty, 11] (в браузере, зависит от среды выполнения кода)."
    },
    {
      "id": "94a8bc37-7e7e-49c1-a22d-3d5310c840b4",
      "code": "(() => {\n    let x, y;\n    try {\n        throw new Error();\n    } catch (x) {\n        (x = 1), (y = 2);\n        console.log(x);\n    }\n    console.log(x);\n    console.log(y);\n})();",
      "answers": {
        "A": "A: 1 undefined 2",
        "B": "B: undefined undefined undefined",
        "C": "C: 1 1 2",
        "D": "D: 1 undefined undefined"
      },
      "right_answer": "A",
      "details": "Блок catch получает аргумент 'x'. Это не тот 'x', который объявлен перед try. Затем мы присваиваем этому аргументу значение 1 и присваиваем значение переменной 'y'. После этого выводим в консоль значение 'x', т.е. 1. За пределами catch 'x' все еще имеет значение undefined, а y = 2. Когда мы вызываем console.log(x) за пределами catch, возвращается undefined, а console.log(y) = 2."
    },
    {
      "id": "cd6193ec-8209-49ff-abde-54055da0744f",
      "code": "const result =\n    [[0, 1], [2, 3]].reduce(\n        (acc, cur) => {\n            return acc.concat(cur);\n        },\n        [1, 2]\n    );\n\nconsole.log(result);",
      "answers": {
        "A": "A: [0, 1, 2, 3, 1, 2]",
        "B": "B: [6, 1, 2]",
        "C": "C: [1, 2, 0, 1, 2, 3]",
        "D": "D: [1, 2, 6]"
      },
      "right_answer": "C",
      "details": "[1, 2] - начальное значение переменной acc. После первого прохода acc равняется [1, 2], а cur - [0, 1]. После конкатенации acc равняется [1, 2, 0, 1], а cur - [2, 3]. После их объединения мы получаем [1, 2, 0, 1, 2, 3]."
    },
    {
      "id": "c5ece4b5-a46c-4b15-b99b-f702a2dfd332",
      "code": "console.log(!!null);\nconsole.log(!!\"\");\nconsole.log(!!1);",
      "answers": {
        "A": "A: false true false",
        "B": "B: false false true",
        "C": "C: false true true",
        "D": "D: true true false"
      },
      "right_answer": "B",
      "details": "null - false. !null возвращает true. !true возвращает false.<br> '' - false. !'' возвращает true. !true возвращает false. 1 - true. !1 возвращает false. !false возвращает true."
    },
    {
      "id": "c5b07fc1-a000-4b39-84ab-36e71a571c2d",
      "code": "console.log([...\"Lydia\"]);",
      "answers": {
        "A": "A: ['L', 'y', 'd', 'i', 'a']",
        "B": "B: ['Lydia']",
        "C": "C: [[], 'Lydia']",
        "D": "D: [['L', 'y', 'd', 'i', 'a']]"
      },
      "right_answer": "A",
      "details": "Строка является итерируемой сущностью. Оператор распространения (spread) ... преобразует строку в массив, состоящий из символов этой строки."
    },
    {
      "id": "a6449244-1ed2-41c3-b561-660a3324e22b",
      "code": "function* generator(i) {\n    yield i;\n    yield i * 2;\n}\n\nconst gen = generator(10);\n\nconsole.log(gen.next().value);\nconsole.log(gen.next().value);",
      "answers": {
        "A": "A: [0, 10], [10, 20]",
        "B": "B: 20, 20",
        "C": "C: 10, 20",
        "D": "D: 0, 10 and 10, 20"
      },
      "right_answer": "C",
      "details": "Выполнение обычных функций не может быть остановлено после их запуска. Однако, генераторы можно останавливать в процессе выполнения, а затем продолжать с места остановки. Каждый раз, когда в функции-генераторе встречается ключевое слово yield, функция возвращает значение, указанное после него. Обратите внимание, что в генераторе вместо return используется yield.<br> Сначала мы инициализируем генератор с i равным 10. Мы вызываем генератор, используя метод next(). Когда мы в первый раз вызываем генератор, i равно 10. Движок JavaScript встречает первое ключевое слово yield, возвращая значение i. После этого выполнение функции приостанавливается, и 10 выводится в консоль. Затем мы снова вызываем функцию посредством next(). Она запускается с того места, где остановилась, с i = 10. Компилятор встречает следующее ключевое слово yield и возвращает i * 2. i равно 10, поэтому возвращается 10 * 2, т.е. 20."
    },
    {
      "id": "c9e6ad6e-0018-4b7c-9016-d68ad6324a55",
      "code": "const firstPromise = new Promise((res, rej) => {\n    setTimeout(res, 500, \"один\");\n});\n\nconst secondPromise = new Promise((res, rej) => {\n    setTimeout(res, 100, \"два\");\n});\n\nPromise.race([firstPromise, secondPromise]).then(res => console.log(res));",
      "answers": {
        "A": "A: 'один'",
        "B": "B: 'два'",
        "C": "C: 'два' 'один'",
        "D": "D: 'один' 'два'"
      },
      "right_answer": "B",
      "details": "Когда мы передаем несколько промисов методу Promise.race(), он возвращает первый разрешенный/отклоненный промис. В метод setTimeout мы передаем таймер: 500 мс для первого промиса и 100 мс для второго. Это означает, что secondPromise разрешается первым со значением 'два'. res имеет значение 'два', которое и выводиться в консоль."
    },
    {
      "id": "c6b4d165-f2a4-4fd7-9433-9d00caede36c",
      "code": "let person = { name: \"Lydia\" };\nconst members = [person];\nperson = null;\n\nconsole.log(members);",
      "answers": {
        "A": "A: null",
        "B": "B: [null]",
        "C": "C: [{}]",
        "D": "D: [{ name: 'Lydia' }]"
      },
      "right_answer": "D",
      "details": "Сначала мы объявляем переменную person со значением объекта со свойством name. Затем мы объявляем переменную members. Мы делаем первый элемент этого массива равным person. Объекты взаимодействуют посредством ссылок при установке их равными друг другу. Когда вы назначаете ссылку из одной переменной в другую, вы создаете копию этой ссылки (обратите внимание, что у этих переменных не одинаковые ссылки). Затем мы присваиваем переменной person значение null. Мы изменили только значение person, а не первый элемент массива, поскольку этот элемент имеет другую (скопированную) ссылку на объект. Первый элемент в members по-прежнему содержит ссылку на исходный объект. Когда мы выводим в консоль массив members, первый элемент содержит значение объекта, который и выводится в консоль."
    },
    {
      "id": "8b76760f-88b5-459a-a416-5c466544402c",
      "code": "const person = {\n    name: \"Lydia\",\n    age: 21\n};\n\nfor (const item in person) {\n    console.log(item);\n}",
      "answers": {
        "A": "A: { name: 'Lydia' }, { age: 21 }",
        "B": "B: 'name', 'age'",
        "C": "C: 'Lydia', 21",
        "D": "D: ['name', 'Lydia'], ['age', 21]"
      },
      "right_answer": "B",
      "details": "С помощью цикла for-in мы перебираем ключи объекта, в данном случае name и age. Под катом ключи объекта являются строками (если они не являются Symbol). В каждом цикле мы устанавливаем значение item равным текущему ключу, по которому он перебирается. Сначала item равен name, и выводится в консоль. Затем item равен age, что также выводится в консоль."
    },
    {
      "id": "2bc42042-820b-4174-8146-9c25694d7e7a",
      "code": "console.log(3 + 4 + \"5\");",
      "answers": {
        "A": "A: '345'",
        "B": "B: '75'",
        "C": "C: 12",
        "D": "D: '12'"
      },
      "right_answer": "B",
      "details": "Ассоциативность операторов - это порядок оценивания выражения компилятором, слева направо или справа налево. Это происходит только в том случае, если все операторы имеют одинаковый приоритет. У нас есть только один тип оператора: +. Ассоциативность - слева направо. 3 + 4 оценивается первым. Это приводит к числу 7. 7 + '5' приводит к '75' из-за неявного приведения типов. JavaScript преобразует число 7 в строку. Мы можем объединить (конкатенировать) две строки, используя оператор +. '7' + '5' = '75'."
    },
    {
      "id": "c17f9160-e7bb-4157-96dd-b813dc9c9987",
      "code": "const num = parseInt(\"7*6\", 10);\n\nconsole.log(num);",
      "answers": {
        "A": "A: 42",
        "B": "B: '42'",
        "C": "C: 7",
        "D": "D: NaN"
      },
      "right_answer": "C",
      "details": "ParseInt проверяет, являются ли символы в строке допустимыми с точки зрения используемой системы счисления (второй аргумент). Как только он встречает недопустимый символ, синтаксический анализ строки прекращается и последующие символы игнорируются. * не является допустимым числом. Поэтому parseInt прекращает разбор строки и возвращает 7."
    },
    {
      "id": "4cf7760c-de29-4b61-9ab1-6d1dad02cc16",
      "code": "const result =\n    [1, 2, 3].map(num => {\n        if (typeof num === \"number\") return;\n        return num * 2;\n    });\n\nconsole.log(result)",
      "answers": {
        "A": "A: []",
        "B": "B: [null, null, null]",
        "C": "C: [undefined, undefined, undefined]",
        "D": "D: [ 3 x empty ]"
      },
      "right_answer": "C",
      "details": "Метод map возвращает новый массив с обработанными каким-либо образом с помощью функции обратного вызова элементами исходного массива. В данном случае элементы исходного массива являются числами, поэтому условие if typeof num === 'number' является истинным. После этого выполнение функции останавливается, в новый массив попадает значение num, равное undefined."
    },
    {
      "id": "d1e9f6f9-65fb-4b79-adcd-5bf81ca2289a",
      "code": "function getInfo(member, year) {\n    member.name = \"Lydia\";\n    year = 1998;\n}\n\nconst person = { name: \"Sarah\" };\nconst birthYear = \"1997\";\n\ngetInfo(person, birthYear);\n\nconsole.log(person, birthYear);",
      "answers": {
        "A": "A: { name: 'Lydia' }, '1997'",
        "B": "B: { name: 'Sarah' }, '1998'",
        "C": "C: { name: 'Lydia' }, '1998'",
        "D": "D: { name: 'Sarah' }, '1997'"
      },
      "right_answer": "A",
      "details": "Аргументы передаются по значению. Если значение аргумента является объектом, то он передается по ссылке. birthYear передается по значению, поскольку это строка, а не объект. Когда мы передаем аргументы по значению, создается копия этого значения. Переменная birthYear ссылается на значение '1997'. Аргумент year также ссылается на значение '1997', но это не то значение, на которое ссылается birthYear. Когда мы обновляем значение year, устанавливая year равным '1998', мы обновляем только значение year. birthYear по-прежнему равняется '1997'. Значение person является объектом. Аргумент member имеет скопированную ссылку на этот объект. Когда мы изменяем свойство объекта, на который ссылается member, значение person также меняется, поскольку они ссылаются на один и тот же объект. Свойство name объекта person становится равным значению 'Lydia'."
    },
    {
      "id": "b789aba6-7f12-4d2b-9889-902561c82741",
      "code": "function greeting() {\n    throw \"Hello world!\";\n}\n\nfunction sayHi() {\n    try {\n        const data = greeting();\n        console.log(\"Работает!\", data);\n    } catch (e) {\n        console.log(\"Ошибка:\", e);\n    }\n}\n\nsayHi();",
      "answers": {
        "A": "A: Работает! Hello world!",
        "B": "B: Ошибка: undefined",
        "C": "C: SyntaxError: can only throw Error objects",
        "D": "D: Ошибка: Hello world!"
      },
      "right_answer": "D",
      "details": "С помощью оператора throw мы можем создавать собственные ошибки. Мы можем генерировать пользовательские исключения. Исключением может быть строка, число, логическое значение или объект. В данном случае исключением является строка 'Hello world'. С помощью оператора catch мы можем указать, что делать, если в блоке try возникнет ошибка. Исключение - 'Hello world'. 'e' равняется этой строке. Это приводит к 'Ошибка: Hello world'."
    },
    {
      "id": "4ef76b6a-d29f-4708-aa36-b4b3fdddebcb",
      "code": "function Car() {\n    this.make = \"Lamborghini\";\n    return { make: \"Maserati\" };\n}\n\nconst myCar = new Car();\nconsole.log(myCar.make);",
      "answers": {
        "A": "A: 'Lamborghini'",
        "B": "B: 'Maserati'",
        "C": "C: ReferenceError",
        "D": "D: TypeError"
      },
      "right_answer": "B",
      "details": "Когда возвращается свойство, его значение равняется возвращаемому значению, а не значению, установленному в конструкторе функции. Мы возвращаем строку 'Maserati', поэтому значением myCar.make является 'Maserati'."
    },
    {
      "id": "a68a2fed-89e8-4919-b290-3430d6d28f60",
      "code": "(() => {\n    let x = (y = 10);\n})();\n\nconsole.log(typeof x);\nconsole.log(typeof y);",
      "answers": {
        "A": "A: 'undefined', 'number'",
        "B": "B: 'number', 'number'",
        "C": "C: 'object', 'number'",
        "D": "D: 'number', 'undefined'"
      },
      "right_answer": "A",
      "details": "let x = y = 10 на самом деле является сокращением для:"
    },
    {
      "id": "73f9d0e3-db6d-4a09-9f8c-fe201848b697",
      "code": "class Dog {\n    constructor(name) {\n      this.name = name;\n    }\n}\n\nDog.prototype.bark = function() {\n    console.log(`Woof I am ${this.name}`);\n};\n\nconst pet = new Dog(\"Mara\");\n\npet.bark();\n\ndelete Dog.prototype.bark;\n\npet.bark();",
      "answers": {
        "A": "A: 'Woof I am Mara', TypeError",
        "B": "B: 'Woof I am Mara', 'Woof I am Mara'",
        "C": "C: 'Woof I am Mara', undefined",
        "D": "D: TypeError, TypeError"
      },
      "right_answer": "A",
      "details": "Мы можем удалять свойства объектов с помощью ключевого слова delete, включая свойства прототипов. Удаленное свойство прототипа становится недоступным в цепочке прототипов. Другими словами, функция bark больше не доступна в прототипе после delete Dog.prototype.bark, однако мы пытаемся получить к ней доступ. Когда мы пытаемся вызвать нечто, не являющееся функцией, выбрасывается исключение TypeError. В данном случае TypeError: pet.bark is not a function, поскольку значением pet.bark является undefined."
    },
    {
      "id": "1c50b699-31d2-4d7c-bd25-d3525a7db68b",
      "code": "const set = new Set([1, 1, 2, 3, 4]);\n\nconsole.log(set);",
      "answers": {
        "A": "A: [1, 1, 2, 3, 4]",
        "B": "B: [1, 2, 3, 4]",
        "C": "C: {1, 1, 2, 3, 4}",
        "D": "D: {1, 2, 3, 4}"
      },
      "right_answer": "D",
      "details": "Объект Set является коллекцией уникальных значений. Мы передаем массив [1, 1, 2, 3, 4] с повторяющимся значением 1. Поскольку в наборе не может быть двух одинаковых значений, одно из них удаляется. Это приводит к {1, 2, 3, 4}."
    },
    {
      "id": "a6a74d8a-eef8-4e12-b256-de4698504cb5",
      "code": "// counter.js\nlet counter = 10;\nexport default counter;\n\n// index.js\nimport myCounter from \"./counter\";\n\nmyCounter += 1;\n\nconsole.log(myCounter);",
      "answers": {
        "A": "A: 10",
        "B": "B: 11",
        "C": "C: Error",
        "D": "D: NaN"
      },
      "right_answer": "C",
      "details": "Импортированный модуль доступен только для чтения: мы не можем его изменить. Это можно сделать только при экпорте. Когда мы пытаемся увеличить значение myCounter, возникает ошибка: myCounter доступен только для чтения и не может быть изменен."
    },
    {
      "id": "1530c4f1-75dd-4c97-bb36-361cc065840b",
      "code": "const name = \"Lydia\";\nage = 21;\n\nconsole.log(delete name);\nconsole.log(delete age);",
      "answers": {
        "A": "A: false, true",
        "B": "B: 'Lydia', 21",
        "C": "C: true, true",
        "D": "D: undefined, undefined"
      },
      "right_answer": "A",
      "details": "Оператор delete возвращает логическое значение: true при успешном удалении, иначе false. Однако переменные, объявленные с помощью ключевого слова var, const или let, не могут быть удалены с помощью delete. Переменная name была объявлена ​​с помощью ключевого слова const, поэтому возвращается false. Когда мы устанавливаем age равным 21, мы фактически добавляем свойство с именем age к глобальному объекту (window.age в браузере, global.age в Node.js). Свойства объектов, включая глобальный, удалять можно, поэтому delete age возвращает true."
    },
    {
      "id": "9b8d6856-eccd-486c-9c77-2d3cc91887d1",
      "code": "const numbers = [1, 2, 3, 4, 5];\nconst [y] = numbers;\n\nconsole.log(y);",
      "answers": {
        "A": "A: [[1, 2, 3, 4, 5]]",
        "B": "B: [1, 2, 3, 4, 5]",
        "C": "C: 1",
        "D": "D: [1]"
      },
      "right_answer": "C",
      "details": "Мы можем распаковывать элементы из массивов или свойства из объектов путем деструктуризации. Например:<br> [a, b] = [1, 2];<br> Значение a теперь равно 1, а значение b - 2. Что мы на самом деле сделали в примере, так это:<br> [y] = [1, 2, 3, 4, 5];<br> Это означает, что значение 'y' равняется первому значению массива, которое является числом 1. Поэтому в консоль выводится 1."
    },
    {
      "id": "0aeb7773-b79a-4b3b-9a37-ac393213ab09",
      "code": "const user = { name: \"Lydia\", age: 21 };\nconst admin = { admin: true, ...user };\n\nconsole.log(admin);",
      "answers": {
        "A": "A: { admin: true, user: { name: 'Lydia', age: 21 } }",
        "B": "B: { admin: true, name: 'Lydia', age: 21 }",
        "C": "C: { admin: true, user: ['Lydia', 21] }",
        "D": "D: { admin: true }"
      },
      "right_answer": "B",
      "details": "С помощью оператора распространения (spread) ... можно объединять объекты. Это позволяет создавать копии пар ключ/значение одного объекта и добавлять их в другой объект. В данном случае мы создаем копию объекта user и добавляем ее в объект admin. Объект admin содержит скопированные пары ключ/значение, что приводит к {admin: true, name: 'Lydia', age: 21}."
    },
    {
      "id": "74ce800c-f1f1-4166-91d2-1e18e924423a",
      "code": "const person = { name: \"Lydia\" };\n\nObject.defineProperty(person, \"age\", { value: 21 });\n\nconsole.log(person);\nconsole.log(Object.keys(person));",
      "answers": {
        "A": "A: { name: 'Lydia', age: 21 }, ['name', 'age']",
        "B": "B: { name: 'Lydia', age: 21 }, ['name']",
        "C": "C: { name: 'Lydia'}, ['name', 'age']",
        "D": "D: { name: 'Lydia'}, ['age']"
      },
      "right_answer": "B",
      "details": "С помощью метода defineProperty() мы добавляем новые свойства к объекту или изменяем существующие. Когда мы добавляем свойство к объекту с помощью defineProperty(), они по умолчанию являются не перечисляемыми. Метод Object.keys() возвращает все перечисляемые свойства объекта, в данном случае только 'name'. Свойства, добавленные с помощью defineProperty(), по умолчанию также иммутабельны (неизменяемы). Это поведение можно переопределить, используя свойства writable, configurable и enumerable. Таким образом, метод defineProperty() дает нам гораздо больший контроль над свойствами, добавляемыми к объекту."
    },
    {
      "id": "6bab959f-d210-4f66-b633-6f6ede02fd2a",
      "code": "const settings = {\n    username: \"lydiahallie\",\n    level: 19,\n    health: 90\n};\n\nconst data = JSON.stringify(settings, [\"level\", \"health\"]);\nconsole.log(data);",
      "answers": {
        "A": "A: '{'level': 19, 'health': 90}'",
        "B": "B: '{'username': 'lydiahallie'}'",
        "C": "C: '['level', 'health']'",
        "D": "D: '{'username': 'lydiahallie', 'level':19, 'health':90}'"
      },
      "right_answer": "A",
      "details": "Второй аргумент JSON.stringify() - это replacer (заменитель). Заменитель может быть либо функцией, либо массивом, и позволяет контролировать, что и как должно быть преобразовано в значения. Если заменитель является массивом, только свойства, указанные в нем, будут добавлены в JSON-строку. В данном случае в строку включаются только свойства 'level' и 'health', 'username' исключается. data равняется '{'level': 19, 'health': 90}'. Если заменитель является функцией, она вызывается для каждого свойства объекта. Значение функции будет значением свойства при добавлении в строку. Если значением свойства является undefined, такое свойство исключается из строки."
    },
    {
      "id": "e6cc443f-4b87-4120-96dc-c93e38b7537a",
      "code": "let num = 10;\n\nconst increaseNumber = () => num++;\nconst increasePassedNumber = number => number++;\n\nconst num1 = increaseNumber();\nconst num2 = increasePassedNumber(num1);\n\nconsole.log(num1);\nconsole.log(num2);",
      "answers": {
        "A": "A: 10, 10",
        "B": "B: 10, 11",
        "C": "C: 11, 11",
        "D": "D: 11, 12"
      },
      "right_answer": "A",
      "details": "Постфиксный оператор ++ сначала возвращает значение операнда, затем увеличивает его. Значение num1 равняется 10, так как функция сначала возвращает значение num, и только после этого увеличивает его на 1. num2 - это 10, так как мы передали num1 в increasePassedNumber(). number равняется 10. Снова ++ возвращает значение операнда, а затем увеличивает его. number = 10, поэтому num2 также равняется 10."
    },
    {
      "id": "f5bae250-4303-4020-aae5-073727cf309c",
      "code": "const value = { number: 10 };\n\nconst multiply = (x = { ...value }) => {\n  console.log((x.number *= 2));\n};\n\nmultiply();\nmultiply();\nmultiply(value);\nmultiply(value);",
      "answers": {
        "A": "A: 20, 40, 80, 160",
        "B": "B: 20, 40, 20, 40",
        "C": "C: 20, 20, 20, 40",
        "D": "D: NaN, NaN, 20, 40"
      },
      "right_answer": "C",
      "details": "В ES6 мы можем инициализировать параметры со значениями по умолчанию. Параметр будет иметь значение по умолчанию, если другое значение не было передано функции, или если значением параметра является undefined. В данном случае мы распространяем свойства объекта value на новый объект, поэтому значение 'x' по умолчанию равняется {number: 10}. Аргумент по умолчанию реализуется в момент вызова функции. Каждый раз, когда мы вызываем функцию, создается новый объект. Мы вызываем функцию multiply() первые два раза, не передавая значений: 'x' имеет значение {number: 10}. Затем мы умножаем это значение на 2, получаем 20. В третий раз, когда мы вызываем multiply(), мы передаем ей аргумент - объект value. Оператор *= на самом деле является сокращением для x.number = x.number * 2: мы меняем значение x.number, теперь оно равняется 20. В четвертый раз мы снова передаем multiply() объект value. x.number = 20, поэтому x.number *= 2 равняется 40."
    },
    {
      "id": "9c68dbcb-7f85-40e9-89a8-1f8507f532e6",
      "code": "[1, 2, 3, 4].reduce((x, y) => console.log(x, y));",
      "answers": {
        "A": "A: 1 2, 3 3 и 6 4",
        "B": "B: 1 2, 2 3 и 3 4",
        "C": "C: 1 undefined, 2 undefined, 3 undefined и 4 undefined",
        "D": "D: 1 2, undefined 3 и undefined 4"
      },
      "right_answer": "D",
      "details": "Первый агрумент метода reduce - аккумулятор, в данном случае 'x'. Второй аргумент - текущее значение, 'y'. С помощью reduce мы выполняем функцию обратного вызова для каждого элемента массива, что может привести к единственному значению. В примере мы не возвращаем значений, а просто регистрируем значения аккумулятора и текущее значение. Значение аккумулятора равняется ранее возвращенному значению колбека. Если вы не передадите необязательный аргумент initialValue методу reduce, аккумулятор будет равен первому элементу при первом вызове. При первом вызове аккумулятор (x) = 1, а текущее значение (y) = 2. Мы не выходим из функции, а регистрируем аккумулятор и текущее значение: 1 и 2 регистрируются. Если вы не возвращаете значение из функции, она возвращает undefined. При следующем вызове аккумулятор = undefined, а текущее значение = 3. undefined и 3 регистрируются. При четвертом вызове мы снова не возвращаем значение из функции. Аккумулятор = undefined, а текущее значение = 4: undefined и 4 выводятся в консоль."
    },
    {
      "id": "56cf6369-3c08-4bb1-8af4-43baaaf5efe6",
      "code": "// index.js\nconsole.log('running index.js');\nimport { sum } from './sum.js';\nconsole.log(sum(1, 2));\n\n// sum.js\nconsole.log('running sum.js');\nexport const sum = (a, b) => a + b;",
      "answers": {
        "A": "A: running index.js, running sum.js, 3",
        "B": "B: running sum.js, running index.js, 3",
        "C": "C: running sum.js, 3, running index.js",
        "D": "D: running index.js, undefined, running sum.js"
      },
      "right_answer": "B",
      "details": "При импорте модулей с помощью ключевого слова import, они являются прераспарсенными (предварительно разобранными). Это означает, что модули запускаются первыми, а код в файле, который импортирует модуль, выполняется позже. В этом разница между require() в CommonJS и import. С помощью require() мы можем загружать зависимости динамически во время выполнения кода. При использовании require() вместо import в консоль будет выведено running index.js, running sum.js, 3."
    },
    {
      "id": "b4ef0757-a04d-4893-aa29-4adc0fce807d",
      "code": "console.log(Number(2) === Number(2))\nconsole.log(Boolean(false) === Boolean(false))\nconsole.log(Symbol('foo') === Symbol('foo'))",
      "answers": {
        "A": "A: true, true, false",
        "B": "B: false, true, false",
        "C": "C: true, false, true",
        "D": "D: true, true, true"
      },
      "right_answer": "A",
      "details": "Каждый Symbol уникален. Цель аргумента, переданного Symbol, состоит в том, чтобы дать Symbol описание. Значение Symbol не зависит от переданного аргумента. Когда мы проверяем равенство, мы создаем два разных Symbol: первый Symbol('foo') и второй Symbol('foo'). Эти значения уникальны и не равны друг другу, Symbol('foo') === Symbol('foo') возвращает false."
    },
    {
      "id": "a2d51820-0e75-42d6-ac50-bb473df972b7",
      "code": "const name = \"Lydia Hallie\"\nconsole.log(name.padStart(13))\nconsole.log(name.padStart(2))",
      "answers": {
        "A": "A: 'Lydia Hallie', 'Lydia Hallie'",
        "B": "B: ' Lydia Hallie', ' Lydia Hallie' ('[13x whitespace]Lydia Hallie', '[2x whitespace]Lydia Hallie')",
        "C": "C: ' Lydia Hallie', 'Lydia Hallie' ('[1x whitespace]Lydia Hallie', 'Lydia Hallie')",
        "D": "D: 'Lydia Hallie', 'Lyd',"
      },
      "right_answer": "C",
      "details": "С помощью метода padStart мы добавляем отступы в начало строки. Значение, передаваемое этому методу, представляет собой общую длину строки вместе с отступом. Строка 'Lydia Hallie' имеет длину равную 12. name.padStart(13) вставляет 1 пробел в начало строки, потому что 12 + 1 равно 13. Если аргумент, переданный методу padStart, меньше длины строки, заполнение не выполняется."
    },
    {
      "id": "83ac2c38-8e5b-4d57-b84d-886e9553d9a7",
      "code": "console.log(\"📱\" + \"💻\");",
      "answers": {
        "A": "A: '📱💻'",
        "B": "B: 257548",
        "C": "C: Строка, содержащая кодовые обозначения",
        "D": "D: Error"
      },
      "right_answer": "A",
      "details": "С помощью оператора + мы можем объединять строки (это называется конкатенацией). В данном случае мы объединяем строку '📱' со строкой '💻', что приводит к '📱💻'."
    },
    {
      "id": "b1d504a5-ab39-4dd1-a953-3c73c224c582",
      "code": "function* startGame() {\n    const answer = yield \"Ты любишь JavaScript?\";\n    if (answer !== \"Да\") {\n        return \"Как интересно... В таком случае что ты здесь делаешь?\";\n    }\n    return \"JavaScript тоже тебя любит ❤️\";\n}\n\nconst game = startGame();\nconsole.log(/* 1 */); // Ты любишь JavaScript?\nconsole.log(/* 2 */); // JavaScript тоже тебя любит ❤️",
      "answers": {
        "A": "A: game.next('Да').value и game.next().value",
        "B": "B: game.next.value('Да') и game.next.value()",
        "C": "C: game.next().value и game.next('Да').value",
        "D": "D: game.next.value() и game.next.value('Да')"
      },
      "right_answer": "C",
      "details": "Функция-генератор 'приостанавливает' выполнение, когда встречает ключевое слово yield. Во-первых, мы должны позволить функции выдать строку 'Ты любишь JavaScript?', что можно сделать, вызвав game.next().value. Код выполняется последовательно до тех пор, пока не встречается ключевое слово yield. В первой строке функции есть ключевое слово yield: выполнение останавливается с первым результатом. Это означает, что переменная answer еще не определена. Когда мы вызываем game.next('Да').value, предыдущий yield заменяется значением параметров, переданных функции next(), в данном случае 'Да'. Значение переменной answer теперь равняется 'Да'. Условие if возвращает false, и 'JavaScript тоже тебя любит ❤️' выводится в консоль."
    },
    {
      "id": "26d08188-0d9f-426b-b39f-13584ad5cbd0",
      "code": "console.log(String.raw`Hello\nworld`);",
      "answers": {
        "A": "A: Hello world!",
        "B": "B: Hello (на следующей строке) world",
        "C": "C: Hello world",
        "D": "D: Hello (на следующей строке) world"
      },
      "right_answer": "C",
      "details": "String.raw() возвращает строку, в которой обратные последовательности ( , , и т.д.) игнорируются. Обратная косая черта может стать проблемой, например:<br> const path = `C:DocumentsProjects able.html` Это приведет к:<br> 'C:DocumentsProjects able.html'<br> С String.raw() управляющие символы будут проигнорированы:<br> C:DocumentsProjects able.html"
    },
    {
      "id": "0137d532-1d84-4225-8132-959cd4c949fa",
      "code": "async function getData() {\n    return await Promise.resolve(\"Я сделал это!\");\n}\n\nconst data = getData();\nconsole.log(data);",
      "answers": {
        "A": "A: 'Я сделал это!'",
        "B": "B: Promise {: 'Я сделал это!'}",
        "C": "C: Promise {}",
        "D": "D: undefined"
      },
      "right_answer": "C",
      "details": "Асинхронная функция возвращает промис. await ожидает разрешения промиса: промис возвращается, когда мы вызываем getData(), чтобы установить data равным ему. Если бы мы хотели получить доступ к разрешенному значению 'Я сделал это!', мы могли бы использовать метод .then() для data: data.then(res =&gt; console.log(res)). Тогда бы в консоль было выведено 'Я сделал это!'"
    },
    {
      "id": "efb0b631-4705-4ef5-a095-82bd958c38fe",
      "code": "function addToList(item, list) {\n    return list.push(item);\n}\n\nconst result = addToList(\"apple\", [\"banana\"]);\nconsole.log(result);",
      "answers": {
        "A": "A: ['apple', 'banana']",
        "B": "B: 2",
        "C": "C: true",
        "D": "D: undefined"
      },
      "right_answer": "B",
      "details": "Метод push возвращает длину нового массива. Ранее массив содержал только один элемент (строку 'banana') и имел длину 1. После добавления в массив строки 'apple', длина массива увеличивается до 2. Это значение возвращается из функции addToList(). Метод push изменяет исходный массив. Если мы хотим вернуть массив, а не его длину, необходимо вернуть list после добавления item."
    },
    {
      "id": "8e7ac8f1-5c28-4faf-afae-8d8d47f86dee",
      "code": "const box = { x: 10, y: 20 };\n\nObject.freeze(box);\n\nconst shape = box;\nshape.x = 100;\n\nconsole.log(shape);",
      "answers": {
        "A": "A: { x: 100, y: 20 }",
        "B": "B: { x: 10, y: 20 }",
        "C": "C: { x: 100 }",
        "D": "D: ReferenceError"
      },
      "right_answer": "B",
      "details": "Object.freeze делает невозможным добавление, удаление или изменение свойств объекта (если только значение свойства не является другим объектом). Когда мы создаем переменную shape и устанавливаем ее равной замороженному объекту box, shape ссылается на этот объект. Вы можете проверить, заморожен ли объект, используя Object.isFrozen(). В даном случае Object.isFrozen(shape) возвращает true, поскольку переменная shape ссылается на замороженный объект. Поскольку shape заморожен, а значение 'x' не является объектом, мы не можем менять свойство 'x'. 'x' по-прежнему равняется 10, и {x: 10, y: 20} выводится в консоль."
    },
    {
      "id": "9118b1f7-20dd-4770-b04f-1ecef9dcbcf6",
      "code": "const { name: myName } = { name: \"Lydia\" };\n\nconsole.log(name);",
      "answers": {
        "A": "A: 'Lydia'",
        "B": "B: 'myName'",
        "C": "C: undefined",
        "D": "D: ReferenceError"
      },
      "right_answer": "D",
      "details": "Когда мы распаковываем свойство name из правого объекта, мы присваиваем значение 'Lydia' переменной myName. С помощью {name: myName} мы сообщаем JavaScript, что хотим создать новую переменную с именем myName и со значением свойства name из правой части. Поскольку мы пытаемся вывести в консоль name, переменную, которая не определена, выбрасывается исключение ReferenceError."
    },
    {
      "id": "d4064bf5-ee14-4e5b-8326-106965367403",
      "code": "const add = () => {\n    const cache = {};\n    return num => {\n        if (num in cache) {\n            return `Из кэша! ${cache[num]}`;\n        } else {\n            const result = num + 10;\n            cache[num] = result;\n            return `Вычислено! ${result}`;\n        }\n    };\n};\n\nconst addFunction = add();\nconsole.log(addFunction(10));\nconsole.log(addFunction(10));\nconsole.log(addFunction(5 * 2));",
      "answers": {
        "A": "A: Вычислено! 20 Вычислено! 20 Вычислено! 20",
        "B": "B: Вычислено! 20 Из кэша! 20 Вычислено! 20",
        "C": "C: Вычислено! 20 Из кэша! 20 Из кэша! 20",
        "D": "D: Вычислено! 20 Из кэша! 20 Error"
      },
      "right_answer": "C",
      "details": "Функция add() является функцией запоминания (мемоизации). С помощью запоминания мы можем кэшировать результаты вызова функции, чтобы ускорить ее повторное выполнение. В данном случае мы создаем объект cache, в котором хранятся ранее возвращенные значения. Если мы повторно вызываем функцию addFunction() с тем же аргументом, она сначала проверяет, имеется ли соответствующее значение в кэше. Если значение имеется, оно возвращается, что экономит время на выполнение функции. Иначе, если значение в кэше отсутствует, оно вычисляется и сохраняется. Мы вызываем функцию addFunction() три раза с одним и тем же аргументом: при первом вызове значение функции, когда num = 10, еще не кэшировано. Условие if num in cache возвращает false, и выполняется блок else: Вычислено! 20 выводится в консоль, и результат добавляется в объект cache. cache теперь выглядит как {10: 20}. При повторном вызове значение для аргумента 10 возвращается из кэша. Условие if num in cache возвращает true, а 'Из кэша! 20' выводится в консоль. В третий раз мы передаем в функцию 5 * 2, что оценивается как 10. Объект cache содержит значение для аргумента 10. Условие if num in cache возвращает true, а 'Из кэша! 20' выводится в консоль."
    },
    {
      "id": "55a2927e-1b90-4784-bfd0-3e452dbde155",
      "code": "const myLifeSummedUp = [\"☕\", \"💻\", \"🍷\", \"🍫\"]\n\nfor (let item in myLifeSummedUp) {\n  console.log(item)\n}\n\nfor (let item of myLifeSummedUp) {\n  console.log(item)\n}",
      "answers": {
        "A": "A: 0 1 2 3 и '☕' '💻' '🍷' '🍫'",
        "B": "B: '☕' '💻' '🍷' '🍫' и '☕' '💻' '🍷' '🍫'",
        "C": "C: '☕' '💻' '🍷' '🍫' и 0 1 2 3",
        "D": "D: 0 1 2 3 и {0: '☕', 1: '💻', 2: '🍷', 3: '🍫'}"
      },
      "right_answer": "A",
      "details": "С помощью цикла for-in мы перебираем перечисляемые свойства. В массиве перечисляемые свойства являются 'ключами' элементов массива, которые фактически являются их индексами. Вы можете представить массив как: <br> {0: '☕', 1: '💻', 2: '🍷', 3: '🍫'} <br> где ключи - перечисляемые свойства. 0 1 2 3 выводится в консоль. С помощью for-of мы выполняем итерацию итераций. Массив является итеративным. Когда мы выполняем итерацию по массиву, переменная 'item' равна итерируемому элементу, '☕' '💻' '🍷' '🍫' выводится в консоль."
    },
    {
      "id": "190e5b0b-a126-417d-ac90-af9aca3c181a",
      "code": "const list = [1 + 2, 1 * 2, 1 / 2]\nconsole.log(list)",
      "answers": {
        "A": "A: ['1 + 2', '1 * 2', '1 / 2']",
        "B": "B: ['12', 2, 0.5]",
        "C": "C: [3, 2, 0.5]",
        "D": "D: [1, 1, 1]"
      },
      "right_answer": "C",
      "details": "Элементами массива могут быть любые типы данных. Числа, строки, объекты, другие массивы, null, логические значения, undefined и др., например, даты, функции и выражения. Элемент будет равен возвращаемому значению. 1 + 2 возвращает 3, 1 * 2 - 2, а 1 / 2 - 0.5."
    },
    {
      "id": "f4490949-c3b9-4b03-b67d-a5fe0f731e2d",
      "code": "function sayHi(name) {\n    return `Привет, ${name}`\n}\n\nconsole.log(sayHi())",
      "answers": {
        "A": "A: Привет,",
        "B": "B: Привет, undefined",
        "C": "C: Привет, null",
        "D": "D: ReferenceError"
      },
      "right_answer": "B",
      "details": "По умолчанию аргументы имеют значение undefined, если значение не было передано функции. В данном случае мы не передаем значения для аргумента name. name = undefined. В ES6 мы можем перезаписать undefined параметрами по умолчанию. Например: <br> function sayHi(name = 'Lydia') { ... } <br> В данном случае, если мы не передали значение или если мы передали undefined, name будет иметь значение Lydia."
    },
    {
      "id": "72150740-7801-4685-b2bb-e5dd4419c80c",
      "code": "var status = \"😎\"\n\nsetTimeout(() => {\n  const status = \"😍\"\n\n  const data = {\n    status: \"😉\",\n    getStatus() {\n      return this.status\n    }\n  }\n\n  console.log(data.getStatus())\n  console.log(data.getStatus.call(this))\n}, 0)",
      "answers": {
        "A": "A: '😉' и '😍'",
        "B": "B: '😉' и '😎'",
        "C": "C: '😍' и '😎'",
        "D": "D: '😎' и '😎'"
      },
      "right_answer": "B",
      "details": "Значение ключевого слова this зависит от того, где оно используется. В методе getStatus() this указывает на объект, которому принадлежит метод. Метод принадлежит объекту data, поэтому this относится к объекту data. Когда мы выводим в консоль this.status, выводится свойство status объекта data или '😉'. С помощью метода call мы можем изменить объект, на который ссылается this. В функциях ключевое слово this относится к объекту, которому принадлежит функция. Мы объявили функцию setTimeout для объекта global, поэтому в функции setTimeout ключевое слово this ссылается на объект global. В глобальном объекте есть переменная status со значением '😎'. В консоль выводится '😎'."
    },
    {
      "id": "a9648959-e281-489c-a9c8-06a700c62086",
      "code": "const person = {\n    name: \"Lydia\",\n    age: 21\n}\n\nlet city = person.city\ncity = \"Amsterdam\"\n\nconsole.log(person)",
      "answers": {
        "A": "A: { name: 'Lydia', age: 21 }",
        "B": "B: { name: 'Lydia', age: 21, city: 'Amsterdam' }",
        "C": "C: { name: 'Lydia', age: 21, city: undefined }",
        "D": "D: 'Amsterdam'"
      },
      "right_answer": "A",
      "details": "Мы устанавливаем переменную city равной значению свойства city объекта person. У этого объекта нет свойства city, поэтому переменная city имеет значение undefined. Обратите внимание, что мы не ссылаемся на person. Мы просто устанавливаем переменную city равной текущему значению свойства city объекта person. Затем мы устанавливаем city равным строке 'Amsterdam'. Это не меняет person."
    },
    {
      "id": "5652ac95-fb8d-4e7b-bffa-bdf8055f96e1",
      "code": "function checkAge(age) {\n    if (age < 18) {\n      const message = \"Вы слишком молоды.\"\n    } else {\n      const message = \"Вы достаточно взрослый!\"\n    }\n    return message\n}\n\nconsole.log(checkAge(21))",
      "answers": {
        "A": "A: 'Вы слишком молоды.'",
        "B": "B: 'Вы достаточно взрослый!'",
        "C": "C: ReferenceError",
        "D": "D: undefined"
      },
      "right_answer": "C",
      "details": "Переменные, объявленные с помощью ключевых слов const и let имеют блочную область видимости. Блок - это любой код между {}. В данном случае в фигурных скобках операторов if/else. Вы не можете ссылаться на переменную за пределами блока, в котором она объявлена, выбрасывается исключение ReferenceError."
    },
    {
      "id": "db7bb479-61d5-4a8d-b26a-add1403da9ea",
      "code": "function getName(name) {\n    const hasName = /* ? */\n}",
      "answers": {
        "A": "A: !!name",
        "B": "B: name",
        "C": "C: new Boolean(name)",
        "D": "D: name.length"
      },
      "right_answer": "A",
      "details": "С помощью !!name мы определяем, является ли значение name истинным. Если name = true, то !name возвращает false. А !false (это то, чем на самом деле является !!name) возвращает true. Устанавливая hasName равным name, мы устанавливаем hasName равным любому значению, которое передается функции getName(), а не логическому значению true. new Boolean(true) возвращает объектную обертку, а не само логическое значение. name.length возвращает длину переданного аргумента."
    },
    {
      "id": "28b049e2-6310-48e4-9054-c79e3d5065ba",
      "code": "console.log(\"Я хочу пиццу!\"[0])",
      "answers": {
        "A": "A: ''",
        "B": "B: 'Я'",
        "C": "C: SyntaxError",
        "D": "D: undefined"
      },
      "right_answer": "B",
      "details": "Чтобы получить символ по определенному индексу в строке, вы можете использовать скобочную нотацию. Первый символ в строке имеет индекс 0 и т.д. В данном случае мы хотим получить элемент с индексом 0, символ 'Я', который и выводится в консоль. Альтернативой является метод charAt."
    },
    {
      "id": "d5a681be-95f0-4d43-92d0-1c2afef02a7f",
      "code": "function sum(num1, num2 = num1) {\n    console.log(num1 + num2)\n}\n\nsum(10)",
      "answers": {
        "A": "A: NaN",
        "B": "B: 20",
        "C": "C: ReferenceError",
        "D": "D: undefined"
      },
      "right_answer": "B",
      "details": "Мы можем установить значение параметра по умолчанию равным другому параметру функции, если такой параметр был определен до параметра по умолчанию. Мы передаем значение 10 в функцию sum(). Если sum() принимает только один аргумент, значит, значение для num2 не передано, оно получает значение по умолчанию, т.е. 10. num1 + num2 возвращает 20. Если попытаться установить значение параметра по умолчанию равным параметру, который определяется позже, то возникнет ошибка."
    },
    {
      "id": "e6aaeca1-6fb8-4d48-9d9f-766a7229582e",
      "code": "// module.js\nexport default () => \"Hello world\"\nexport const name = \"Lydia\"\n\n// index.js\nimport * as data from \"./module\"\n\nconsole.log(data)",
      "answers": {
        "A": "A: { default: function default(), name: 'Lydia' }",
        "B": "B: { default: function default() }",
        "C": "C: { default: 'Hello world', name: 'Lydia' }",
        "D": "D: Глобальный объект module.js"
      },
      "right_answer": "A",
      "details": "С помощью import * as name мы импортируем все экспорты из файла module.js в файл index.js, создается новый объект data. В файле module.js имеется два экспорта: экспорт по умолчанию и именованный экспорт. Экспорт по умолчанию - это функция, которая возвращает строку 'Hello World', а именованный экспорт - это переменная name, которая имеет значение 'Lydia'. Объект data имеет свойство default для экспорта по умолчанию, другие свойства - именованные экспорты и соответствующие значения."
    },
    {
      "id": "1a60ef0a-70a3-4ad9-975f-179cf41dca59",
      "code": "class Person {\n    constructor(name) {\n      this.name = name\n    }\n}\n\nconst member = new Person(\"John\")\nconsole.log(typeof member)",
      "answers": {
        "A": "A: 'class'",
        "B": "B: 'function'",
        "C": "C: 'object'",
        "D": "D: 'string'"
      },
      "right_answer": "C",
      "details": "Классы являются синтаксическим сахаром для конструкторов функций. Эквивалентом класса Person в качестве конструктора функции будет:<br> function Person() { this.name = name }<br> Вызов конструктора функции с ключевым словом new приводит к созданию экземпляра Person. typeof member возвращает 'object'."
    },
    {
      "id": "f2857795-41e4-4293-8920-ab57c8d45c9a",
      "code": "let newList = [1, 2, 3].push(4)\n\nconsole.log(newList.push(5))",
      "answers": {
        "A": "A: [1, 2, 3, 4, 5]",
        "B": "B: [1, 2, 3, 5]",
        "C": "C: [1, 2, 3, 4]",
        "D": "D: Error"
      },
      "right_answer": "D",
      "details": "Метод push возвращает длину нового массива, а не сам массив. Устанавливая newList равным [1, 2, 3].push(4), мы устанавливаем newList равным 4. Затем мы пытаемся использовать метод push для newList. Поскольку newList является числом 4, мы не можем использовать push: выбрасывается исключение TypeError."
    },
    {
      "id": "89c3c5ef-f858-49c5-8c92-7c1e3ccddad1",
      "code": "function giveLydiaPizza() {\n    return \"А вот и пицца!\"\n}\n\nconst giveLydiaChocolate = () => \"Вот шоколад... теперь дуй в тренажерку.\"\n\nconsole.log(giveLydiaPizza.prototype)\nconsole.log(giveLydiaChocolate.prototype)",
      "answers": {
        "A": "A: { constructor: ...} { constructor: ...}",
        "B": "B: {} { constructor: ...}",
        "C": "C: { constructor: ...} {}",
        "D": "D: { constructor: ...} undefined"
      },
      "right_answer": "D",
      "details": "Обычные функции, такие как giveLydiaPizza(), имеют свойство prototype, которое является объектом (прототипом объекта) со свойством constructor. Однако стрелочные функции, такие как giveLydiaChocolate(), не имеют прототипа. Поэтому при попытке получить доступ к giveLydiaChocolate.prototype возвращается undefined."
    },
    {
      "id": "953da7ec-4b41-419f-8787-ff1e909293b1",
      "code": "const person = {\n    name: \"Lydia\",\n    age: 21\n}\n\nfor (const [x, y] of Object.entries(person)) {\n    console.log(x, y)\n}",
      "answers": {
        "A": "A: name Lydia и age 21",
        "B": "B: ['name', 'Lydia'] и ['age', 21]",
        "C": "C: ['name', 'age'] и undefined",
        "D": "D: Error"
      },
      "right_answer": "A",
      "details": "Object.entries(person) возвращает массив вложенных массивов, содержащий ключи и значения:<br> [ [ 'name', 'Lydia' ], [ 'age', 21 ] ]<br> С помощью for-of мы перебираем элементы массива, в данном случае подмассивы. Мы можем деструктурировать подмассивы в цикле, используя const [x, y]. 'x' равен первому элементу в подмассиве, 'y' - второму. Первым подмассивом является [ 'name', 'Lydia' ], где 'x' равняется 'name', а 'y' = 'Lydia'. Вторым подмассивом является [ 'age', 21 ], где 'x' = 'age', и 'y' равняется 21."
    },
    {
      "id": "571e8671-8b90-46d3-b390-47cab5d2b86d",
      "code": "function getItems(fruitList, ...args, favoriteFruit) {\n    return [...fruitList, ...args, favoriteFruit]\n}\n\nconsole.log(getItems([\"banana\", \"apple\"], \"pear\", \"orange\"))",
      "answers": {
        "A": "A: ['banana', 'apple', 'pear', 'orange']",
        "B": "B: [['banana', 'apple'], 'pear', 'orange']",
        "C": "C: ['banana', 'apple', ['pear'], 'orange']",
        "D": "D: SyntaxError"
      },
      "right_answer": "D",
      "details": "...args - это прочие параметры (оператор rest). Значение rest - это массив, содержащий неиспользованные аргументы и в этой связи передаваемый последним. В примере rest является вторым аргументом. Это приводит к синтаксической ошибке."
    },
    {
      "id": "87c9e8bd-1514-4f02-be31-a89f46b7d4e3",
      "code": "function nums(a, b) {\n    if\n        (a > b)\n        console.log('a больше')\n    else\n        console.log('b больше')\n        return\n    a + b\n}\n\nconsole.log(nums(4, 2))\nconsole.log(nums(1, 2))",
      "answers": {
        "A": "A: a больше, 6 и b больше, 3",
        "B": "B: a больше, undefined and b больше, undefined",
        "C": "C: undefined and undefined",
        "D": "D: SyntaxError"
      },
      "right_answer": "B",
      "details": "В JavaScript мы не должны явно указывать точку с запятой (;), однако компилятор автоматически добавляет их после операторов. Например, оператором могут быть переменные или ключевые слова, такие как throw, return, break и т.д. Здесь мы написали инструкцию return и другое значение a + b в новой строке. Однако, поскольку это новая строка, движок не знает, что это на самом деле значение, которое мы хотим вернуть. Вместо этого, он автоматически добавляет точку с запятой после return. Это выглядит так:"
    },
    {
      "id": "42b72018-ce7b-4057-9af3-fd6d24f9ec17",
      "code": "class Person {\n    constructor() {\n        this.name = \"Lydia\"\n    }\n}\n\nPerson = class AnotherPerson {\n    constructor() {\n        this.name = \"Sarah\"\n    }\n}\n\nconst member = new Person()\nconsole.log(member.name)",
      "answers": {
        "A": "A: 'Lydia'",
        "B": "B: 'Sarah'",
        "C": "C: Error: cannot redeclare Person",
        "D": "D: SyntaxError"
      },
      "right_answer": "B",
      "details": "Мы можем установить классы равными другим классам/конструкторам функций. В данном случае мы устанавливаем Person равным AnotherPerson. Свойство name этого конструктора - Sarah, поэтому свойство name для нового экземпляра класса Person member - это также Sarah."
    },
    {
      "id": "18952e93-ba83-4a2e-9673-034ddaf13cb9",
      "code": "const info = {\n    [Symbol('a')]: 'b'\n}\n\nconsole.log(info)\nconsole.log(Object.keys(info))",
      "answers": {
        "A": "A: {Symbol('a'): 'b'} и ['{Symbol('a')']",
        "B": "B: {} и []",
        "C": "C: { a: 'b' } и ['a']",
        "D": "D: {Symbol('a'): 'b'} и []"
      },
      "right_answer": "D",
      "details": "Symbol не является перечисляемый. Метод Object.keys возвращает все перечисляемые ключи объекта. Symbol не просматривается таким образом, и возвращается пустой массив. При выводе в консоль всего объекта будут видны все свойства, даже не перечисляемые. Это одно из многих качеств символа: помимо представления совершенно уникального значения (которое предотвращает случайное пересечение имен в объектах, например, при работе с 2 библиотеками, которые хотят добавить свойства к одному и тому же объекту). Мы также можем 'скрыть' свойства объектов таким способом (хотя и не полностью. Мы можем получить доступ к символам с помощью метода Object.getOwnPropertySymbols())."
    },
    {
      "id": "14736904-2175-426a-9310-c0bdd459c704",
      "code": "const getList = ([x, ...y]) => [x, y]\nconst getUser = user => { name: user.name, age: user.age }\n\nconst list = [1, 2, 3, 4]\nconst user = { name: \"Lydia\", age: 21 }\n\nconsole.log(getList(list))\nconsole.log(getUser(user))",
      "answers": {
        "A": "A: [1, [2, 3, 4]] и undefined",
        "B": "B: [1, [2, 3, 4]] и { name: 'Lydia', age: 21 }",
        "C": "C: [1, 2, 3, 4] и { name: 'Lydia', age: 21 }",
        "D": "D: Error и { name: 'Lydia', age: 21 }"
      },
      "right_answer": "A",
      "details": "Функция getList() получает массив в качестве аргумента. В getList() мы деструктурируем этот массив. Это выглядит так:<br> [x, ...y] = [1, 2, 3, 4]<br> С помощью прочих параметров (оператора rest) ...y мы помещаем все 'оставшиеся' аргументы в массив. Такими аргументами являются 2, 3 и 4. Значение 'y' является массивом, содержащим прочие параметры. В данном случае значение 'x' равно 1, поэтому, мы видим в консоли [x, y], [1, [2, 3, 4]]. Функция getUser() получает объект. В случае стрелочных функций мы можем обойтись без фигурных скобок, если возвращаем только одно значение. Однако, если мы хотим вернуть объект из стрелочной функции, то должны указать его в круглых скобках, в противном случае, никакое значение не будет возвращено. Следующая функция вернула бы объект:<br> const getUser = user =&gt; ({ name: user.name, age: user.age }) <br> Поскольку значение не возвращается, функция возвращает undefined."
    },
    {
      "id": "405a1d56-87fb-486e-9a31-7f2d9fe5e55c",
      "code": "const name = \"Lydia\"\n\nconsole.log(name())",
      "answers": {
        "A": "A: SyntaxError",
        "B": "B: ReferenceError",
        "C": "C: TypeError",
        "D": "D: undefined"
      },
      "right_answer": "C",
      "details": "Переменная name содержит значение строки, которая не является функцией, поэтому не может быть вызвана. TypeError возникает, когда значение не соответствует ожидаемому типу. JavaScript ожидал, что name будет функцией, так как мы пытаемся ее вызвать. Однако name является строкой, поэтому выбрасывается исключение TypeError: name is not a function. SyntaxError генерируются, когда мы написали нечто недопустимое с точки зрения JavaScript, например, когда слово return написано как retrun. ReferenceError генерируются, когда JavaScript не может найти ссылку на значение, к которому мы обращаемся."
    },
    {
      "id": "4066ecb5-b322-44ee-9c6f-01cb9397b568",
      "code": "console.log(\n    `${[] && 'Не'}вероятно!\n    Вам ${'' && 'не'}следует обратиться (обращаться) к врачу после такого количества JavaScript lol`\n)",
      "answers": {
        "A": "A: вероятно! Вам следует обратиться к врачу после такого количества JavaScript lol",
        "B": "B: Невероятно! Вам следует обратиться к врачу после такого количества JavaScript lol",
        "C": "C: вероятно! Вам не следует обращаться к врачу после такого количества JavaScript lol",
        "D": "D: Невероятно! Вам не следует обращаться к врачу после такого количества JavaScript lol"
      },
      "right_answer": "B",
      "details": "[] - истинное значение. Оператор &amp;&amp; возвращает правое значение, если левое значение является истинным. В данном случае левое значение [] является истинным, поэтому возвращается 'Не'. '' - ложное значение. Если левое значение ложно, ничего не возвращается. 'не' не возвращается."
    },
    {
      "id": "95cbccf6-111c-4aae-8fa9-64943b5d7554",
      "code": "const one = (false || {} || null)\nconst two = (null || false || \"\")\nconst three = ([] || 0 || true)\n\nconsole.log(one, two, three)",
      "answers": {
        "A": "A: false null []",
        "B": "B: null '' true",
        "C": "C: {} '' []",
        "D": "D: null null true"
      },
      "right_answer": "C",
      "details": "Оператор || возвращает первый истинный операнд. Если все значения ложны, возвращается последний операнд. (false || {} || null): пустой объект {} является истинным значением. Это первое (и единственное) истинное значение, которое и возвращается. one = {}. (null || false ||' '): все операнды являются ложными. Это означает, что возвращается последний операнд - ''. two = ''. ([] || 0 ||' '): пустой массив [] является истинным. Это первое истинное значение, которое и возвращается. three = []."
    },
    {
      "id": "648a6de2-ead7-4229-8cd4-b19790a4d1f1",
      "code": "const myPromise = () => Promise.resolve('I have resolved!')\n\nfunction firstFunction() {\n  myPromise().then(res => console.log(res))\n  console.log('first')\n}\n\nasync function secondFunction() {\n  console.log(await myPromise())\n  console.log('second')\n}\n\nfirstFunction()\nsecondFunction()",
      "answers": {
        "A": "A: I have resolved!, first and I have resolved!, second",
        "B": "B: first, I have resolved! and second, I have resolved!",
        "C": "C: I have resolved!, second and first, I have resolved!",
        "D": "D: first, I have resolved! and I have resolved!, second"
      },
      "right_answer": "D",
      "details": "С промисами дело обстоит следующим образом: 'Я хочу отложить выполнение этой функции, поскольку это может занять некоторое время'. Только когда определенное значение разрешено (или отклонено), и когда стек вызовов пуст, я хочу получить это значение. Мы можем получить значение с помощью ключевого слова then и await в асинхронной функции. Хотя мы можем получить значение промиса с помощью then и await, они работают по-разному. В firstFunction мы (вроде бы) приостановили выполнение функции myPromise, и продолжили выполнение другого кода, в данном случае console.log('first'). Затем функция разрешается строкой 'I have resolved!', которая выводится в консоль после освобождения стека вызовов. С помощью ключевого слова await в secondFunction, мы приостанавливаем выполнение асинхронной функции до тех пор, пока значение не будет разрешено. Это означает, что мы ожидаем разрешения myPromise со значением 'I have resolved!', и только когда это произошло, мы переходим к следующей строке: second выводится в консоль последней."
    },
    {
      "id": "eaa4e349-a80f-4a37-9c2e-784ad7f77357",
      "code": "const set = new Set()\n\nset.add(1)\nset.add(\"Lydia\")\nset.add({ name: \"Lydia\" })\n\nfor (let item of set) {\n  console.log(item + 2)\n}",
      "answers": {
        "A": "A: 3, NaN, NaN",
        "B": "B: 3, 7, NaN",
        "C": "C: 3, Lydia2, [object Object]2",
        "D": "D: '12', Lydia2, [object Object]2"
      },
      "right_answer": "C",
      "details": "Оператор + используется не только для сложения чисел, но и для объединения (конкатенации) строк. Всякий раз, когда движок JavaScript видит, что одно или несколько значений не являются числом, он приводит число к строке. Первым значением является 1 - число. 1 + 2 возвращает 3. Тем не менее, второе значение 'Lydia'. 'Lydia' является строкой, а 2 является числом: 2 приводится к строке. 'Lydia' и '2' объединяются, что приводит к 'Lydia2'. {name: 'Lydia'} является объектом. Ни число, ни объект не являются строкой, поэтому они приводятся к строке. Когда объект приводится к строке он становится '[object Object]'. '[object Object]', объединенный с '2', становится '[object Object]2'."
    },
    {
      "id": "9526dd81-57d2-4f88-ac3f-39a62d05727b",
      "code": "console.log(Promise.resolve(5))",
      "answers": {
        "A": "A: 5",
        "B": "B: Promise {: 5}",
        "C": "C: Promise {: 5}",
        "D": "D: Error"
      },
      "right_answer": "C",
      "details": "Мы можем передать в Promise.resolve любой тип данных. Данный метод возвращает промис с разрешенным значением. Если мы передадим ему обычную функцию, промис разрешится с обычным значением. Если мы передадим промис, промис разрешится с разрешенным значением переданного промиса. В данном случае мы передаем число 5. Возвращается разрешенный промис со значением 5."
    },
    {
      "id": "05bd8a9f-a484-4433-a22f-bc05bc4e27b0",
      "code": "function compareMembers(person1, person2 = person) {\n    if (person1 !== person2) {\n      console.log(\"Не одинаковые!\")\n    } else {\n      console.log(\"Одинаковые!\")\n    }\n}\n\nconst person = { name: \"Lydia\" }\n\ncompareMembers(person)",
      "answers": {
        "A": "A: Не одинаковые!",
        "B": "B: Одинаковые!",
        "C": "C: ReferenceError",
        "D": "D: SyntaxError"
      },
      "right_answer": "B",
      "details": "Объекты передаются по ссылке. Когда мы проверяем объекты на строгое равенство (идентичность) (===), мы сравниваем их ссылки. Мы устанавливаем значение по умолчанию для person2, равное объекту person, и передаем объект person в качестве значения для person1. Это означает, что оба значения имеют ссылку на одно и то же место в памяти, поэтому они равны. Блок кода в операторе else запускается, и в консоль выводится 'Одинаковые!'."
    },
    {
      "id": "3e7ccb9d-8145-4f2f-97d7-2222d330b8e8",
      "code": "const colorConfig = {\n    red: true,\n    blue: false,\n    green: true,\n    black: true,\n    yellow: false,\n}\n\nconst colors = [\"pink\", \"red\", \"blue\"]\n\nconsole.log(colorConfig.colors[1])",
      "answers": {
        "A": "A: true",
        "B": "B: false",
        "C": "C: undefined",
        "D": "D: TypeError"
      },
      "right_answer": "D",
      "details": "В JavaScript у нас есть два способа получить доступ к свойствам объекта: скобочная нотация или точечная нотация. В данном случае мы используем точечную нотацию (colorConfig.colors) вместо скобочной (colorConfig['colors']). При точечной нотации JavaScript пытается найти свойство объекта с указанным именем. В примере JavaScript пытается найти свойство colors в объекте colorConfig. Не существует такого свойства, поэтому возвращается undefined.<br> Затем мы пытаемся получить доступ к значению первого элемента, используя [1]. Мы не можем сделать этого для undefined, поэтому выбрасывается исключение TypeError: Cannot read property '1' of undefined.<br> JavaScript интерпретирует (или распаковывает) операторы. Когда мы используем скобочную нотацию, он видит открывающуюся скобку [ и продолжает работать, пока не найдет закрывающуюся скобку ]. Только тогда он оценивает выражение. Если бы мы использовали colorConfig[colors[1]], то вернулось бы значение свойства red объекта colorConfig."
    },
    {
      "id": "8b082c34-106a-4448-94ed-80ec1d8e00f7",
      "code": "console.log('❤️' === '❤️')",
      "answers": {
        "A": "A: true",
        "B": "B: false"
      },
      "right_answer": "A",
      "details": "Смайлики - это юникоды. Юникод для сердца - 'U+2764 U+FE0F'. Юникоды одинаковы для одних и тех же смайликов, поэтому мы сравниваем две одинаковые строки, что возвращает true."
    },
    {
      "id": "23a0a41b-af4f-422e-bef7-daf66c1cd742",
      "code": "const food = ['🍕', '🍫', '🍳', '🍔']\nconst info = { favoriteFood: food[0] }\n\ninfo.favoriteFood = '🍝'\n\nconsole.log(food)",
      "answers": {
        "A": "A: ['🍕', '🍫', '🍳', '🍔']",
        "B": "B: ['🍝', '🍫', '🍳', '🍔']",
        "C": "C: ['🍝', '🍕', '🍫', '🍳', '🍔']"
      },
      "right_answer": "A",
      "details": "Мы устанавливаем значение свойства favourFood объекта info равным строке '🍕'. Строка является примитивным типом данных. В JavaScript примитивные типы данных (все, что не является объектом) передаются по значению. Затем мы меняем значение свойства favourFood объекта info. Массив food не изменился, поскольку значение favourFood было скопировано из значения первого элемента в массиве и не имеет ссылки на то же место в памяти, что и food[0]. Поэтому в консоль выводится исходный массив ['🍕', '🍫', '🍳', '🍔']."
    },
    {
      "id": "152f46ab-a3f9-4d30-b149-e27230b6a084",
      "code": "let name = 'Lydia'\n\nfunction getName() {\n  console.log(name)\n  let name = 'Sarah'\n}\n\ngetName()",
      "answers": {
        "A": "A: Lydia",
        "B": "B: Sarah",
        "C": "C: undefined",
        "D": "D: ReferenceError"
      },
      "right_answer": "D",
      "details": "Каждая функция имеет собственный контекст выполнения (или область видимости). Функция getName() сначала ищет переменную name в собственном контексте (области видимости). getName() содержит собственную переменную name: мы объявляем переменную name с помощью ключевого слова let и присваиваем ей значение 'Sarah'. Переменные, объявленные с помощью ключевого слова let (и const) не поднимаются в начало функции, в отличие от переменных, объявленных с помощью var. Они недоступны до инициализации. Это называется 'временной мертвой зоной'. Когда мы пытаемся получить доступ к таким переменным, JavaScript выбрасывает исключение ReferenceError. Если бы мы не объявили переменную name в функции getName(), движок JavaScript продолжал бы поиск переменной вверх по цепочке областей видимости. Внешняя область видимости содержит переменную name со значением Lydia. В этом случае в консоль было бы выведено 'Lydia'."
    },
    {
      "id": "454693c0-03c4-4159-a7a2-1b3e16ef0b97",
      "code": "function* generatorOne() {\n    yield ['a', 'b', 'c'];\n}\n\nfunction* generatorTwo() {\n    yield* ['a', 'b', 'c'];\n}\n\nconst one = generatorOne()\nconst two = generatorTwo()\n\nconsole.log(one.next().value)\nconsole.log(two.next().value)",
      "answers": {
        "A": "A: a и a",
        "B": "B: a и undefined",
        "C": "C: ['a', 'b', 'c'] и a",
        "D": "D: a и ['a', 'b', 'c']"
      },
      "right_answer": "C",
      "details": "С помощью ключевого слова yield мы получаем значения в функции-генераторе. С помощью yield* мы можем получить значение из другой функции-генератора или итерируемого объекта (например, массива). В generatorOne() мы получаем весь массив [' a ',' b ',' c '], используя yield. Значение свойства value, возвращаемого методом next объекта one (one.next().value), равняется массиву ['a', 'b', 'c']."
    },
    {
      "id": "9466815c-fa0e-4d58-aa87-62969c2ad7a3",
      "code": "console.log(`${(x => x)('Я люблю')} писать код`)",
      "answers": {
        "A": "A: Я люблю писать код",
        "B": "B: undefined писать код",
        "C": "C: ${(x => x)('Я люблю') писать код",
        "D": "D: TypeError"
      },
      "right_answer": "A",
      "details": "Выражения внутри шаблонных литералов оцениваются первыми. Это означает, что строка будет содержать значение выражения, в данном случае значение немедленно вызываемого функционального выражения (x =&gt; x)('I love'). Мы передаем значение 'Я люблю' в качестве аргумента стрелочной функции x =&gt; x. x = 'Я люблю', что и возвращается. Это приводит к 'Я люблю писать код'."
    },
    {
      "id": "0e3025a8-3dec-4696-a0a8-c48210a5039a",
      "code": "const person = {\n    name: \"Lydia\",\n    age: 21\n}\n\nconst changeAge = (x = { ...person }) => x.age += 1\nconst changeAgeAndName = (x = { ...person }) => {\n    x.age += 1\n    x.name = \"Sarah\"\n}\n\nchangeAge(person)\nchangeAgeAndName()\n\nconsole.log(person)",
      "answers": {
        "A": "A: {name: 'Sarah', age: 22}",
        "B": "B: {name: 'Sarah', age: 23}",
        "C": "C: {name: 'Lydia', age: 22}",
        "D": "D: {name: 'Lydia', age: 23}"
      },
      "right_answer": "C",
      "details": "Функции changeAge() и changeAgeAndName() имеют параметры по умолчанию, а именно: вновь созданный объект { ...person }. Этот объект имеет копии всех ключей/значений объекта person. Сначала мы вызываем функцию changeAge() и передаем ей объект person в качестве аргумента. Эта функция увеличивает значение свойства age на 1. person теперь равняется {name: 'Lydia', age: 22}. Затем мы вызываем функцию changeAgeAndName() без аргументов. Поэтому значение 'x' равняется новому объекту: { ...person }. Поскольку это новый объект, он не влияет на свойства объекта person. person по-прежнему равняется {name: 'Lydia', age: 22}."
    },
    {
      "id": "deaa2787-33f2-4293-ab54-5e8a534d8413",
      "code": "function sumValues(x, y, z) {\n    return x + y + z; // 6\n}",
      "answers": {
        "A": "A: sumValues([...1, 2, 3])",
        "B": "B: sumValues([...[1, 2, 3]])",
        "C": "C: sumValues(...[1, 2, 3])",
        "D": "D: sumValues([1, 2, 3])"
      },
      "right_answer": "C",
      "details": "С помощью оператора распространения (spread) ... мы разбиваем итерируемые сущности на отдельные элементы. Функция sumValues() принимает три аргумента: x, y и z. Для того, чтобы эта функция вернула 6, ей в качестве аргумента необходимо передать ...[1, 2, 3]."
    },
    {
      "id": "1334ab20-1100-4deb-aeef-a2c9cde80709",
      "code": "let num = 1;\nconst list = ['a', 'b', 'c', 'd'];\n\nconsole.log(list[(num += 1)]);",
      "answers": {
        "A": "A: b",
        "B": "B: c",
        "C": "C: SyntaxError",
        "D": "D: ReferenceError"
      },
      "right_answer": "B",
      "details": "С помощью оператора += мы увеличиваем значение num на 1. Начальным значением num является 1, 1 + 1 = 2. Элементом со вторым индексом является 'c', что и выводится в консоль."
    },
    {
      "id": "815294c9-20a0-45e8-9f28-9127ec19ce55",
      "code": "const person = {\n    firstName: 'Lydia',\n    lastName: 'Hallie',\n    pet: {\n      name: 'Mara',\n      breed: 'Dutch Tulip Hound',\n    },\n    getFullName() {\n      return `${this.firstName} ${this.lastName}`;\n    },\n};\n\nconsole.log(person.pet?.name);\nconsole.log(person.pet?.family?.name);\nconsole.log(person.getFullName?.());\nconsole.log(member.getLastName?.());",
      "answers": {
        "A": "A: undefined undefined undefined undefined",
        "B": "B: Mara undefined Lydia Hallie undefined",
        "C": "C: Mara null Lydia Hallie null",
        "D": "D: null ReferenceError null ReferenceError"
      },
      "right_answer": "B",
      "details": "Благодаря оператору опциональной цепочки ?. нам больше не нужно проверять глубоко вложенные значения на валидность. Если мы попытаемся получить доступ к свойству значения undefined или null, выражение вернет undefined. person.pet?.name: person имеет свойство pet; pet имеет свойство name, возвращается Mara. person.pet?.family?.name: person имеет свойство pet; pet не имеет свойства family; person.pet?.family отсутствует, возвращается undefined. person.getFullName?.(): person имеет метод getFullName(), возвращается Lydia Hallie. member.getLastName?.(): member не определена; member.getLastName() отсутствует, возвращается undefined."
    },
    {
      "id": "2cc2c938-11aa-41df-b1c3-25b9f0676f0b",
      "code": "const groceries = ['banana', 'apple', 'peanuts'];\n\nif (groceries.indexOf('banana')) {\n  console.log('Нам нужно купить бананы!');\n} else {\n  console.log('Нам не нужно покупать бананы!');\n}",
      "answers": {
        "A": "A: Нам нужно купить бананы!",
        "B": "B: Нам не нужно покупать бананы!",
        "C": "C: undefined",
        "D": "D: 1"
      },
      "right_answer": "B",
      "details": "Условие groceries.indexOf('banana') возвращает 0, который является ложным значением. Поскольку условие ложно, выполняется блок else, и мы получаем 'Нам не нужно покупать бананы!'"
    },
    {
      "id": "b562ff8c-bbff-4ab1-b542-60198e2e36fa",
      "code": "const config = {\n    languages: [],\n    set language(lang) {\n      return this.languages.push(lang);\n    },\n};\n\nconsole.log(config.language);",
      "answers": {
        "A": "A: function language(lang) { this.languages.push(lang }",
        "B": "B: 0",
        "C": "C: []",
        "D": "D: undefined"
      },
      "right_answer": "D",
      "details": "Метод language() - это сеттер. Сеттеры не имеют собственных значений, их задача - модифицировать свойства. Поэтому вызов сеттера возвращает undefined."
    },
    {
      "id": "3feb3405-222c-42b0-97dc-2004954086eb",
      "code": "const name = 'Lydia Hallie';\n\nconsole.log(!typeof name === 'object');\nconsole.log(!typeof name === 'string');",
      "answers": {
        "A": "A: false true",
        "B": "B: true false",
        "C": "C: false false",
        "D": "D: true true"
      },
      "right_answer": "C",
      "details": "typeof name возвращает 'string'. 'string' - это истинное значение, поэтому !typeof name = false. false === 'object' и false === 'string' возвращают false (если мы хотим сравнить типы значений вместо !typeof следует использовать !==)."
    },
    {
      "id": "2d58e3ee-f255-469e-8f6e-df063de8676e",
      "code": "const add = x => y => z => {\n    console.log(x, y, z);\n    return x + y + z;\n};\n\nadd(4)(5)(6);",
      "answers": {
        "A": "A: 4 5 6",
        "B": "B: 6 5 4",
        "C": "C: 4 function function",
        "D": "D: undefined undefined 6"
      },
      "right_answer": "A",
      "details": "Функция add() возвращает стрелочную функцию, которая возвращает стрелочную функцию, которая возвращает стрелочную функцию (вы еще здесь?). Первая функция принимает аргумент 'x' со значением 4. Мы вызываем вторую функцию с аргументом 'y' со значением 5. Затем мы вызываем третью функцию с аргументом 'z' со значением 6. Когда мы пытаемся получить доступ к значениям 'x' и 'y', движок JavaScript поднимается по цепочке областей видимости в поисках соответствующих значений. Возвращается 4 5 6."
    },
    {
      "id": "92a80cdf-909a-45dc-82d0-c37931ac1181",
      "code": "async function* range(start, end) {\n    for (let i = start; i <= end; i++) {\n      yield Promise.resolve(i);\n    }\n  }\n\n(async () => {\n    const gen = range(1, 3);\n    for await (const item of gen) {\n        console.log(item);\n    }\n})();",
      "answers": {
        "A": "A: Promise {1} Promise {2} Promise {3}",
        "B": "B: Promise {} Promise {} Promise {}",
        "C": "C: 1 2 3",
        "D": "D: undefined undefined undefined"
      },
      "right_answer": "C",
      "details": "Функция-генератор range() возвращает асинхронный объект с промисами для каждого переданного значения: Promise{1}, Promise{2}, Promise{3}. Мы присваиваем переменной gen этот объект, и перебираем его элементы с помощью цикла for await... of. Мы устанавливаем значение переменной item равным значению промиса. Поскольку мы ожидаем значения item, т.е. разрешения промиса, то получаем 1, 2, 3."
    },
    {
      "id": "1f471d10-3c15-4017-802f-33f935b880be",
      "code": "const myFunc = ({ x, y, z }) => {\n    console.log(x, y, z);\n};\n\nmyFunc(1, 2, 3);",
      "answers": {
        "A": "A: 1 2 3",
        "B": "B: {1: 1} {2: 2} {3: 3}",
        "C": "C: { 1: undefined } undefined undefined",
        "D": "D: undefined undefined undefined"
      },
      "right_answer": "D",
      "details": "myFunc в качестве аргумента ожидает получить объект со свойствами x, y и z. Поскольку мы передаем ей 1, 2, 3, а не {x: 1, y: 2, z: 3}, то возвращается значение x, y и z по умолчанию, т.е. undefined."
    },
    {
      "id": "2281f243-d816-4355-acb5-61edd54f4736",
      "code": "function getFine(speed, amount) {\n    const formattedSpeed = new Intl.NumberFormat({\n        'en-US',\n        { style: 'unit', unit: 'mile-per-hour' }\n    }).format(speed)\n\n    const formattedAmount = new Intl.NumberFormat({\n        'en-US',\n        { style: 'currency', currency: 'USD' }\n    }).format(amount)\n\n    return `The driver drove ${formattedSpeed} and has to pay ${formattedAmount}`\n}\n\nconsole.log(getFine(130, 300))",
      "answers": {
        "A": "A: The driver drove 130 and has to pay 300",
        "B": "B: The driver drove 130 mph and has to pay $300.00",
        "C": "C: The driver drove undefined and has to pay undefined",
        "D": "D: The driver drove 130.00 and has to pay 300.00"
      },
      "right_answer": "B",
      "details": "С помощью метода Intl.NumberFormat() мы можем форматировать числовые значению в любую локаль. Мы форматируем число 130 в локаль en-US как unit со значением mile-per-hour, что возвращает 130 mph. Число 300 в локали en-US со свойством currency и значением USD возвращает $300.00."
    },
    {
      "id": "6e38d81b-ff56-4a13-9c25-aa242ea9dac6",
      "code": "const spookyItems = ['👻', '🎃', '👿'];\n({ item: spookyItems[3] } = { item: '💀' });\n\nconsole.log(spookyItems);",
      "answers": {
        "A": "A: ['👻', '🎃', '👿']",
        "B": "B: ['👻', '🎃', '👿', '💀']",
        "C": "C: ['👻', '🎃', '👿', { item: '💀' }]",
        "D": "D: ['👻', '🎃', '👿', '[object Object]']"
      },
      "right_answer": "B",
      "details": "Деструктурируя объекты, мы распаковываем значения правого объекта и присваиваем это значение одноименному свойству левого объекта. В данном случае, мы присваиваем значение '💀' spookyItems[3]. Это означает, что мы модифицируем массив spookyItems, добавляя в него '💀'. Поэтому получаем ['👻', '🎃', '👿', '💀']."
    },
    {
      "id": "765181da-ef1e-4bab-882a-8fd8f6536665",
      "code": "const name = 'Lydia Hallie';\nconst age = 21;\n\nconsole.log(Number.isNaN(name));\nconsole.log(Number.isNaN(age));\n\nconsole.log(isNaN(name));\nconsole.log(isNaN(age));",
      "answers": {
        "A": "A: true false true false",
        "B": "B: true false false false",
        "C": "C: false false true false",
        "D": "D: false true false true"
      },
      "right_answer": "C",
      "details": "С помощью метода Number.isNaN() мы можем проверить, является ли переданное значение числом и равняется ли оно NaN. name не является числовым значением, поэтому Number.isNaN(name) возвращает false. age является числовым значением, но не равняется NaN, поэтому Number.isNaN(age) также возвращает false. С помощью метода isNaN() мы можем проверить, что переданное значение не является числом. Значение name не является числом, поэтому isNaN(name) возвращает true. Значение age является числом, поэтому isNaN(age) возвращает false."
    },
    {
      "id": "246810d0-d55c-4b75-9487-24bd4e2bc1a2",
      "code": "const randomValue = 21;\n\nfunction getInfo() {\n  console.log(typeof randomValue);\n  const randomValue = 'Lydia Hallie';\n}\n\ngetInfo();",
      "answers": {
        "A": "A: 'number'",
        "B": "B: 'string'",
        "C": "C: undefined",
        "D": "D: ReferenceError"
      },
      "right_answer": "D",
      "details": "Переменные, объявленные с помощью ключевого слова const недоступны до инициализации: это называется 'временной мертвой зоной'. В getInfo() областью видимости переменной randomValue является функция. Когда мы пытаемся вывести значение randomValue в консоль, она еще не инициализирована: выбрасывается исключение ReferenceError. Движок не спускается вниз по цепочке областей видимости, поскольку мы объявили переменную randomValue в функции getInfo()."
    },
    {
      "id": "297e6dc7-9c46-45a5-94c1-7a31763618c2",
      "code": "const myPromise = Promise.resolve('Woah some cool data');\n\n(async () => {\n  try {\n    console.log(await myPromise);\n  } catch {\n    throw new Error(`Oops didn't work`);\n  } finally {\n    console.log('Oh finally!');\n  }\n})();",
      "answers": {
        "A": "A: Woah some cool data",
        "B": "B: Oh finally!",
        "C": "C: Woah some cool data Oh finally!",
        "D": "D: Oops didn't work Oh finally!"
      },
      "right_answer": "C",
      "details": "В блоке try мы выводим в консоль ожидаемое значение переменной myPromise: 'Woah some cool data'. Поскольку в блоке try не возникло ошибки, код в блоке catch не выполняется. Код в блоке finally выполняется всегда, поэтому в консоль выводится 'Oh finally!'"
    },
    {
      "id": "41437dc2-4ca6-4eb7-8d53-d012f461558d",
      "code": "const emojis = ['💫', ['✨', '✨', ['🍕', '🍕']]];\n\nconsole.log(emojis.flat(1));",
      "answers": {
        "A": "A: ['💫', ['✨', '✨', ['🍕', '🍕']]]",
        "B": "B: ['💫', '✨', '✨', ['🍕', '🍕']]",
        "C": "C: ['💫', ['✨', '✨', '🍕', '🍕']]",
        "D": "D: ['💫', '✨', '✨', '🍕', '🍕']"
      },
      "right_answer": "B",
      "details": "С помощью метода flat мы можем создать новый 'плоский' массив. Глубина этого массива зависит от передаваемого значения. В данном случае, мы передаем значение 1 (чего мы могли бы не делать, поскольку это является значением по умолчанию), значит, будут объединены только массивы певрого уровня вложенности, т.е. ['💫'] и ['✨', '✨', ['🍕', '🍕']]. Результатом объединения этих массивов является ['💫', '✨', '✨', ['🍕', '🍕']]."
    },
    {
      "id": "fdcbd1c5-372a-4881-a46e-5157503494ac",
      "code": "class Counter {\n    constructor() {\n      this.count = 0;\n    }\n\n    increment() {\n      this.count++;\n    }\n}\n\nconst counterOne = new Counter();\ncounterOne.increment();\ncounterOne.increment();\n\nconst counterTwo = counterOne;\ncounterTwo.increment();\n\nconsole.log(counterOne.count);",
      "answers": {
        "A": "A: 0",
        "B": "B: 1",
        "C": "C: 2",
        "D": "D: 3"
      },
      "right_answer": "D",
      "details": "counterOne является экземпляром класса Counter. Класс Counter содержит свойство count в конструкторе и метод increment(). Сначала мы дважды вызываем метод increment() с помощью counterOne.increment(). Таким образом, значением counterOne.count становится 2. Затем мы создаем новую переменную counterTwo и присваиваем ей значение counterOne. Поскольку объекты взаимодействуют через ссылки, мы просто создали новую ссылку на тоже самое место в памяти, на которое указывает counterOne. Поскольку обе переменные ссылаются на одно и тоже место в памяти, любые изменения объекта, на который ссылается counterTwo также влияют на counterOne. Таким образом, значением counterTwo является 2. Мы вызываем counterTwo.increment(), который увеличивает значение count до 3. Наконец, мы выводим в консоль значение counterOne.count, которое также равняется 3."
    },
    {
      "id": "11b7525c-00f8-4f32-9aa7-62eec8739d3f",
      "code": "const myPromise = Promise.resolve(Promise.resolve('Promise!'));\n\nfunction funcOne() {\n  myPromise.then(res => res).then(res => console.log(res));\n  setTimeout(() => console.log('Timeout!', 0));\n  console.log('Last line!');\n}\n\nasync function funcTwo() {\n  const res = await myPromise;\n  console.log(await res);\n  setTimeout(() => console.log('Timeout!', 0));\n  console.log('Last line!');\n}\n\nfuncOne();\nfuncTwo();",
      "answers": {
        "A": "A: Promise! Last line! Promise! Last line! Last line! Promise!",
        "B": "B: Last line! Timeout! Promise! Last line! Timeout! Promise!",
        "C": "C: Promise! Last line! Last line! Promise! Timeout! Timeout!",
        "D": "D: Last line! Promise! Promise! Last line! Timeout! Timeout!"
      },
      "right_answer": "D",
      "details": "Сначала мы вызываем функцию funcOne(). На первой строке этой функции мы вызываем промис myPromise, который является асинхронной операцией. Пока движок занят выполнением промиса, выполнение myFunc() продолжается. Следующей строкой является асинхронная функция setTimeout(), функция обратного вызова которой отправляется в Web API. Промис и setTimeout() являются асинхронными, поэтому выполнение функции не дожидается разрешения промиса и обработки setTimeout().<br> Это означает, что сначала в консоль выводится 'Last line!', поскольку console.log() не асинхронная операция. Это последняя строка кода в myFunc(), промис разрешается и в консоль выводится 'Promise!'.<br> В момент вызова функции funcTwo() стек вызовов не является пустым, поэтому функция обратного вызова setTimeout() не может туда попасть. В funcTwo() мы сначала ожидаем разрешение промиса myPromise. С помощью ключевого слова await мы приостанавливаем выполнение функции до разрешения (или отклонения) промиса. Затем мы выводим в консоль ожидаемое значение res (поскольку промис возвращает промис). В консоль выводится 'Promise!'. На следуюей строке у нас снова асинхронная функция setTimeout(), чей колбек отправляется в Web API. Мы достигаем последней строки кода в funcTwo(), в консоль выводится 'Last line!'.<br> После того, как funcTwo() удаляется из стека вызовов, он оказывается пустым. Ожидающие этого в очереди задач колбеки (() =&gt; console.log('Timeout!') из funcOne() и () =&gt; console.log('Timeout!') из funcTwo()) помещаются в стек одна за другой. Первый колбек выводит в консоль 'Timeout!' и покидает стек, затем тоже самое происходит со вторым колбеком. Таким образом, мы получаем 'Last line! Promise! Promise! Last line! Timeout! Timeout!'."
    },
    {
      "id": "e0cf44ae-7a84-4da6-ab21-7822e1efba4b",
      "code": "// sum.js\nexport default function sum(x) {\n  return x + x;\n}\n\n// index.js\nimport * as sum from './sum';\n/* sum */",
      "answers": {
        "A": "A: sum(4)",
        "B": "B: sum.sum(4)",
        "C": "C: sum.default(4)",
        "D": "D: символ * может использоваться только в именованном экспорте"
      },
      "right_answer": "C",
      "details": "С помощью символа * мы импортируем все экспортируемые из файла значения, как дефолтные, так и именованные. Если у нас есть такой файл:"
    },
    {
      "id": "23406f0e-ba50-4a57-a971-0f21aa4d9ead",
      "code": "const handler = {\n    set: () => console.log('Added a new property!'),\n    get: () => console.log('Accessed a property!'),\n};\n\nconst person = new Proxy({}, handler);\n\nperson.name = 'Lydia';\nperson.name;",
      "answers": {
        "A": "A: Added a new property!",
        "B": "B: Accessed a property!",
        "C": "C: Added a new property! Accessed a property!",
        "D": "D: Nothing gets logged"
      },
      "right_answer": "C",
      "details": "С помощью прокси-объекта мы можем добавить объекту, передаваемому в качестве второго аргумента, определенное поведение. В данном случае, мы передаем объект handler, который имеет два свойства: set и get. set вызывается при установке значений, а get - при их получении. Первый аргумент прокси - пустой объект {}, который является значением person. Поведение этого объекта определено в объекте handler. При добавлении свойства объекту person вызывается set. При получении доступа к свойству person вызывается get. Сначала мы добавляем прокси-объекту новое свойство name. Вызывается set и в консоль выводится 'Added a new property!'. Затем мы получаем значение свойства name. Вызывается get и в консоль выводится 'Accessed a property!'."
    },
    {
      "id": "7359c381-44f4-40ed-a3ba-10c7d792320f",
      "code": "const person = {\n    name: 'Lydia Hallie',\n    address: {\n        street: '100 Main St',\n    },\n};\n\nObject.freeze(person);",
      "answers": {
        "A": "A: person.name = 'Evan Bacon'",
        "B": "B: delete person.address",
        "C": "C: person.address.street = '101 Main St'",
        "D": "D: person.pet = { name: 'Mara' }"
      },
      "right_answer": "С",
      "details": "Метод Object.freeze() 'замораживает' объект. Свойства не могут добавляться, изменяться или удаляться. Тем не менее, объект замораживается поверхностно. Это означает, что свойства первого уровня вложенности заморожены. Однако, в случае когда таким свойством является объект - address, его свойства не являются замороженными и их можно изменять."
    },
    {
      "id": "2d4bf3b6-179f-4fcb-9535-aca8c2813d6b",
      "code": "const add = x => x + x;\n\nfunction myFunc(num = 2, value = add(num)) {\n  console.log(num, value);\n}\n\nmyFunc();\nmyFunc(3);",
      "answers": {
        "A": "A: 2 4 and 3 6",
        "B": "B: 2 NaN and 3 NaN",
        "C": "C: 2 Error and 3 6",
        "D": "D: 2 4 and 3 Error"
      },
      "right_answer": "A",
      "details": "Сначала мы вызываем функцию myFunc() без аргументов. Поэтому аргументам присваиваются значения по умолчанию, num - 2, а value - значение функции add(). Мы передаем add() значение num в качестве аргумента, которое равняется 2. add() возвращает 4, что является значением value. Затем мы вызываем myFunc() с аргументом 3, которое присваивается num. Поскольку мы не присваиваем значения value, его значением вновь становится значение add(). Мы передаем add() значение 3, она возвращает 6, что и является значением value."
    },
    {
      "id": "14b24d67-3637-4def-af4f-01ccc7d61a31",
      "code": "class Counter {\n    #number = 10\n\n    increment() {\n        this.#number++\n    }\n\n    getNum() {\n        return this.#number\n    }\n}\n\nconst counter = new Counter()\ncounter.increment()\n\nconsole.log(counter.#number)",
      "answers": {
        "A": "A: 10",
        "B": "B: 11",
        "C": "C: undefined",
        "D": "D: SyntaxError"
      },
      "right_answer": "D",
      "details": "В ES2020 мы можем добавлять классам приватные переменные с помощью #. Мы не можем получить доступ к таким переменным за пределами класса. Поэтому, когда мы пытается вывести в консоль значение counter.#number, выбрасывается исключение SyntaxError."
    },
    {
      "id": "ca45a5fc-d217-408a-9f5f-51788700fd2a",
      "code": "const teams = [\n    { name: 'Team 1', members: ['Paul', 'Lisa'] },\n    { name: 'Team 2', members: ['Laura', 'Tim'] },\n];\n\nfunction* getMembers(members) {\n    for (let i = 0; i < members.length; i++) {\n        yield members[i];\n    }\n}\n\nfunction* getTeams(teams) {\n    for (let i = 0; i < teams.length; i++) {\n        /* ? */\n    }\n}\n\nconst obj = getTeams(teams);\nobj.next(); // { value: \"Paul\", done: false }\nobj.next(); // { value: \"Lisa\", done: false }",
      "answers": {
        "A": "A: yield getMembers(teams[i].members)",
        "B": "B: yield* getMembers(teams[i].members)",
        "C": "C: return getMembers(teams[i].members)",
        "D": "D: return yield getMembers(teams[i].members)"
      },
      "right_answer": "B",
      "details": "Для того, чтобы перебрать members в каждом элементе массива items, нам необходимо передать teams[i].members в функцию-генератор getMembers(). Генератор возвращает объект. Для того, чтобы перебрать элементы этого объекта следует использовать yield*. Если мы не укажем yield, return yield или return, внутренняя функция-генератор не будет возвращена при первом вызове метода next."
    },
    {
      "id": "46dbff28-470a-4757-8642-109c609dd2fa",
      "code": "const person = {\n    name: 'Lydia Hallie',\n    hobbies: ['coding'],\n};\n\nfunction addHobby(hobby, hobbies = person.hobbies) {\n    hobbies.push(hobby);\n    return hobbies;\n}\n\naddHobby('running', []);\naddHobby('dancing');\naddHobby('baking', person.hobbies);\n\nconsole.log(person.hobbies);",
      "answers": {
        "A": "A: ['coding']",
        "B": "B: ['coding', 'dancing']",
        "C": "C: ['coding', 'dancing', 'baking']",
        "D": "D: ['coding', 'running', 'dancing', 'baking']"
      },
      "right_answer": "C",
      "details": "Функция addHobby() принимает два аргумента, hobby и hobbies с дефолтным значением, равным свойству hobbies объекта person. Сначала мы вызываем addHobby() и передаем ей 'running' в качестве значения для hobby и пустой массив в качестве значения для hobbies. Поскольку мы передали пустой массив в качестве значения для hobbies, в него добавляется 'running'. Затем мы вызываем addHobby() и передаем ей 'dancing' в качестве значения для hobby. Мы не передаем значения для hobbies, поэтому он получает значение по умолчанию, т.е. значение свойства hobbies объекта person. Мы добавляем в этот массив 'dancing'. Наконец, мы вызываем addHobby() и передаем ей 'baking' в качестве значения для hobby и массив person.hobbies в качестве значения для hobbies. Мы добавляем 'baking' в массив person.hobbies. После добавления dancing и baking значением person.hoobies является ['coding', 'dancing', 'baking']."
    },
    {
      "id": "178466cc-0378-4d6b-afe4-242746816a42",
      "code": "class Bird {\n    constructor() {\n        console.log(\"I'm a bird. 🐤\");\n    }\n}\n\nclass Flamingo extends Bird {\n    constructor() {\n        console.log(\"I'm pink. 🌸\");\n        super();\n    }\n}\n\nconst pet = new Flamingo();",
      "answers": {
        "A": "A: I'm pink. 🌸",
        "B": "B: I'm pink. 🌸 I'm a bird. 🐤",
        "C": "C: I'm a bird. 🐤 I'm pink. 🌸",
        "D": "D: Ничего."
      },
      "right_answer": "B",
      "details": "Мы создаем переменную pet, которая является экземпляром класса Flamingo. При создании экземпляра вызывается constructor(). В консоль выводится 'I'm pink. 🌸', после чего вызывается super(). super() вызывает конструктор родительского класса. В консоль выводится 'I'm a bird. 🐤'."
    },
    {
      "id": "b1fe4f6d-3402-4f24-8ba4-a7dd295ae9da",
      "code": "const person = {\n    name: \"Lydia Hallie\",\n    age: 21\n}\n\n[...person] // [\"Lydia Hallie\", 21]",
      "answers": {
        "A": "A: Объекты являются итерируемыми по умолчанию",
        "B": "B: *[Symbol.iterator]() { for (let x in this) yield* this[x] }",
        "C": "C: *[Symbol.iterator]() { yield* Object.values(this) }",
        "D": "D: *[Symbol.iterator]() { for (let x in this) yield this }"
      },
      "right_answer": "C",
      "details": "Объекты не являются итерируемыми по умолчанию. В итерируемых сущностях имеется протокол итератора. Мы можем сделать это вручную, добавив символ итератора [Symbol.iterator], который будет возвращать объект-генератор, например, сделав исходный объект функцией-генератором *[Symbol.iterator]() {}. Эта функция-генератор должна перебирать Object.values объекта person, если мы хотим вернуть массив ['Lydia Hallie', 21]: yield* Object.values(this)."
    },
    {
      "id": "fb5f95b4-328e-4f01-af36-63c963cefd33",
      "code": "let count = 0;\nconst nums = [0, 1, 2, 3];\n\nnums.forEach(num => {\n    if (num) count += 1\n})\n\nconsole.log(count)",
      "answers": {
        "A": "A: 1",
        "B": "B: 2",
        "C": "C: 3",
        "D": "D: 4"
      },
      "right_answer": "C",
      "details": "Условие if в цикле forEach проверяет, является ли значение num истинным. Поскольку первым значением num является 0, который является ложным, код в блоке if не выполняется. Остальные значения num (1, 2, 3) являются истинными, поэтому counter увеличивается на 1 три раза. В результате значением counter является 3."
    },
    {
      "id": "2efa7b2b-7623-4057-ae44-ec71ef58e524",
      "code": "function getFruit(fruits) {\n\tconsole.log(fruits?.[1]?.[1])\n}\n\ngetFruit([['🍊', '🍌'], ['🍍']])\ngetFruit()\ngetFruit([['🍍'], ['🍊', '🍌']])",
      "answers": {
        "A": "A: null, undefined, 🍌",
        "B": "B: [], null, 🍌",
        "C": "C: [], [], 🍌",
        "D": "D: undefined, undefined, 🍌"
      },
      "right_answer": "D",
      "details": "Оператор ?. позволяет нам получать опциональный доступ к глубоко вложенным свойствам объектов. Мы пытаемся вывести в консоль элемент с индексом 1 подмассива с индексом 1 массива fruits. Если подмассив с индексом 1 в массиве fruits не существует, возвращается undefined. Если подмассив с индексом 1 в массиве fruits существует, но не имеет элемента с индексом 1, также возвращается undefined. Сначала мы пытаемся вывести в консоль второй элемент подмассива ['🍍'] массива [['🍊', '🍌'], ['🍍']]]. Этот подмассив состоит из одного элемента, т.е. элемента с индексом 1 не существует, поэтому возвращается undefined. Затем мы вызываем функцию getFruits() без аргументов, поэтому массив fruits имеет значение undefined по умолчанию. Наконец, мы пытаемся вывести в консоль второй элемент подмассива ['🍊', '🍌'] массива ['🍍'], ['🍊', '🍌']. Элементом с индексом 1 этого подмассива является 🍌, который и выводится в консоль."
    },
    {
      "id": "e8482b93-bd43-4ee9-9f8a-5bca293f8008",
      "code": "class Calc {\n\tconstructor() {\n\t\tthis.count = 0\n\t}\n\n\tincrease() {\n\t\tthis.count++\n\t}\n}\n\nconst calc = new Calc()\nnew Calc().increase()\n\nconsole.log(calc.count)",
      "answers": {
        "A": "A: 0",
        "B": "B: 1",
        "C": "C: undefined",
        "D": "D: ReferenceError"
      },
      "right_answer": "A",
      "details": "Мы присваиваем переменной calc значение нового экземпляра класса Calc. Затем мы инициализируем новый экземпляр класса Calc и вызываем метод increase() этого экземпляра. Поскольку свойство count находится в конструкторе класса Calc, данное свойство не является общим для экземпляров класса Calc. Это означает, что свойство count не обновляется для экземпляра calc, оно по-прежнему равняется 0."
    },
    {
      "id": "8f702b6c-d852-4162-bcaf-888e698da11b",
      "code": "const user = {\n\temail: \"e@mail.com\",\n\tpassword: \"12345\"\n}\n\nconst updateUser = ({ email, password }) => {\n\tif (email) {\n        Object.assign(user, { email })\n\t}\n\n\tif (password) {\n        user.password = password\n\t}\n\n\treturn user\n}\n\nconst updatedUser = updateUser({ email: \"new@email.com\" })\n\nconsole.log(updatedUser === user)",
      "answers": {
        "A": "A: false",
        "B": "B: true",
        "C": "C: TypeError",
        "D": "D: ReferenceError"
      },
      "right_answer": "B",
      "details": "Функция updateUser() обновляет свойства email и password объекта user, если их значения переданы в качестве аргументов, после чего функция возвращает объект user. Значение, которое вернула updateUser(), это объект user. Таким образом, переменная updatedUser ссылается на тот же объект user, на который ссылается сам user. Поэтому updatedUser === user возвращает true."
    },
    {
      "id": "95c56e83-f2b2-4267-b98a-2d8a0c867374",
      "code": "const fruits = ['🍌', '🍊', '🍎']\n\nfruits.slice(0, 1)\nfruits.splice(0, 1)\nfruits.unshift('🍇')\n\nconsole.log(fruits)",
      "answers": {
        "A": "A: ['🍌', '🍊', '🍎']",
        "B": "B: ['🍊', '🍎']",
        "C": "C: ['🍇', '🍊', '🍎']",
        "D": "D: ['🍇', '🍌', '🍊', '🍎']"
      },
      "right_answer": "C",
      "details": "Сначала мы вызываем метод slice() для массива fruits. Данный метод не модифицирует исходный массив, но возвращает извлеченное значение: '🍌'. Затем мы вызываем метод splice(). Данный метод модифицирует исходный массив, fruits теперь состоит из ['🍊', '🍎']. Наконец, мы вызываем метод unshift(), который модифицирует исходный массив, добавляя '🍇' в качестве первого элемента. Массив fruits теперь состоит из ['🍇', '🍊', '🍎']."
    },
    {
      "id": "66080e5e-0388-46e4-93cd-0432ab7dd5e8",
      "code": "const animals = {};\nlet dog = { emoji: '🐶' }\nlet cat = { emoji: '🐈' }\n\nanimals[dog] = { ...dog, name: \"Mara\" }\nanimals[cat] = { ...cat, name: \"Sara\" }\n\nconsole.log(animals[dog])",
      "answers": {
        "A": "A: { emoji: '🐶', name: 'Mara' }",
        "B": "B: { emoji: '🐈', name: 'Sara' }",
        "C": "C: undefined",
        "D": "D: ReferenceError"
      },
      "right_answer": "B",
      "details": "Ключи объекта конвертируются (преобразуются) в строки. Поскольку значением dog является объект, animals[dog] на самом деле означает, что мы создаем новое свойство с именем 'object Object', значением которого является новый объект. animals['object Object'] равняется { emoji: '🐶', name: 'Mara'}. Значением cat также является объект. Это означает, что мы перезаписываем свойство animals['object Object'] новым значением. Поэтому, когда мы выводим в консоль animals[dog], мы на самом деле выводим animals['object Object'], поэтому выводится { emoji: '🐈', name: 'Sara' }."
    },
    {
      "id": "1a18e170-86a7-497f-a142-403ec5ae8f39",
      "code": "const user = {\n\temail: \"my@email.com\",\n\tupdateEmail: email => {\n\t\tthis.email = email\n\t}\n}\n\nuser.updateEmail(\"new@email.com\")\nconsole.log(user.email)",
      "answers": {
        "A": "A: my@email.com",
        "B": "B: new@email.com",
        "C": "C: undefined",
        "D": "D: ReferenceError"
      },
      "right_answer": "A",
      "details": "Функция updateEmail() является стрелочной, поэтому она не привязана к объекту user. Это означает, что ключевое слово this не ссылается на объект user, в данном случае оно ссылается на глобальную область видимости (window в браузере, global в Node.js). Значение свойства email объекта user не обновляется. Поэтому, когда мы выводим в консоль значение user.email, выводится my@email.com."
    },
    {
      "id": "c0f8a7e6-f206-483d-acb1-77baad701866",
      "code": "const promise1 = Promise.resolve('First')\nconst promise2 = Promise.resolve('Second')\nconst promise3 = Promise.reject('Third')\nconst promise4 = Promise.resolve('Fourth')\n\nconst runPromises = async () => {\n\tconst res1 = await Promise.all([promise1, promise2])\n\tconst res2  = await Promise.all([promise3, promise4])\n\treturn [res1, res2]\n}\n\nrunPromises()\n\t.then(res => console.log(res))\n\t.catch(err => console.log(err))",
      "answers": {
        "A": "A: [['First', 'Second'], ['Fourth']]",
        "B": "B: [['First', 'Second'], ['Third', 'Fourth']]",
        "C": "C: [['First', 'Second']]",
        "D": "D: 'Third'"
      },
      "right_answer": "D",
      "details": "Метод Promise.all() выполняет переданные ему промисы одновременно. Если один из промисов отклоняется, Promise.all также отклоняется со значением отклоненного промиса. В данном случае, promise3 отклоняется со значением 'Third'. Мы перехватываем отклоненное значение в методе catch вызова функции runPromises(). Поэтому в консоль выводится только 'Third'."
    },
    {
      "id": "8e987e5e-a1da-40dd-ab28-50a2ba4bcf8f",
      "code": "const keys = [\"name\", \"age\"]\nconst values = [\"Lydia\", 22]\n\nconst method = /* ? */\n\nObject[method](keys.map((_, i) => {\n\treturn [keys[i], values[i]]\n})) // { name: \"Lydia\", age: 22 }",
      "answers": {
        "A": "A: entries",
        "B": "B: values",
        "C": "C: fromEntries",
        "D": "D: forEach"
      },
      "right_answer": "C",
      "details": "Метод fromEntries() преобразует двумерный массив в объект. Первый элемент каждого подмассива становится ключом, а второй элемент - значением. В данном случае, мы перебираем элементы массива keys, возвращая массив, первым элементом которого является элемент массива keys с текущим индексом, вторым элементом - элемент массива values с текущим индексом. Это создает массив массивов с правильными ключами и значениями, которые преобразуются в { name: 'Lydia', age: 22 }."
    },
    {
      "id": "99a657f0-d20a-4e72-afb6-429a40d69cc5",
      "code": "const createMember = ({ email, address = {}}) => {\n\tconst validEmail = /.+@.+..+/.test(email)\n\tif (!validEmail) throw new Error(\"Valid email pls\")\n\n\treturn {\n\t\temail,\n\t\taddress: address ? address : null\n\t}\n}\n\nconst member = createMember({ email: \"my@email.com\" })\nconsole.log(member)",
      "answers": {
        "A": "A: { email: 'my@email.com', address: null }",
        "B": "B: { email: 'my@email.com' }",
        "C": "C: { email: 'my@email.com', address: {} }",
        "D": "D: { email: 'my@email.com', address: undefined }"
      },
      "right_answer": "C",
      "details": "Значением address по умолчанию является пустой объект {}. Когда мы присваиваем переменной member значение функции createMember(), мы не передаем значение для address, поэтому значением address становится {}. Пустой объект - это истинное значение, поэтому условие address ? address : null возвращает true. Значением address является {}."
    },
    {
      "id": "6d7c3601-9e0a-43d7-ad24-9ead0dd3cee7",
      "code": "let randomValue = { name: \"Lydia\" }\nrandomValue = 23\n\nif (!typeof randomValue === \"string\") {\n\tconsole.log(\"Это не строка!\")\n} else {\n\tconsole.log(\"Это строка!\")\n}",
      "answers": {
        "A": "A: Это не строка!",
        "B": "B: Это строка!",
        "C": "C: TypeError",
        "D": "D: undefined"
      },
      "right_answer": "B",
      "details": "Условие if проверяет, является ли !typeof random value строкой. Оператор ! преобразует значение в логический тип данных. Если значение истинно, возвращается false, если ложно - true. В данном случае, значением typeof randomValue является 'number', что есть истина, поэтому возвращается false. !typeof randomValue === 'string' возвращает false, поскольку на самом деле мы проверяем false === 'string'. Условие возвращает false, поэтому выполняется код в блоке else и в консоль выводится 'Это строка!'."
    },
    {
      "id": "d4b8d217-ea8d-4c71-921f-3c844a43ba36",
      "code": "var car = new Vehicle(\"Honda\", \"white\", \"2010\", \"UK\");\nconsole.log(car);\n\nfunction Vehicle(model, color, year, country) {\n    this.model = model;\n    this.color = color;\n    this.year = year;\n    this.country = country;\n}",
      "answers": {
        "A": "A: undefined",
        "B": "B: error",
        "C": "C: null",
        "D": "D: {model: 'Honda', color: 'white', year: '2010', country: 'UK'}"
      },
      "right_answer": "D",
      "details": "Объявления функций поднимаются подобно объявлениям переменных. Поэтому место объявления функции 'Venicle()' не имеет значения."
    },
    {
      "id": "7307f410-1051-427a-bfeb-f4f67ab5883f",
      "code": "function foo() {\n    let x = y = 0;\n    x++;\n    y++;\n    return x;\n}\n\nconsole.log(foo(), typeof x, typeof y);",
      "answers": {
        "A": "A: 1 undefined undefined",
        "B": "B: error",
        "C": "C: 1 undefined number",
        "D": "D: 1 number number"
      },
      "right_answer": "C",
      "details": "Функция 'foo()' возвращает 1 из-за оператора '++'. Выражение 'let x = y = 0' определяет локальную переменную 'x'. Однако 'y' определяется как глобальная переменная. Данное выражение эквивалентно следующему:"
    },
    {
      "id": "2a11ba5d-cac7-498d-8a70-8d2008a8d934",
      "code": "function main() {\n    console.log('A')\n    setTimeout(function print() {\n        console.log('B')\n    }, 0)\n    console.log('C')\n}\n\nmain()",
      "answers": {
        "A": "A: A B C",
        "B": "B: B A C",
        "C": "C: A C",
        "D": "D: A C B"
      },
      "right_answer": "D",
      "details": "Порядок выполнения функций зависит от стека вызовов. В данном случае, он будет следующим: <br> 1. Сначала в стек помещается функция 'main()'. <br> 2. Затем в стек помещается console.log('A'), выполняется и удаляется из стека. <br> 3. Далее 'setTimeot()' отправляется в Web API, а оставшийся код выполняется дальше. <br> 4. В стек помещается console.log('C'), выполняется и удаляется из стека. <br> 5. Колбек счетчика помещается в очередь задач. <br> 6. Функция 'main()' удаляется из стека. <br> 7. Поскольку стек опустел, в него помещается колбек из очереди. <br> 8. В стек помещается console.log('B'), выполняется и удаляется из стека."
    },
    {
      "id": "069b7638-e96a-459e-80e6-e856e0de3bd2",
      "code": "console.log(0.1 + 0.2 === 0.3)",
      "answers": {
        "A": "A: false",
        "B": "B: true",
        "C": "C: undefined",
        "D": "D: SyntaxError"
      },
      "right_answer": "A",
      "details": "Здесь мы имеем дело с распространенной проблемой чисел с плавающей точкой. Поскольку такие числа преобразуются в двоичные данные, имеет место некоторая неточность округления. Поэтому сравнение названных чисел порой приводит к неожиданным результатам. В частности, значением выражения '0.1 + 0.2' будет 0.30000000000000004, что чуть больше, чем 0.3."
    },
    {
      "id": "d232aaad-11e1-4666-b663-83fa04cf090b",
      "code": "var y = 1;\nif (function f(){}) {\n    y += typeof f;\n}\nconsole.log(y);",
      "answers": {
        "A": "A: 1function",
        "B": "B: 1object",
        "C": "C: error",
        "D": "D: 1undefined"
      },
      "right_answer": "D",
      "details": "if возвращает true. Поскольку переменная 'f' нигде не определяется, она имеет значением 'undefined' по умолчанию с типом 'undefined'."
    },
    {
      "id": "7e987afc-dd9d-4669-bca5-5e1430a721c5",
      "code": "function foo() {\nreturn\n    {\n        message: \"Hello World\"\n    };\n}\nconsole.log(foo());",
      "answers": {
        "A": "A: Hello World",
        "B": "B: Object {message: 'Hello World'}",
        "C": "C: undefined",
        "D": "D: error"
      },
      "right_answer": "D",
      "details": "Здесь мы имеем дело с автоматической расстановкой точек с запятой. В данном случае, точка с запятой автоматически вставляется после оператора 'return'. Поэтому функция возвращает 'undefined'. <br> Если поставить '{' перед return, то функция будет работать как ожидается:"
    },
    {
      "id": "67cd148d-f069-41e0-8c10-7627de31974c",
      "code": "var myChars = ['a', 'b', 'c', 'd']\ndelete myChars[0];\nconsole.log(myChars);\nconsole.log(myChars[0]);\nconsole.log(myChars.length);",
      "answers": {
        "A": "A: [empty, 'b', 'c', 'd'], empty, 3",
        "B": "B: [null, 'b', 'c', 'd'], empty, 3",
        "C": "C: [empty, 'b', 'c', 'd'], undefined, 4",
        "D": "D: [null, 'b', 'c', 'd'], undefined, 4"
      },
      "right_answer": "C",
      "details": "Оператор 'delete' удаляет свойства объекта, но не индексы массива. Другими словами, удаляется только значение массива по указанному индексу, сам индекс остается, его значением становится 'undefined'. Поэтому количество элементов в массиве или его длина сохраняется."
    },
    {
      "id": "8b165876-acb8-4dac-a8bc-e423d931d00e",
      "code": "var array1 = new Array(3);\nconsole.log(array1);\n\nvar array2 = [];\narray2[2] = 100;\nconsole.log(array2);\n\nvar array3 = [,,,];\nconsole.log(array3);",
      "answers": {
        "A": "A: [undefined × 3], [undefined × 2, 100], [undefined × 3]",
        "B": "B: [empty × 3], [empty × 2, 100], [empty × 3]",
        "C": "C: [null × 3], [null × 2, 100], [null × 3]",
        "D": "D: [], [100], []"
      },
      "right_answer": "C",
      "details": "На самом деле то, что будет выведено в консоль, зависит от браузера. Например, последние версии Chrome выводят 'empty x n', а старые выводили 'undefined x n'. В Firefox выводится 'n empty slots'."
    },
    {
      "id": "b8b2ac3c-5bc4-4e27-9f48-db9bb46948be",
      "code": "const obj = {\n    prop1: function() { return 0 },\n    prop2() { return 1 },\n    ['prop' + 3]() { return 2 }\n}\n\nconsole.log(obj.prop1());\nconsole.log(obj.prop2());\nconsole.log(obj.prop3());",
      "answers": {
        "A": "A: 0, 1, 2",
        "B": "B: 0, { return 1 }, 2",
        "C": "C: 0, { return 1 }, { return 2 }",
        "D": "D: 0, 1, undefined"
      },
      "right_answer": "A",
      "details": "ES6, среди прочего, представил новые способы определения методов и сокращения свойств объекта. Поэтому 'prop2' и 'prop3' обрабатываются как обычные функции."
    },
    {
      "id": "23f8226e-25c7-4bd2-a37a-c5cb7a72ff30",
      "code": "console.log(1 < 2 < 3);\nconsole.log(3 > 2 > 1);",
      "answers": {
        "A": "A: true, true",
        "B": "B: true, false",
        "C": "C: error",
        "D": "D: false, false"
      },
      "right_answer": "B",
      "details": "Если в if содержатся одинаковые операторы, то выражение оценивается слева направо. Для первого выражения порядок будет следующим:"
    },
    {
      "id": "91686aa3-ee41-4eac-87ce-976e13b3f093",
      "code": "// код выполняется в нестрогом режиме\nfunction printNumbers (first, second, first) {\n    console.log(first, second, first);\n}\nprintNumbers(1, 2, 3);",
      "answers": {
        "A": "A: 1, 2, 3",
        "B": "B: 3, 2, 3",
        "C": "C: error",
        "D": "D: 1, 2, 1"
      },
      "right_answer": "B",
      "details": "В нестрогом режиме дублирующиеся параметры в обычных функциях разрешены. В приведенном примере дублирующимися являются параметры 1 и 3. Первый параметр указывает на третий аргумент, передаваемый функции. Поэтому третий аргумент перезаписывает первый параметр. Обратите внимание, что в строгом режиме возникнет ошибка."
    },
    {
      "id": "fdb3207a-7a8c-4632-86ca-b3d19a3ffd58",
      "code": "// код выполняется в нестрогом режиме\nconst printNumbersArrow = (first, second, first) => {\n    console.log(first, second, first);\n}\nprintNumbersArrow(1, 2, 3);",
      "answers": {
        "A": "A: 1, 2, 3",
        "B": "B: 3, 2, 3",
        "C": "C: error",
        "D": "D: 1, 2, 1"
      },
      "right_answer": "C",
      "details": "В отличие от обычных, в стрелочных функциях дублирующиеся параметры запрещены независимо от режима выполнения кода. Поэтому в данном случае будет вырошено исключение SyntaxError: Duplicate parameter name not allowed in this context."
    },
    {
      "id": "c1257eff-0278-4dbb-8757-0e0d80da7393",
      "code": "const f = () => arguments.length;\nconsole.log(f(1, 2, 3));",
      "answers": {
        "A": "A: ReferenceError: arguments is not defined",
        "B": "B: 3",
        "C": "C: undefined",
        "D": "D: null"
      },
      "right_answer": "A",
      "details": "Стрелоные функции не имеют arguments, this, super и new.target. Поэтому любое обращение к arguments приводит к поиску переменной с таким названием в лексическом окружении функции. В данном случае, переменной 'arguments' не существует. Поэтому возникает ошибка.<br> В обычных функциях arguments - это массивоподобный объект, содержащий переданные функции аргументы:"
    },
    {
      "id": "0adc9c26-d33f-458d-a312-241d45cd2b07",
      "code": "console.log( String.prototype.trimLeft.name === 'trimLeft' );\nconsole.log( String.prototype.trimLeft.name === 'trimStart' );",
      "answers": {
        "A": "A: true false",
        "B": "B: false true",
        "C": "C: undefined",
        "D": "D: null"
      },
      "right_answer": "B",
      "details": "По аналогии с String.prototype.padStart стандартный метод для удаления пробелов в начале строки был назван 'trimStart'. Однако для обеспечения обратной совместимости название 'trimLeft' было сохранено в качестве алиаса для 'trimStart'. Однако, прототипом trimLeft является trimStart."
    },
    {
      "id": "88b3908d-1bb7-43ec-a793-9aa90c464d39",
      "code": "console.log(Math.max());",
      "answers": {
        "A": "A: undefined",
        "B": "B: Infinity",
        "C": "C: 0",
        "D": "D: -Infinity"
      },
      "right_answer": "D",
      "details": "-Infinity - это наименьшее сравниваемое значение, поскольку почти любое другое значение в JavaScript больше него. Поэтому, когда метод 'Math.max()' вызывается без аргументов, возвращается -Infinity."
    },
    {
      "id": "3825ef76-4f9f-4ef7-9e23-3c6142048656",
      "code": "console.log(10 === [10]);\nconsole.log(10 === [[[[[[[10]]]]]]]);",
      "answers": {
        "A": "A: true true",
        "B": "B: true false",
        "C": "C: false false",
        "D": "D: false true"
      },
      "right_answer": "A",
      "details": "Согласно спецификации приведенные выражения будут преобразованы следующим образом:"
    },
    {
      "id": "20c00424-3869-46d2-a285-943f3723db2e",
      "code": "console.log(10 + '10');\nconsole.log(10 - '10');",
      "answers": {
        "A": "A: 20 0",
        "B": "B: 1010 0",
        "C": "C: 1010 10-10",
        "D": "D: NaN NaN"
      },
      "right_answer": "B",
      "details": "Оператор '+' применяется как к числам, так и к строкам. Если одним из операндов является строка, тогда оба операнда объединяются как строки. Оператор '-' пытается преобразовать операнды в число."
    },
    {
      "id": "c9425ea0-b4b8-416c-9359-2523f9205b4f",
      "code": "console.log([1, 2] + [3, 4]);",
      "answers": {
        "A": "A: [1,2,3,4]",
        "B": "B: [1,2][3,4]",
        "C": "C: error",
        "D": "D: 1,23,4"
      },
      "right_answer": "D",
      "details": "Оператор '+' не предназначен для сложения массивов. Поэтому массивы преобразуются в строки и объединяются."
    },
    {
      "id": "c8c59db8-bbe2-47b0-ade4-031a2637626e",
      "code": "const numbers = new Set([1, 1, 2, 3, 4]);\nconsole.log(numbers);\n\nconst browser = new Set('Firefox');\nconsole.log(browser);",
      "answers": {
        "A": "A: {1, 2, 3, 4} {'F', 'i', 'r', 'e', 'f', 'o', 'x'}",
        "B": "B: {1, 2, 3, 4} {'F', 'i', 'r', 'e', 'o', 'x'}",
        "C": "C: [1, 2, 3, 4] ['F', 'i', 'r', 'e', 'o', 'x']",
        "D": "D: {1, 1, 2, 3, 4} {'F', 'i', 'r', 'e', 'f', 'o', 'x'}"
      },
      "right_answer": "A",
      "details": "Set - это объект, представляющий собой коллекцию уникальных значений, поэтому повторяющиеся значения исключаются. В тоже время данный объяект является чуствительным к регистру, поэтому в коллекцию записываются и 'F', и 'f'."
    },
    {
      "id": "29e6c8d1-8cd9-49b7-b794-5badfa53c8d9",
      "code": "console.log(NaN === NaN);",
      "answers": {
        "A": "A: true",
        "B": "B: false",
        "C": "C: error",
        "D": "D: undefined"
      },
      "right_answer": "B",
      "details": "NaN согласно стандарту IEEE 754 не равен никакому другому значению, включая NaN."
    },
    {
      "id": "45da4126-ae87-4c2f-848a-123620dc8a2a",
      "code": "const numbers = [1, 2, 3, 4, NaN];\nconsole.log(numbers.indexOf(NaN));",
      "answers": {
        "A": "A: 4",
        "B": "B: NaN",
        "C": "C: error",
        "D": "D: -1"
      },
      "right_answer": "D",
      "details": "indexOf() использует оператор строгого равенства (===), а поскольку NaN не равен никокому другому значению, включая NaN, выражение 'NaN === NaN' возвращает false. indexOf() не может найти NaN в массиве, возвращается -1. Для поиска индекса NaN можно использовать метод 'findIndex()'. Также для проверки наличия NaN в массиве можно использовать метод 'includes()':"
    },
    {
      "id": "fb9a1da0-9f65-4943-a5da-1ebc272ed591",
      "code": "const [a, ...b,] = [1, 2, 3, 4, 5];\nconsole.log(a, b);",
      "answers": {
        "A": "A: 1 [2, 3, 4, 5]",
        "B": "B: 1 {2, 3, 4, 5}",
        "C": "C: SyntaxError: Rest element must be last element",
        "D": "D: 1 [2, 3, 4]"
      },
      "right_answer": "C",
      "details": "При использовании оператора 'rest' (прочие параметры, ...), данный оператор передается в качестве последнего аргумента. В данном случае, использование замыкающей запятой (trailing comma) приводит к возникновению ошибки. Если удалить запятую, то все будет в порядке:<br>"
    },
    {
      "id": "2f25505b-f2ed-48c2-8ce9-b58772d873ce",
      "code": "async function func() {\n    return 10;\n}\nconsole.log(func());",
      "answers": {
        "A": "A: Promise {: 10}",
        "B": "B: 10",
        "C": "C: error",
        "D": "D: Promise {: undefined}"
      },
      "right_answer": "A",
      "details": "Асинхронная функция всегда возвращает промис. Даже если возвращаемое такой функцией значение само по себе не является промисом, оно будет завернуто в промис. Приведенный пример эквивалентен следующему:"
    },
    {
      "id": "4e4a3039-6a73-44d6-acf8-5cb086fbf13b",
      "code": "async function func() {\n    await 10;\n}\nconsole.log(func());",
      "answers": {
        "A": "A: Promise {: 10}",
        "B": "B: 10",
        "C": "C: error",
        "D": "D: Promise {: undefined}"
      },
      "right_answer": "A",
      "details": "await возвращает Promise {: 10}, который может быть обработан с помощью then(). В данном случае, функция не содержит return, т.е. не возвращает значения. Поэтому возвращается undefined. Приведенный пример эквивалентен следующему:"
    },
    {
      "id": "c604d2e9-9252-4120-a7d9-79199aa108bc",
      "code": "function delay() {\n    return new Promise(resolve => setTimeout(resolve, 2000));\n}\n\nasync function delayedLog(item) {\n    await delay();\n    console.log(item);\n}\n\nasync function processArray(array) {\n    array.forEach(item => {\n        await delayedLog(item);\n    })\n}\n\nprocessArray([1, 2, 3, 4]);",
      "answers": {
        "A": "A: error",
        "B": "B: 1, 2, 3, 4",
        "C": "C: 4, 4, 4, 4",
        "D": "D: 4, 3, 2, 1"
      },
      "right_answer": "A",
      "details": "Несмотря на то, что processArray - это асинхронная функция, анонимная функция, которую мы используем в forEach, является синхронной. Использование ключевого слова 'await' в синхронных функциях приводит к выбрасыванию исключения SyntaxError: await is only valid in async function."
    },
    {
      "id": "9dd46fbf-adf7-4127-b2f2-3d579735cfb2",
      "code": "function delay() {\n    return new Promise(resolve => setTimeout(resolve, 2000));\n}\n\nasync function delayedLog(item) {\n    await delay();\n    console.log(item);\n}\n\nasync function process(array) {\n    array.forEach(async (item) => {\n        await delayedLog(i);\n    });\n    console.log('Process completed!');\n}\n\nprocess([1, 2, 3, 5]);",
      "answers": {
        "A": "1: 1 2 3 5 Process completed!",
        "B": "2: 5 5 5 5 Process completed!",
        "C": "3: Process completed! 5 5 5 5",
        "D": "4: Process completed! 1 2 3 5"
      },
      "right_answer": "D",
      "details": "Метод 'forEach' не ожидает завершения операции, он лишь запускает ее выполнение и двигается дальше. Поэтому console.log('Process finished!') выполняется первым согласно последовательности разрешения промисов.<br> Определить нужную последовательность можно с помощью оператора for-of:<br>"
    },
    {
      "id": "77e43fd9-4e5d-4f0a-9f4d-f482bd071384",
      "code": "var set = new Set();\nset.add(\"+0\")\n    .add(\"-0\")\n        .add(NaN)\n            .add(undefined)\n                .add(NaN);\n\nconsole.log(set);",
      "answers": {
        "A": "A: Set(4) {'+0', '-0', NaN, undefined}",
        "B": "B: Set(3) {'+0', NaN, undefined}",
        "C": "C: Set(5) {'+0', '-0', NaN, undefined, NaN}",
        "D": "D: Set(4) {'+0', NaN, undefined, NaN}"
      },
      "right_answer": "A",
      "details": "В отличии от операторов равенства (==, ===), для Set все NaN являются одинаковыми значениями, а +0 и -0 - разными."
    },
    {
      "id": "d97b481e-b848-4eb7-8220-08f8d1faca06",
      "code": "const sym1 = Symbol('one');\nconst sym2 = Symbol('one');\n\nconst sym3 = Symbol.for('two');\nconst sym4 = Symbol.for('two');\n\nconsole.log(sym1 === sym2, sym3 === sym4);",
      "answers": {
        "A": "A: true true",
        "B": "B: true false",
        "C": "C: false true",
        "D": "D: false false"
      },
      "right_answer": "C",
      "details": "Для символом характерно следующее:<br> 1. Каждый символ, возвращаемый Symbol(), это уникальное значение. Строка, передаваемая Symbol(), это лишь опциональная метка или описание символа, которая, обычно, используется в целях отладки кода.<br> 2. Метод 'Symbol.for()' создает символ в глобальном реестре символов. При каждом вызове данного метода проверяется, имеется ли символ с указанным ключом в реестре. После этого либо возвращается найденный символ, либо создается новый."
    },
    {
      "id": "1442e89b-ed25-4493-8798-2b0ba216855c",
      "code": "const sym1 = new Symbol('one');\nconsole.log(sym1);",
      "answers": {
        "A": "A: error",
        "B": "B: one",
        "C": "C: Symbol('one')",
        "D": "D: Symbol"
      },
      "right_answer": "A",
      "details": "Symbol - это обычная функция, а не конструктор, в отличие, например, от Number или String. Поэтому при попытке использования его с ключевым словом 'new' выбрасывается исключение TypeError: Symbol is not a constructor."
    },
    {
      "id": "b35a2f6a-8b5c-4011-a764-fd94d6383b53",
      "code": "let myNumber = 100;\nlet myString = '100';\n\nif (!typeof myNumber === \"string\") {\n    console.log(\"It is not a string!\");\n} else {\n    console.log(\"It is a string!\");\n}\n\nif (!typeof myString === \"number\"){\n    console.log(\"It is not a number!\")\n} else {\n    console.log(\"It is a number!\");\n}",
      "answers": {
        "A": "A: error",
        "B": "B: It is not a string! It is not a number!",
        "C": "C: It is not a string! It is a number!",
        "D": "D: It is a string! It is a number!"
      },
      "right_answer": "D",
      "details": "Оператор '!' приводит значение к логическому типу. Поскольку выражения 'typeof myNumber' и 'typeof myString' истинные, в обоих случаях возвращается false. Далее выполняются блоки 'else'."
    },
    {
      "id": "48c4edbc-3d3e-44fc-be2c-9e1309126f13",
      "code": "console.log(JSON.stringify({ myArray: ['one', undefined, function() {}, Symbol('')] }));\nconsole.log(JSON.stringify({ [Symbol.for('one')]: 'one' }, [Symbol.for('one')]));",
      "answers": {
        "A": "A: {'myArray':['one', undefined, {}, Symbol]}, {}",
        "B": "B: {'myArray':['one', null, null, null]}, {}",
        "C": "C: {'myArray':['one', null, null, null]}, '{ [Symbol.for('one')]: 'one' }, [Symbol.for('one')]'",
        "D": "D: {'myArray':['one', undefined, function(){}, Symbol('')]}, {}"
      },
      "right_answer": "B",
      "details": "undefined, функции и символы не являются валидными JSON-значениями. Такие значения не включаются в объект и конвертируются в null в массиве. Поэтому возвращается null, null, null.<br> Глобальные символы игнорируются, поэтому возвращается пустой объект ({})."
    },
    {
      "id": "e6928316-c6a5-44bd-aa65-18cf9e949296",
      "code": "class A {\n    constructor() {\n        console.log(new.target.name)\n    }\n}\n\nclass B extends A { constructor() { super() } }\n\nnew A();\nnew B();",
      "answers": {
        "A": "A: A A",
        "B": "B: A B",
        "C": "C: B B",
        "D": "D: error"
      },
      "right_answer": "B",
      "details": "new.target ссылается на конструктор (указывает на определение инициализируемого класса), который вызывается с помощью new. Это также справедливо для конструктора родительского класса, делегированного из дочернего конструктора."
    },
    {
      "id": "92193fbf-c46e-4839-9a9c-5033316f56db",
      "code": "const {a: x = 10, b: y = 20} = {a: 30};\n\nconsole.log(x);\nconsole.log(y);",
      "answers": {
        "A": "A: 30 20",
        "B": "B: 10 20",
        "C": "C: 10 undefined",
        "D": "D: 30 undefined"
      },
      "right_answer": "A",
      "details": "Для свойств объекта характерно следующее:<br> 1. Значение свойства (30) может быть извлечено и присвоено переменной (x).<br> 2. Свойству присваивается значение по умолчанию (20), когда извлекаемым значением является undefined (y)."
    },
    {
      "id": "d7fcd5a9-ffde-4936-a71b-4a4fbbb63ecf",
      "code": "function area({ length = 10, width = 20 }) {\n    console.log(length * width);\n}\n\narea();",
      "answers": {
        "A": "A: 200",
        "B": "B: error",
        "C": "C: undefined",
        "D": "D: 0"
      },
      "right_answer": "B",
      "details": "Здесь мы имеем дело с деструктуризацией объекта. Если опустить правую часть выражения, функция при вызове попытается найти хотя бы один аргумент. Если ей не удастся этого сделать, будет выброшено исключение TypeError: Cannot read property 'length' of undefined.<br> Решить данную проблему можно следующими способами:<br> 1. Передать функции пустой объект в качестве аргумента:<br>"
    },
    {
      "id": "5c8bd58a-e08b-4761-ae18-a4826893d2ed",
      "code": "const props = [\n    { id: 1, name: 'John'},\n    { id: 2, name: 'Jack'},\n    { id: 3, name: 'Tom'}\n];\n\nconst [, , { name }] = props;\nconsole.log(name);",
      "answers": {
        "A": "A: Tom",
        "B": "B: Error",
        "C": "C: undefined",
        "D": "D: John"
      },
      "right_answer": "A",
      "details": "Деструктуризацию массива и объекта можно комбинировать. В данном случае переменной 'name' присваивается значение соответствующего свойства третьего элемента массива 'props'."
    },
    {
      "id": "20415684-cf64-4700-a43b-b0f7f49b1423",
      "code": "function checkType(num = 1) {\n    console.log(typeof num);\n}\n\ncheckType();\ncheckType(undefined);\ncheckType('');\ncheckType(null);",
      "answers": {
        "A": "A: number, undefined, string, object",
        "B": "B: undefined, undefined, string, object",
        "C": "C: number, number, string, object",
        "D": "D: number, number, number, number"
      },
      "right_answer": "C",
      "details": "Если функции не передается значение или передается undefined, аргумент принимает значение по умолчанию (1). Другие ложные значения ('' и null) присваиваются аргументу.<br> Первые два вызова функции возвращают number, поскольку значением аргумента является 1.<br> Типом '' является string (строка), а типом null - object (объект)."
    },
    {
      "id": "fb375253-910f-406a-83e1-3fe666db5a43",
      "code": "function add(item, items = []) {\n    items.push(item);\n    return items;\n}\n\nconsole.log(add('Orange'));\nconsole.log(add('Apple'));",
      "answers": {
        "A": "A: ['Orange'] ['Orange', 'Apple']",
        "B": "B: ['Orange'] ['Apple']",
        "C": "C: []",
        "D": "D: undefined"
      },
      "right_answer": "B",
      "details": "Аргументу 'items' при каждом вызове функции 'add' присваивается пустой массив (значение по умолчанию), который возвращается с помещенным в него значением аргумента 'item'."
    },
    {
      "id": "e49795c9-67a8-4ea9-8c04-59fd30b16ed9",
      "code": "function greet(greeting, name, message = greeting + ' ' + name) {\n    console.log([name, greeting, message]);\n}\n\ngreet('Hello', 'John');\ngreet('Hello', 'John', 'Good morning!');",
      "answers": {
        "A": "A: error",
        "B": "B: ['Hello', 'John', 'Hello John'] ['Hello', 'John', 'Good morning!']",
        "C": "C: ['Hello', 'John', 'Hello John'] ['Hello', 'John', 'Hello John']",
        "D": "D: undefined"
      },
      "right_answer": "B",
      "details": "При первом вызове функции 'greet' аргументу 'message' присваивается значение по умолчанию (greeting + ' ' + name). При втором вызове данному аргументу присваивается переданное значение (Good morning!)."
    },
    {
      "id": "f8ebf47c-105d-4fa0-bbdc-17a98bf3e061",
      "code": "function outer(f = inner()) {\n    function inner() { return 'Inner' }\n}\nconsole.log(outer());",
      "answers": {
        "A": "A: error",
        "B": "B: Inner",
        "C": "C: Inner Inner",
        "D": "D: undefined"
      },
      "right_answer": "A",
      "details": "Функции и переменные, объявленные в теле функции, не могут использоваться в качестве значений по умолчанию, поэтому выбрасывается исключение ReferenceError: inner is not defined.<br> Функцию можно переписать так:<br>"
    },
    {
      "id": "4efef084-3b2a-47fd-a6e5-145cd9b61745",
      "code": "function myFun(x, y, ...args) {\n    console.log(args)\n}\n\nmyFun(1, 2, 3, 4, 5);\nmyFun(1, 2);",
      "answers": {
        "A": "A: [3, 4, 5] undefined",
        "B": "B: error",
        "C": "C: [3, 4, 5] []",
        "D": "D: [3, 4, 5] [undefined]"
      },
      "right_answer": "C",
      "details": "Оператор 'rest' (прочие параметры, ...) возвращает массив с переданными функции неименованными аргументами или пустой массив в случае, когда такие аргументы отсутствуют."
    },
    {
      "id": "fe4ac1c9-1c44-4a69-8e17-5ae442007ae6",
      "code": "const obj = {'key': 'value'};\nconst array = [...obj];\nconsole.log(array);",
      "answers": {
        "A": "A: ['key', 'value']",
        "B": "B: error",
        "C": "C: []",
        "D": "D: ['key']"
      },
      "right_answer": "C",
      "details": "Оператор 'spread' (распространения, ...) применяется только к итерируемым сущностям. Объекты таковыми не являются. Поэтому выбрасывается исключение TypeError: object is not iterable."
    },
    {
      "id": "991ec731-5218-4f3e-bcec-def696a2f733",
      "code": "function* myGenFunc() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\nvar myGenObj = new myGenFunc;\nconsole.log(myGenObj.next().value);",
      "answers": {
        "A": "A: 1",
        "B": "B: undefined",
        "C": "C: 2",
        "D": "D: error"
      },
      "right_answer": "D",
      "details": "Генераторы (функции со специальным символом '*') не могут использоваться в качестве конструктора, т.е. с ключевым словом 'new', поэтому выбрасывается исключение TypeError: myGenFunc is not a constructor."
    },
    {
      "id": "9e3618a9-7d64-4e66-bbee-ea860b1898fe",
      "code": "function* yieldAndReturn() {\n    yield 1;\n    return 2;\n    yield 3;\n}\n\nvar myGenObj = yieldAndReturn()\nconsole.log(myGenObj.next());\nconsole.log(myGenObj.next());\nconsole.log(myGenObj.next());",
      "answers": {
        "A": "A: { value: 1, done: false }, { value: 2, done: true }, { value: undefined, done: true }",
        "B": "B: { value: 1, done: false }, { value: 2, done: false }, { value: undefined, done: true }",
        "C": "C: { value: 1, done: false }, { value: 2, done: true }, { value: 3, done: true }",
        "D": "D: { value: 1, done: false }, { value: 2, done: false }, { value: 3, done: true }"
      },
      "right_answer": "A",
      "details": "Инструкция 'return' в генераторе (функция со специальным символом '*') останавливает его выполнение. Возвращаемое значение 2 присваивается свойству 'value', а значением свойства 'done' становится true. После завершения работы генератора вызов метода 'next()' возвращает {value: undefined, done: true}."
    },
    {
      "id": "3a20aa56-2abc-47d7-87f2-e140d212d875",
      "code": "const myGenerator = (function *(){\n    yield 1;\n    yield 2;\n    yield 3;\n})();\nfor (const value of myGenerator) {\n    console.log(value);\n    break;\n}\n\nfor (const value of myGenerator) {\n    console.log(value);\n}",
      "answers": {
        "A": "A: 1,2,3 1,2,3",
        "B": "B: 1,2,3 4,5,6",
        "C": "C: 1 1",
        "D": "D: 1"
      },
      "right_answer": "D",
      "details": "Генератор (функция со специальным символом '*') не может использоваться после закрытия итератора. В первом цикле мы с помощью break останавливаем выполнение генератора со значением 1. Повторный перебор генератора невозможен, поэтому второй console.log() ничего не возвращает."
    },
    {
      "id": "87af57d0-fc12-42c7-a4ff-c81920461b8f",
      "code": "const squareObj = new Square(10);\nconsole.log(squareObj.area);\n\nclass Square {\n    constructor(length) {\n        this.length = length;\n    }\n\n    get area() {\n        return this.length * this.length;\n    }\n\n    set area(value) {\n        this.area = value;\n    }\n}",
      "answers": {
        "A": "A: 100",
        "B": "B: error",
        "C": "C: 10",
        "D": "D: undefined"
      },
      "right_answer": "B",
      "details": "В отличие от объявления функций (не функциональных выражений), объявления классов не поднимаются в начало области видимости. Это также справедливо для выражений класса. Поэтому использовать класс можно только после его объявления, в противном случае, выбрасывается исключение ReferenceError: Square is not defined."
    },
    {
      "id": "300d6456-73f0-423f-b17a-c741088431f3",
      "code": "function Person() { }\n\nPerson.prototype.walk = function() {\n    return this;\n}\n\nPerson.run = function() {\n    return this;\n}\n\nlet user = new Person();\nlet walk = user.walk;\nconsole.log(walk());\n\nlet run = Person.run;\nconsole.log(run());",
      "answers": {
        "A": "A: undefined undefined",
        "B": "B: Person Person",
        "C": "C: error",
        "D": "D: Window Window"
      },
      "right_answer": "D",
      "details": "Когда обычный метод или метод прототипа вызывается без передачи ему значения this, метод возвращает значение this по умолчанию. В данном случае, таким значением является глобальный объект 'window'."
    },
    {
      "id": "313a1879-c84a-4887-9c50-a8a9af3ff6db",
      "code": "class Vehicle {\n    constructor(name) {\n        this.name = name;\n    }\n\n    start() {\n        console.log(`${this.name} vehicle started`);\n    }\n}\n\nclass Car extends Vehicle {\n    start() {\n        console.log(`${this.name} car started`);\n        super.start();\n    }\n}\n\nconst car = new Car('BMW');\nconsole.log(car.start());",
      "answers": {
        "A": "A: error",
        "B": "B: BMW vehicle started, BMW car started",
        "C": "C: BMW car started, BMW vehicle started",
        "D": "D: BMW car started, BMW car started"
      },
      "right_answer": "C",
      "details": "Ключевое слово 'super' используется, в том числе, для вызова методов родительского класса. В отличие от других языков программирования, в JavaScript вызов super() не обязательно должен быть первой инструкцией."
    },
    {
      "id": "d49d1c12-f6a7-4194-b649-52f27bc3aecc",
      "code": "const user = {'age': 30};\nuser.age = 25;\nconsole.log(user.age);",
      "answers": {
        "A": "A: 30",
        "B": "B: 25",
        "C": "C: error",
        "D": "D: undefined"
      },
      "right_answer": "B",
      "details": "Мы используем ключевое слово 'const' для объявления переменной 'user', т.е. делаем ее неизменяемой (константой). Однако иммутабельность переменной, являющейся объектом, не распространяется на свойства объекта. Другими словами, свойства такого объекта можно изменять. Однако, если мы попытаемся присвоить переменной 'user' новое значение (user = {'age': 25}), будет выброшено исключение TypeError: Assignment to constant variable. Для обеспечения иммутабельности свойств объекта используется метод 'freeze()'."
    },
    {
      "id": "e145acc7-37c5-49ac-98c7-aa1dd0563080",
      "code": "function a(x) {\n    x++;\n    return function () {\n        console.log(++x);\n    };\n}\n\na(1)();\na(1)();\na(1)();\n\nlet x = a(1);\nx();\nx();\nx();",
      "answers": {
        "A": "A: 1, 2, 3 и 1, 2, 3",
        "B": "B: 3, 3, 3 и 3, 4, 5",
        "C": "C: 3, 3, 3 и 1, 2, 3",
        "D": "D: 1, 2, 3 и 3, 3, 3"
      },
      "right_answer": "B",
      "details": "Здесь мы имеем дело с замыканием. Замыкания позволяют нам создавать статические функции, которым доступны переменные из внешнего окружения. Другими словами, замыкание имеет доступ к глобальной области видимости, области видимости родительской функции и собственной области видимости.<br> Мы получаем 3, 3, 3 и 3, 4, 5, поскольку сначала просто вызываем функцию 'a()'. Она работает как обычная функция. Затем мы объявляем переменную 'x' и присваиваем ей значение функции 'a(1)', вот почему мы получаем 3, 4, 5 вместо 3, 3, 3."
    },
    {
      "id": "7fc3e8f0-7bb4-4c1f-86fa-96ef4e0646af",
      "code": "function Name(a, b) {\n    this.a = a;\n    this.b = b;\n}\n\nconst me = Name('John', 'Smith');\n\nconsole.log(!(a.length - window.a.length));",
      "answers": {
        "A": "A: undefined",
        "B": "B: NaN",
        "C": "C: true",
        "D": "D: false"
      },
      "right_answer": "С",
      "details": "Мы получаем true. Обратите внимание, что при создании объекта с помощью конструктора функции 'Name' мы не использовали ключевое слово 'new'. Из-за этого переменная 'a' стала глобальной и получила значение 'John'. В действительности, глобальные переменные - это свойства глобального объекта 'window' (в браузере) или 'global' в Node.js.<br> Поэтому выражение 'a.length - window.a.length' возвращает 0. !0 возвращает true."
    },
    {
      "id": "43c581aa-3409-4177-be1b-34d6d3f50f34",
      "code": "const x = function (...x) {\n    let k = (typeof x).length;\n    let y = () => \"freetut\".length;\n    let z = { y: y };\n\n    return k - z.y();\n};\n\nconsole.log(Boolean(x()));",
      "answers": {
        "A": "A: true",
        "B": "B: 1",
        "C": "C: -1",
        "D": "D: false"
      },
      "right_answer": "A",
      "details": "Оператор распространения (spread) '...x' позволяет получить параметры функции в виде массива. В JavaScript 'typeof array' возвращает 'object'.<br> Длина строки 'object' равняется 6. z.y() возвращает длину строки 'freetut', т.е. 7.<br> Функциональное выражение 'x()' возвращает -1, которое после преобразования в логический тип становится true. Обратите внимание, что boolean(0) вернет false."
    },
    {
      "id": "30c5b58e-17d5-43b9-957e-a6f6006e389d",
      "code": "(function js(x) {\n    const y = (j) => j * x;\n\n    console.log(y(s()));\n\n    function s() {\n        return j();\n    }\n\n    function j() {\n        return x ** x;\n    }\n})(3);",
      "answers": {
        "A": "A: undefined",
        "B": "B: 18",
        "C": "C: 81",
        "D": "D: 12"
      },
      "right_answer": "A",
      "details": "Функция 'js()' выполняется автоматически, поскольку является IIFE (Immediately Invoked Function Expression - немедленно вызываемым функциональным выражением). Параметр 'x' функции 'js' передается со значением 3.<br> Значение, возвращаемое функцией 'y(s())', означает вызов трех функций: y(), s() и j(), поскольку функция s() возвращает j().<br> j() возвращает 3 ^ 3 = 27, поэтому s() возвращает 27.<br> y(s()) означает y(27), которая возвращает 27 * 3 = 81.<br> Обратите внимание, что мы можем вызвать функцию до ее объявления, но это не работает с функциональными выражениями."
    },
    {
      "id": "f5d0f281-4427-415e-a914-157d53d848a5",
      "code": "var tip = 100;\n\n(function () {\n    console.log(\"I have $\" + husband());\n\n    function wife() {\n        return tip * 2;\n    }\n\n    function husband() {\n        return wife() / 2;\n    }\n\n    var tip = 10;\n})();",
      "answers": {
        "A": "A: 'I have $10'",
        "B": "B: 'I have $100'",
        "C": "C: 'I have $50'",
        "D": "D: 'I have $NaN'"
      },
      "right_answer": "D",
      "details": "Здесь мы имеем дело с IIFE (Immediately Invoked Function Expression - немедленно вызываемым функциональным выражением). IIFE выполняются автоматически. Последовательность следующая: husband() возвращает wife(), а wife() возвращает tip * 2.<br> Можно подумать, что tip = 100, поскольку мы объявили ее с помощью ключевого слова 'var', и она стала глобальной. Однако, на самом деле ее значением является undefined, поскольку мы объявляем 'tip = 10' внутри функции. Поскольку переменная 'tip' поднимается со значением 'undefined', правильным ответом является D. Undefined возвращает NaN, когда мы пытаемся разделить его на 2 или умножить на 2.<br> Если убрать 'var tip = 10' в конце функции, правильным ответом будет B."
    },
    {
      "id": "3fa8a481-b035-417a-a411-40afc52891b4",
      "code": "const js = { language: \"loosely type\", label: \"difficult\" };\n\nconst edu = { ...js, level: \"PhD\" };\n\nconst newbie = edu;\n\ndelete edu.language;\n\nconsole.log(Object.keys(newbie).length);",
      "answers": {
        "A": "A: 2",
        "B": "B: 3",
        "C": "C: 4",
        "D": "D: 5"
      },
      "right_answer": "A",
      "details": "Данная задача посвящена оператору распространения (spread, ...). Этот оператор позволяет получать параметры функции, копировать или объединять объекты и массивы в JavaScript.<br> В переменной 'edu' мы используем оператор распространения для копирования объекта 'js' и добавления к нему нового свойства 'level'. Это также работает с массивами.<br> Затем мы объявляем другую переменную с именем 'newbie'. Важное замечание: обе переменных указывают или ссылаются на одно место в памяти. Это называется передачей значения по ссылке.<br> После удаления свойства 'language' посредством delete edu.language, длина обоих объектов становится равной 2."
    },
    {
      "id": "62bf7fa3-0e8c-40e0-ab72-6e77ba2df295",
      "code": "var candidate = {\n    name: \"Vuong\",\n    age: 30,\n};\n\nvar job = {\n    frontend: \"Vuejs or Reactjs\",\n    backend: \"PHP and Laravel\",\n    city: \"Auckland\",\n};\n\nclass Combine {\n    static get() {\n        return Object.assign(candidate, job);\n    }\n\n    static count() {\n        return Object.keys(this.get()).length;\n    }\n}\n\nconsole.log(Combine.count());",
      "answers": {
        "A": "A: 5",
        "B": "B: 6",
        "C": "C: 7",
        "D": "D: 8"
      },
      "right_answer": "A",
      "details": "Вcтроенный метод 'Object.assign(candidate, job)' объединяет candidate и job в один объект. Затем метод 'Object.keys()' считает количество ключей объекта.<br> Обратите внимание, что методы 'get()' и 'count()' определены как статические, поэтому их можно вызывать с помощью Class.staticMethod(). Результирующий объект содержит 5 элементов."
    },
    {
      "id": "06caa3a0-a4a2-4318-860b-56ee05947741",
      "code": "var x = 1;\n\n(() => {\n    x += 1;\n    ++x;\n})();\n((y) => {\n    x += y;\n    x = x % y;\n})(2);\n(() => (x += x))();\n(() => (x *= x))();\n\nconsole.log(x);",
      "answers": {
        "A": "A: 4",
        "B": "B: 50",
        "C": "C: 2",
        "D": "D: 10"
      },
      "right_answer": "A",
      "details": "Начальное значение переменной 'x' равно 1. В первом IIFE (Immediately Invoked Function Expression - немедленно вызываемом функциональном выражении) значение 'x' увеличивается до 3.<br> Во втором IIFE выражение 'x + y (3 + 2)' возвращает 5, а выражение 'x % y (5 % 2)' - 1.<br> В третьем и четвертом IIFE мы получаем 2 (1 + 1) и 4 (2 * 2), соответственно. Проще простого."
    },
    {
      "id": "4a7f74a8-2107-4510-8329-c5cec69ff78d",
      "code": "let x = {};\nlet y = {};\nlet z = x;\n\nconsole.log(x == y);\nconsole.log(x === y);\nconsole.log(x == z);\nconsole.log(x === z);",
      "answers": {
        "A": "A: true true true true",
        "B": "B: false false false false",
        "C": "C: true true false false",
        "D": "D: false false true true"
      },
      "right_answer": "D",
      "details": "Технически 'x' и 'y' имеют одинаковые значения. Обе переменные являются пустыми объектами. Однако объекты сравниваются не по значениям.<br> 'z' и 'x' являются объектами, ссылающимися на одно и тоже место в памяти. В JavaScript массивы и объекты передаются по ссылке. Поэтому при сравнении 'x' и 'z' возвращается true."
    },
    {
      "id": "1034851c-ad08-40df-81bd-74e0d02e9bce",
      "code": "console.log(\"hello\");\n\nsetTimeout(() => console.log(\"hey\"), 1);\nsetTimeout(() => console.log(\"kiora\"), 2);\nsetTimeout(() => console.log(\"world\"), 0);\n\nconsole.log(\"hi\");",
      "answers": {
        "A": "A: 'hello' 'hey' 'kiora' 'world' 'hi'",
        "B": "B: 'hello' 'hi' 'hey' 'kiora' 'world'",
        "C": "C: 'hello' 'hi' 'world' 'hey' 'kiora'",
        "D": "D: 'hello' 'hi' 'hey' 'world' 'kiora'"
      },
      "right_answer": "D",
      "details": "Три функции setTimeout() помещаются в очередь задач (task queue) перед попаданием в стек вызовов (call stack), поэтому сначала в консоль выводятся 'hello' и 'hi'.<br> Можно подумать, что три setTimeout() будут выполнены в следующем порядке: 'world' -&gt; 'hey' -&gt; 'kiora' согласно временной задержке в 0 мс -&gt; 1 мс -&gt; 2 мс, соответственно. Однако, между 0 мс и 1 мс нет разницы. Поэтому следующим в консоль выводится 'hey', затем 'world' и в конце 'kiora'."
    },
    {
      "id": "1bda10bb-9d98-4f5c-bdd9-6d537210f787",
      "code": "String.prototype.lengthy = () => {\n    console.log(\"hello\");\n};\n\nlet x = { name: \"John\" };\n\ndelete x;\n\nx.name.lengthy();",
      "answers": {
        "A": "A: 'John';",
        "B": "B: 'hello';",
        "C": "C: undefined",
        "D": "D: ReferenceError"
      },
      "right_answer": "B",
      "details": "С помощью String.prototype.someThing = function () {} можно определить новый встроенный метод объекта 'String'. Мы можем сделать тоже самое с Array, Object или FunctionName, где FunctionName - это созданная нами функция.<br> Несложно понять, что 'string'.lengthy всегда возвращает 'hello'. Delete удаляет свойство объекта, а не сам объект. Поэтому мы получаем 'hello', а не RefferenceError.<br> Обратите внимание, что если мы объявим объект без ключевых слов 'let', 'const' или 'var', то получим глобальный объект. В этом случае delete objectName вернет true. В противном случае, он всегда возвращает false."
    },
    {
      "id": "2afc447a-05a2-4eae-be96-01388fd400b4",
      "code": "let x = {};\n\nx.__proto__.hi = 10;\n\nObject.prototype.hi = ++x.hi;\n\nconsole.log(x.hi + Object.keys(x).length);",
      "answers": {
        "A": "A: 10",
        "B": "B: 11",
        "C": "C: 12",
        "D": "D: NaN"
      },
      "right_answer": "C",
      "details": "Начальным значением переменной 'x' является пустой объект. Затем мы добавляем к нему свойство 'hi' с помощью 'x.__proto__.hi'. Обратите внимание, что это является эквивалентом 'Object.prototype.hi = 10', поэтому мы добавляем свойство 'hi' родителю пустого объекта - объекту Object. Это означает, что любой объект будет наследовать данное свойство. Свойство 'hi' становится распределенным (совместным). Если мы объявим новый объект, скажем, let y = {}, 'y' унаследует свойство 'hi' от Object. Сравнение 'x.__proto__ === Object.prototype' вернет true.<br> После этого, мы перезаписываем значение свойства 'hi' новым значением 11. Получаем 1 (x имеет одно свойство) + 11 (значение свойства hi) = 12."
    },
    {
      "id": "452cd928-64fb-4f6d-b81a-123ae5c128d9",
      "code": "const array = (a) => {\n    let length = a.length;\n    delete a[length - 1];\n    return a.length;\n};\n\nconsole.log(array([1, 2, 3, 4]));\n\nconst object = (obj) => {\n    let key = Object.keys(obj);\n    let length = key.length;\n    delete obj[key[length - 1]];\n\n    return Object.keys(obj).length;\n};\n\nconsole.log(object({ 1: 2, 2: 3, 3: 4, 4: 5 }));\n\nconst setPropNull = (obj) => {\n    let key = Object.keys(obj);\n    let length = key.length;\n    obj[key[length - 1]] = null;\n\n    return Object.keys(obj).length;\n};\n\nconsole.log(setPropNull({ 1: 2, 2: 3, 3: 4, 4: 5 }));",
      "answers": {
        "A": "A: 3 3 3",
        "B": "B: 4 4 4",
        "C": "C: 4 3 4",
        "D": "D: 3 4 3"
      },
      "right_answer": "C",
      "details": "Данная задача демонстрирует, как работает оператор 'delete' в JavaScript. Выражения 'delete someObject' и 'delete someArray' возвращают false (ничего не делают). Выражение 'delete someObject.someProperty' удаляет указанное свойство объекта. В случае с массивом выражение 'delete someArray[keyNumber]' удаляет только значение указанного индекса, сам индекс остается и его новым значением становится undefined. По этой причине первый console.log() выводит 4 (массив содержит 4 элемента, последний имеет значение 'undefined'), а второй - 3 (оставшиеся свойств объекта).<br> Последний console.log() выводит 4, поскольку присвоение свойству объекта значения 'null' или 'undefined' не удаляет это свойство. Ключ остается. Поэтому длина остается прежней."
    },
    {
      "id": "167bd0f9-d3cb-4e4a-bd7a-97726c06477c",
      "code": "var a = [1, 2, 3];\nvar b = [1, 2, 3];\n\nvar c = [1, 2, 3];\nvar d = c;\n\nvar e = [1, 2, 3];\nvar f = e.slice();\n\nconsole.log(a === b);\nconsole.log(c === d);\nconsole.log(e === f);",
      "answers": {
        "A": "A: true true true",
        "B": "B: false false true",
        "C": "C: true true false",
        "D": "D: false true false"
      },
      "right_answer": "D",
      "details": "Сравнение 'a' и 'b' возвращает false, поскольку эти переменные ссылаются на разные места в памяти, несмотря на то, что их значения являются одинаковыми.<br> В JavaScript в случае с массивами и объектами значения передаются по ссылке. Во втором случае 'd' является копией 'c', поэтому они ссылаются на одно место в памяти. Любые изменения в 'c' отражаются на 'd'.<br> Третий пример демонстирует способ копирования массива с помощью метода 'slice()'. 'f' является копией 'e', но они ссылаются на разные места в памяти. Поэтому их сравнение возвращает false."
    },
    {
      "id": "311ee4f3-3703-47d3-96d3-820d7aedca0a",
      "code": "var languages = {\n    name: [\"elixir\", \"golang\", \"js\", \"php\", { name: \"feature\" }],\n    feature: \"awesome\",\n};\n\nlet flag = languages.hasOwnProperty(\n    Object.values(languages)[0][4].name\n);\n\n(() => {\n    if (flag !== false) {\n        console.log(\n            Object.getOwnPropertyNames(languages)[0].length <<\n            Object.keys(languages)[0].length\n        );\n    } else {\n        console.log(\n            Object.getOwnPropertyNames(languages)[1].length <<\n            Object.keys(languages)[1].length\n        );\n    }\n})();",
      "answers": {
        "A": "A: 8",
        "B": "B: NaN",
        "C": "C: 64",
        "D": "D: 12"
      },
      "right_answer": "C",
      "details": "Данная задача является довольно сложной, поскольку в ней встречается несколько встроенных методов для работы с объектами. Например, методы 'Object.keys()' и 'Object.getOwnPropertyNames' возвращают свойства объекта: первый - только перечисляемые, второй - также не перечисляемые.<br> Object.values() и Object.keys() возвращают значения и ключи объекта, соответственно. Object.hasOwnProperty('propertyName') возвращает булево значение в зависимости от того, существует указанное свойство в объекте или нет.<br> Переменная 'language' имеет значение true, поскольку Object.values(languages)[0][4].name возвращает 'feature', которое является свойством объекта.<br> Наконец, мы получаем 4 &lt;&lt; 4, что возвращает побитовое значение, эквивалентное '4 * 2 ^ 4' или '4 * 16', или 64."
    },
    {
      "id": "f311f1c7-b0f7-48ab-b5c2-a96c3d61b314",
      "code": "var player = {\n    name: \"Ronaldo\",\n    age: 34,\n    getAge: function () {\n        return ++this.age - this.name.length;\n    },\n};\n\nfunction score(greeting, year) {\n    console.log(\n        greeting + \" \" + this.name + `! You were born in  ${year - this.getAge()}`\n    );\n}\n\nwindow.window.window.score.call(\n    window.window.window.player, \"Kiora\", 2019\n);\n\nscore.apply(player, [\"Kiora\", 2009]);\n\nconst helloRonaldo = window.score\n    .bind(window.player, \"Kiora\", 2029);\n\nhelloRonaldo();",
      "answers": {
        "A": "A: 'Kiora Ronaldo! You were born in 1985', 'Kiora Ronaldo! You were born in 1985', 'Kiora Ronaldo! You were born in 1985'",
        "B": "B: 'Kiora Ronaldo! You were born in 1991', 'Kiora Ronaldo! You were born in 1991', 'Kiora Ronaldo! You were born in 1999'",
        "C": "C: 'Kiora Ronaldo! You were born in 1991', NaN, 'Kiora Ronaldo! You were born in 1980'",
        "D": "D: 'Kiora Ronaldo! You were born in 1991', 'Kiora Ronaldo! You were born in 1980', 'Kiora Ronaldo! You were born in 1999'"
      },
      "right_answer": "D",
      "details": "Мы можем использовать call(), apply() и bind() для привязки функции к объекту. На первый взгляд может показаться, что все три метода делают одно и тоже. Однако они немного по-разному спроектированы для работы с контекстом.<br> Из этих методов только bind() можно вызывать после привязки. Мы можем создать переменную для хранения результата, как 'helloRonaldo' в задаче. apply() и call() привязывают и вызывают функцию сразу. В методу 'apply()' параметры передаются в виде массива (array, a), а в методе 'call()' - через запятую (comma, c).<br> Обратите внимание, что window.window.window.score или window.score, или просто score делают одно и тоже. Они указывают на функцию 'score()' в глобальном пространстве имен."
    },
    {
      "id": "3508cb1f-41f7-464b-bbbc-99e30dbeb182",
      "code": "var ronaldo = { age: 34 };\n\nvar messi = { age: 32 };\n\nfunction score(year, tr, t) {\n    if (typeof tr === \"function\" && typeof t === \"function\") {\n        console.log(`You score ${tr(year, t(this.age))} times`);\n    }\n}\n\nconst transform = (x, y) => x - y;\n\nconst title = (x) => ++x + x++;\n\nconst helloRonaldo = score.bind(ronaldo, 2029, transform, title);\n\nhelloRonaldo();\n\nconst helloMessi = score.bind(messi, 2029, transform, title);\n\nhelloMessi();",
      "answers": {
        "A": "A: 'You score 1989 times' and 'You score 1963 times'",
        "B": "B: 'You score 1959 times' and 'You score 1989 times'",
        "C": "C: 'You score 1989 times' and 'You score 1953 times'",
        "D": "D: 'You score 1959 times' and 'You score 1963 times'"
      },
      "right_answer": "D",
      "details": "bind() позволяет привязать функцию к объекту. В данном случае мы привязываем функцию 'score()' к объектам 'ronaldo' и 'messi'.<br> Функция 'score()' принимает три параметра: year, tr и t, где 'tr' и 't' должны быть функциями.<br> Когда мы привязываем score() к ronaldo и messi, мы передаем ей три аргумента, два из которых, 'transfrom' и 'title', являются функциями."
    },
    {
      "id": "fbb523ad-6da1-4963-95eb-91fda68cbe60",
      "code": "var person = {};\n\nObject.defineProperties(person, {\n    name: {\n        value: \"John\",\n        enumerable: true,\n    },\n    job: {\n        value: \"developer\",\n        enumerable: true,\n    },\n    studying: {\n        value: \"PhD\",\n        enumerable: true,\n    },\n    money: {\n        value: \"NZD\",\n        enumerable: false,\n    },\n});\n\nclass Evaluate {\n    static checkFlag(obj) {\n        return Object.getOwnPropertyNames(obj) > Object.keys(obj)\n            ? Object.getOwnPropertyNames(obj)\n            : Object.keys(obj);\n    }\n}\n\nconst flag = Evaluate.checkFlag(person);\n\nconsole.log(flag.length);",
      "answers": {
        "A": "A: 1",
        "B": "B: 2",
        "C": "C: 3",
        "D": "D: 4"
      },
      "right_answer": "D",
      "details": "Object.keys(obj) почти идентичен Object.getOwnPropertyNames(obj), за исключением того, что последний, кроме перечисляемых, возвращает также неперечисляемые свойства объекта. По умолчанию все свойства создаваемого объекта являются перечисляемыми. Мы можем сделать их неперечисляемыми с помощью Object.defineProperty или Object.defineProperties.<br> Поэтому Object.keys(person) возвращает 3, а Object.getOwnPropertyNames(person) - 4. Тернарный оператор возвращает 4."
    },
    {
      "id": "df554a9c-d1a4-4699-a350-d12c7d1085c5",
      "code": "const id = 10;\n\nconst getID = (...id) => {\n    id(id);\n\n    function id(id) {\n        console.log(typeof id);\n    }\n};\n\ngetID(id);",
      "answers": {
        "A": "A: ReferenceError",
        "B": "B: 10",
        "C": "C: undefined",
        "D": "D: 'function'"
      },
      "right_answer": "D",
      "details": "Когда мы определяем одну функцию внутри другой, то получаем замыкание. Обратите внимание, если функция обычная (а не функциональное выражение), она поднимается. Мы видим несколько id в коде, но некоторые из них ничего не делают.<br> Результатом выполнения кода является 'typeof id', т.е. 'function'. Таким образом, 'id' в этой операции является функцией 'id()'."
    },
    {
      "id": "f337d42c-047e-4f2b-b571-1d42fe362ae5",
      "code": "var book1 = {\n    name: \"Name of the rose\",\n    getName: function () {\n        console.log(this.name);\n    },\n};\n\nvar book2 = {\n    name: { value: \"Harry Potter\" },\n};\n\nvar bookCollection = Object.create(book1, book2);\n\nbookCollection.getName();",
      "answers": {
        "A": "A: 'Harry Potter'",
        "B": "B: 'Name of the rose'",
        "C": "C: ReferenceError",
        "D": "D: Object object"
      },
      "right_answer": "A",
      "details": "Object.create() позволяет создавать одни объекты на основе других. Если мы не передадим второй параметр - book2, в данном случае - свойство 'name' объекта 'bookCollection' будет иметь значение 'Name of the rose', унаследованное от book1. Это означает, что мы можем добавлять новые свойства создаваемому с помощью Object.create() объекту.<br> bookCollection имеет собственное свойство 'name' и одноименное свойство, унаследованное от book1. Собственные свойства объекта имеют приоритет перед унаследованными. Поэтому мы получаем 'Harry Potter'."
    },
    {
      "id": "b26a2f99-9cec-48c1-853d-1801a19f5719",
      "code": "(() => {\n    const a = Object.create({});\n\n    const b = Object.create(null);\n\n    let f1 = a.hasOwnProperty(\"toString\");\n\n    let f2 = \"toString\" in b;\n\n    let result =\n        f1 === false && f2 === false\n            ? console.log((typeof a.toString()).length)\n            : console.log(b.toString());\n})();",
      "answers": {
        "A": "A: ReferenceError",
        "B": "B: undefined",
        "C": "C: 0",
        "D": "D: 6"
      },
      "right_answer": "D",
      "details": "Объекты 'a' и 'b' создаются с помощью Object.create(). Разница между ними состоит в том, что 'a' наследует прототип Object, а 'b' является совершенно пустым, поскольку мы передали параметр 'null' методу 'Object.create()'. hasOwnProperty('toString') в обоих случаях возвращает false, поскольку в объектах метод 'toString()' не определяется. Однако данный метод существует в объекте 'a' как унаследованный от Object.<br> 'f1' и 'f2' возвращают false. Обратите внимание, что для проверки существования свойства в объекте мы используем 'Object.hasOwnProperty('key')' и '('key' in object)'. Они отличаются тем, что первый возвращает только собственные свойства объекта, а второй - также унаследованные.<br> typeof a.toString() возвращает 'string', длина которой равняется 6."
    },
    {
      "id": "3a154e3b-6a74-4c5c-a1aa-a4a02360cee1",
      "code": "let promise = new Promise((rs, rj) => {\n    setTimeout(() => rs(4), 0);\n\n    Promise.resolve(console.log(3));\n\n    console.log(2);\n});\n\npromise\n    .then((rs) => {\n        console.log(rs ? rs ** rs : rs);\n        return rs;\n    })\n    .then((rs) => console.log(rs === 256 ? rs : rs * rs));",
      "answers": {
        "A": "A: 3, 2, 256, 256",
        "B": "B: 3, 2, 256, 16",
        "C": "C: 256, 16, 3, 2",
        "D": "D: 16, 256, 3, 2"
      },
      "right_answer": "B",
      "details": "Мы определяем промис с помощью ключевого слова 'let' и вызываем его. setTimeout() - это асинхронная функция, которая выполняется последней, даже при нулевой задержке: setTimeout(() =&gt; rs(4), 0). Хотя 'Promise.resolve(console.log(3))' также возвращает промис, он относится к микрозадачам, которые имеет приоритет над (макро)задачами, такими как 'setTimeout()'.<br> В первом then() мы получаем '4 ^ 4', во втором - '4 * 4'. Обратите внимание, что 'return rs' возвращает оригинальное значение."
    },
    {
      "id": "7763de2f-4b5a-4466-8c89-a30268987cc9",
      "code": "async function f() {\n    let promise = new Promise((resolve, reject) => {\n        setTimeout(() => resolve(\"done!\"), 0);\n    });\n\n    setTimeout(() => console.log(\"world\"), 0);\n\n    console.log(await promise);\n\n    console.log(\"hello\");\n}\n\nf(setTimeout(() => console.log(\"kiora\"), 0));",
      "answers": {
        "A": "A: ReferenceError",
        "B": "B: done, hello, world",
        "C": "C: hello, done, world",
        "D": "D: kiora, done, hello, world"
      },
      "right_answer": "D",
      "details": "Хотя мы не определяем параметров в функции 'f()', мы передаем ей 'setTimeout(() =&gt; console.log('kiora'), 0)' при вызове. Поэтому сначала мы получаем 'kiora'.<br> Переменная promise, возвращающая разрешенный промис, вызывается с помощью ключевого слова 'await'. JavaScript приостанавливает выполнение кода на строке 'console.log(await promise)' до разрешения промиса. Вот почему следующим мы получаем 'done'.<br> Почему вторым значением, выведенным в консоль, является 'done', а не 'world' или 'hello'? Поскольку JavaScript ставит выполнение кода на паузу, когда встречает ключевое слово 'await', мы не можем получить 'hello' до разрешения промиса (обратите внимание, что setTimeout() всегда выполняется последней, поскольку является асинхронной (макро)задачей, поэтому 'setTimeout(() =&gt; console.log('world'), 0))' выполняется последней).<br> Здесь мы наблюдаем небольшую разницу в работе ключевого слова 'await' перед асинхронным оператором (в данном случае, мы использовали setTimeout() в качестве примера) и вызовом функции/оператора без этого ключевого слова."
    },
    {
      "id": "18bc06b4-b28d-4d1a-a79b-7f8a30b73848",
      "code": "function name() {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n            resolve(\"New Zealand\");\n        }, 10);\n    });\n}\n\nfunction fruit() {\n    return new Promise((resolve) => {\n        setTimeout(() => {\n        resolve(\"Kiwi\");\n        }, 20);\n    });\n}\n\n(async function countryandfruit() {\n    const getName = await name();\n    const getFruit = await fruit();\n\n    console.log(`Kiora: ${getName} ${getFruit}`);\n})();\n\n(async function fruitandcountry() {\n    const [getName, getFruit] = await Promise.all([name(), fruit()]);\n\n    console.log(`Hello: ${getName} ${getFruit}`);\n})();",
      "answers": {
        "A": "A: Null",
        "B": "B: Kiora",
        "C": "C: 'Hello: New Zealand Kiwi' -> 'Kiora: New Zealand Kiwi'",
        "D": "D: 'Kiora: New Zealand Kiwi' -> 'Hello: New Zealand Kiwi'"
      },
      "right_answer": "C",
      "details": "Функции 'countryandfruit' и 'fruitandcountry' являются самовызываемыми. Обе определяются с помощью ключевого слова 'async', это означает, что код внутри будет выполняться последовательно. Это позволяет в более краткой форме управлять получением данных по сравнению с промисами или колбеками.<br> Первая функция возвращает 'Kiora: New Zealand Kiwi', вторая - 'Hello: New Zealand Kiwi'. Можно подумать, что порядок будет таким же, но на самом деле порядок обратный, поскольку функции с ключевым словом 'await' выполняются последовательно, а не параллельно как 'Promise.all'. Это означает, что сначала выполнится 'fruitandcountry'."
    },
    {
      "id": "c4583365-b951-488c-9ffe-567de220429c",
      "code": "class MySort {\n    constructor(object) {\n        this.object = object;\n}\n\ngetSort() {\n    return Object.entries(this.object)[0][1].sort()[\n            Object.values(this.object).length\n        ];\n    }\n}\n\nconst object = {\n    month: [\"July\", \"September\", \"January\", \"December\"],\n};\n\nconst sortMe = new MySort(object);\n\nconsole.log(sortMe.getSort());",
      "answers": {
        "A": "A: July",
        "B": "B: September",
        "C": "C: January",
        "D": "D: December"
      },
      "right_answer": "C",
      "details": "Object.entries возвращает массив, состоящий из ключей и значений объекта, Object.values - массив значений объекта, а Object.keys - массив ключей. Таким образом, 'Object.entries(object)' в примере возвращает вложенный массив с одним элементом, значения которого также вложены в другой массив - [['month', ['July', 'September', 'January', 'December']]].<br> По этой причине 'Object.entries(this.object)[0][1].sort()' на самом деле сортирует значения массива и возвращает новый порядок: 'December' -&gt; 'January' -&gt; 'July' -&gt; 'September'. Следовательно, когда мы пытаемся получить элемент с индексом '[Object.values(this.object).length]', то получаем 'January', поскольку '[Object.values(this.object).length]' возвращает 1 (длина массива, возвращенного Object.values)."
    },
    {
      "id": "ef4fb932-5f9c-4d4d-bdd6-63a50af1ad52",
      "code": "const flag = [] !== !!!!![];\n\nlet f = () => {};\n\nconsole.log((typeof f()).length + flag.toString().length);",
      "answers": {
        "A": "A: NaN",
        "B": "B: 12",
        "C": "C: 13",
        "D": "D: 14"
      },
      "right_answer": "C",
      "details": "Сравнение двух массивов или объектов в JavaScript всегда возвращает false, поскольку оба передаются по ссылке, в отличие от примитивов, таких как строка, число или логическое значение. Вот почему сравнение [] и [] с помощью == или === возвращает false. Странная часть - это !==!!!!!, что эквивалентно !==, так что в ней нет ничего особенного. Таким образом, значением переменной 'flag' является true.<br> В функциональном выражении 'f()' мы используем стрелочную функцию, но {} - это часть функции, а не объект. Для того, чтобы вернуть объект, следует написать 'let f = () =&gt; ({})' или использовать обычную функцию. С помощью ключевого слова 'return' мы легко можем поймать содержимое функции, когда используем обычный способ ее определения.<br> Поэтому 'typeof f()' возвращает undefined, а не object. Затем мы получаем 9 (длина undefined) + 4 (длина строки 'true') = 13."
    },
    {
      "id": "697db751-a32c-4084-8d07-16f8c3625d27",
      "code": "(function (a, b, c) {\n    arguments[2] = (typeof arguments).length;\n    c > 10 ? console.log(c) : console.log(++c);\n})(1, 2, 3);",
      "answers": {
        "A": "A: 4",
        "B": "B: 5",
        "C": "C: 6",
        "D": "D: 7"
      },
      "right_answer": "D",
      "details": "Здесь мы имеем дело с самовызываемой функцией с тремя параметрами. Обратите внимание, что arguments внутри функции возвращает объект, состоящий из параметров функции.<br> Когда мы присваиваем значение этому массиву (массивоподобному объекту) (или любому его элементу), функция будет использовать это значение, а не значение переданного при ее вызове параметра. Поэтому значением '(typeof arguments).length' будет 6, а не 3.<br> 6 меньше 10, поэтому мы получаем console.log(++c) или 7.<br> Обратите внимание, что arguments не доступна в стрелочных функциях.<br> ES6 рекомендует использовать прочие параметры (...rest) - настоящий массив. Это означает, что таким массивом можно манипулировать с помощью таких методов, как map, filter или reduce."
    },
    {
      "id": "7ac471c0-0fb4-4132-b5fc-acf5add3462c",
      "code": "class Calculator {\n    constructor(a, b) {\n        this.a = a;\n        this.b = b;\n    }\n    static getFlag() {\n        return new Array(this.a).length == new Array(this.b).toString().length;\n    }\n\n    getValue() {\n        return Calculator.getFlag() ? typeof this.a : typeof new Number(this.b);\n    }\n}\n\nconst me = new Calculator(5, 5);\n\nconsole.log(me.getValue());",
      "answers": {
        "A": "A: NaN",
        "B": "B: 'string'",
        "C": "C: 'object'",
        "D": "D: 'number'"
      },
      "right_answer": "C",
      "details": "У нас есть класс Calculator. При объявлении нового экземпляра мы передаем два параметра: 'a' и 'b'. Эти параметры одинаковые, но 'new Array(this.a).length' сильно отличается от 'new Array(this.b).toString().length', поскольку последний возвращает длину строки ',,,,' или 4, а первый - длину массива или 5.<br> По этой причине getFlags() возвращает false. В getValue() мы получаем 'typeof new Number(this.b)', что возвращает object. Это немного отличается от 'typeof b', что возвращает number."
    },
    {
      "id": "16af6f6c-8bb7-43d3-8692-74322ddd9f7b",
      "code": "var name = \"Auckland\";\n\nconst nz = {\n    name: \"Kiwi\",\n\n    callMe: function () {\n        return this.name;\n    },\n};\n\nlet me = nz.callMe;\n\nlet she = nz.callMe.bind(nz);\n\nlet result = me() === nz.callMe() ? she() : `${me()} ${she()}`;\n\nconsole.log(result);",
      "answers": {
        "A": "A: undefined",
        "B": "B: 'Auckland'",
        "C": "C: 'Kiwi'",
        "D": "D: 'Auckland Kiwi'"
      },
      "right_answer": "D",
      "details": "Данный вопрос посвящен ключевому слову 'this'. У нас есть простой объект, содержащий один метод и одно свойство.<br> Во-первых, важно понимать, что 'let me = nz.callMe' и последующий вызов me() существенно отличаются от прямого вызова 'nz.callMe()'. Если мы присваиваем переменной метод, объявленный внутри объекта, this в этом объекте будет вести себя по-разному (когда мы вызываем переменную как метод и когда мы вызываем сам метод). В частности, в первом случае, this - это объект window, в то время как во втором случае this внутри функции по-прежнему ссылается на свойство 'name' объекта 'nz'. Это означает, что me() возвращает 'Auckland', а nz.callMe - 'Kiwi'.<br> Затем result возвращает false, и мы получаем ${me()} ${she()}. Почему she() отличается от me()? Потому что she() привязана к объекту nz, а me() нет."
    },
    {
      "id": "e63137fa-d230-482d-bbe9-dc4c68ae475a",
      "code": "const club = {\n    name: \"Juventus\",\n    player: [\"Ronaldo\"],\n    showMePlayer: function () {\n        this.player.map(function (thename) {\n            console.log(this.name.length);\n        }, this);\n    },\n    showMe: function () {\n        this.player.forEach(\n        function (thename) {\n            console.log(this.name.length);\n        }.bind(this)\n        );\n    },\n    show: function () {\n        const self = this;\n        this.player.map(function (thename) {\n            console.log(self.name.length);\n        });\n    },\n    Me: function () {\n        this.player.map(function (thename) {\n            console.log(this.name.length);\n        });\n    },\n};\n\nclub.showMePlayer();\nclub.showMe();\nclub.show();\nclub.Me();",
      "answers": {
        "A": "A: 8 - 8 - 8 - 8",
        "B": "B: 'Juventus' - 'Juventus' - 'Juventus' - 'Juventus'",
        "C": "C: 'Ronaldo' - 'Ronaldo' - 'Ronaldo' - 'Ronaldo'",
        "D": "D: 8 - 8 - 8 - 0"
      },
      "right_answer": "D",
      "details": "Данная задача не слишком сложна для вас, не так ли? В ней просто приводится пример this в разных контекстах, когда мы объявляем анонимную функцию внутри метода объекта. Первые три метода являются распространенными способами обработки this с помощью this как второго параметра map(), bind(this) в forEach (или map()) или с помощью приема 'that = this' (мы используем self вместо that).<br> Последний метод Me() приводит к неожиданному результату, поскольку 'this.name' не привязано к объекту 'club'. Обратите внимание, что при тестировании кода в jsbin мы получаем другой результат. В Chrome и Firefox мы получаем 0."
    },
    {
      "id": "34e08702-2141-44bb-9b81-dd58aca68beb",
      "code": "((...a) => {\n    const b = [\"javascript\", \"new zealand\"];\n\n    const c = [...a, typeof a, ...b, \"kiwi\"];\n\n    console.log(c.length + c[0].length);\n})(new Array(10));",
      "answers": {
        "A": "A: 5",
        "B": "B: 10",
        "C": "C: 15",
        "D": "D: 20"
      },
      "right_answer": "C",
      "details": "... используется двумя способами: как оператор распространения (spread) и как прочие параметры (rest).<br> В приведенном примере мы видим оба способа. Первый оператор в самовызывающейся функции - это, разумеется, rest, а в константе c мы видим spread. В первом случае мы можем передать фукнции любое количество параметров. Обратите внимание, что 'typeof a' - это object, несмотря на то, что фактически - это настоящий массив (в отличие от массивоподобного объекта 'arguments').<br> spread позволяет нам объединять массивы. Таким образом, ...a - это оператор rest при использовании в качестве параметра функции, но в константе - это оператор spread.<br> Мы получаем 'c' с пятью элементами (...a - это вложенный массив, поэтому его длина равняется 1), но первый элемент имеет 10 элементов (когда мы передали в функцию new Array(10)). Сумма длин обоих равняется 15."
    },
    {
      "id": "14c99158-f992-40f0-bbf3-8cc9eb5af093",
      "code": "function Kiora(name, ...career) {\n    this.name = name;\n\n    return Array.isArray(career) === true && typeof career === \"object\" ? {} : \"\";\n}\n\nvar student = new Kiora(\"Vuong\");\n\nconsole.log(student.name);",
      "answers": {
        "A": "A: 'Vuong'",
        "B": "B: undefined",
        "C": "C: ErrorReference",
        "D": "D: false"
      },
      "right_answer": "B",
      "details": "У нас имеется конструктор функции 'Kiora' (написано с заглавной буквы, но это не обязательно), который может использоваться для создания объекта, как объект 'student' в задаче. В функции имеется два параметра, хотя второй параметр - это на самом деле оператор rest. Типом оператора является 'object', но 'Array.isArray(career)' возвращает true. Оператор 'return' возвращает объект {}.<br> Вы можете быть удивлены, когда 'console.log(student.name)' выведет в консоль undefined, если конструктор возвращает объект."
    },
    {
      "id": "e4c0b431-aee5-4955-b2b0-e33b33bf87b2",
      "code": "class Filter {\n    constructor(element) {\n        this.element = element;\n    }\n    filter() {\n        return this.type() === \"object\" ? this.element[0].name : \"hello\";\n    }\n\n    type() {\n        return typeof this.element;\n    }\n}\n\nlet countries = [\n    { name: \"New Zealand\", isdeveloped: true },\n    { name: \"Vietnam\", isdeveloped: false },\n];\n\nlet x = new Filter(countries);\n\nconst filter = countries.filter((item) => {\n    return !item.isdeveloped;\n});\n\nconsole.log(x.filter().length + filter[0].name.length);",
      "answers": {
        "A": "A: 15",
        "B": "B: 16",
        "C": "C: 17",
        "D": "D: 18"
      },
      "right_answer": "D",
      "details": "Пример получился длиннее, чем обычно. На самом деле он не слишком сложный. Вы легко найдете правильный ответ, потратив немного времени.<br> Сначала мы определяем класс с двумя методами. Первый метод 'filter()' возвращает первый элемент массива (свойства element) или 'hello' в зависимости от метода 'type()'. Мы знаем, что 'typeof array' вернет object, так что filter() вернет this.elements[0].name.<br> Затем мы вызываем встроенный метод 'filter()'. Этот метод возвращает новый массив в зависимости от условия, переданного колбеку. Обратите внимание, что '!item.isdeveloped' означает false. Значит, мы получаем 'Vietnam'.<br> Наконец, мы получаем 'New Zealand.length' и 'Vietnam.length', что в сумме дает 18."
    },
    {
      "id": "f79c89df-dc4e-4f34-83af-6a3c660e9d54",
      "code": "async function abc() {\n    console.log(8);\n\n    await Promise.resolve(2).then(console.log);\n\n    console.log(3);\n}\n\nsetTimeout(() => {\n    console.log(1);\n}, 0);\n\nabc();\n\nqueueMicrotask(() => {\n    console.log(0);\n});\n\nPromise.resolve(4).then(console.log);\n\nconsole.log(6);",
      "answers": {
        "A": "A: 6 - 8 - 3 - 0 - 4 - 2 - 1",
        "B": "B: 8 - 2 - 3 - 0 - 4 - 6 - 1",
        "C": "C: 6 - 8 - 2 - 0 - 4 - 3 - 1",
        "D": "D: 8 - 6 - 2 - 0 - 4 - 3 - 1"
      },
      "right_answer": "D",
      "details": "Порядок выполнения асинхронного кода зависит от микро- и макрозадач. Микрозадачи имеют приоритет. Запомните, что синхронный код всегда выполняется перед асинхронным. Поэтому мы имеем следующий порядок:<br>"
    },
    {
      "id": "db106e5f-172d-4cfc-bb47-129ebddefdbb",
      "code": "const hoccoban = {\n    x: \"youtube.com/hoccoban\".length,\n    getMe() {\n        const inner = function () {\n            console.log(++this.x);\n        };\n        inner.bind(this)();\n    },\n};\n\nhoccoban.getMe();",
      "answers": {
        "A": "A: 20",
        "B": "B: 21",
        "C": "C: 22",
        "D": "D: 23"
      },
      "right_answer": "B",
      "details": "Мы получаем 21. Сначала 'youtube.com/hoccoban' возвращает 20, поскольку мы используем свойство 'length' строки. Затем значение 'x' увеличивается на 1 посредством '++this.x'. Вопрос выглядит тривиальным, но это не так. Нужно помнить о том, что 'console.log(++this.x)' не будет работать, если значением 'x' будет undefined при вызове за пределами объекта.<br> Мы можем решить эту проблему с this с помощью стрелочной функции: const inner = () =&gt; {}, поскольку стрелочные функции берут this из внешнего (лексического) окружения.<br> Вторым решением является использования трюка с that/this. Нам нужно лишь объявить новую переменную 'const that = this' внутри insideMe() и перед объявлением функции 'inner'. Это довольно распространенный прием.<br> Третьим решением является использование apply(), call() или bind(), нативных методов функций (функция - это тоже объект). В данном случае, мы реализовали bind(this) для связывания функции и объекта, чтобы this указывал на объект при выполнении функции. Обратите внимание, что bind() не выполняется сразу, поэтому мы добавили () после него. Если заменить bind() на call(), то дополнительные () не понадобятся. inner.bind(this)() станет inner.call(this). На практике, мы, как правило, создаем переменную для хранения результата связывания функции и объекта."
    },
    {
      "id": "f5de98a3-6592-4722-a9d7-fa337a701d3f",
      "code": "function* hocCoBan() {\n    yield \"js.edu.vn\";\n    yield \"youtube.com/hoccoban\";\n    yield \"Vuong Nguyen\";\n}\n\nlet data = hocCoBan();\n\nconsole.log((typeof data).length + data.next().value.length);",
      "answers": {
        "A": "A: NaN",
        "B": "B: 10",
        "C": "C: Error",
        "D": "D: 15"
      },
      "right_answer": "D",
      "details": "Присмотритесь к функции. После ключевого слова 'function' имеется символ '*'. В функции отсутствует ключевое слово 'return'. Что здесь происходит?<br> Если вы знакомы с генераторами, решить данную задачу вам не составит труда. Мы не часто используем генераторы, но они являются основой async/await, позволяющей удобно работать с асинхронным кодом.<br> Оператор 'typeof data' возвращает object, а не function. typeof hoCoBan возвращает function, поскольку hoCoBan - обычная функция. Оператор '(typeof data).length' возвращает 6.<br> data.next() вызывает встроенный метод next(), который возвращает значение первого yield, определенного в функции. Получаем 9 - длину строки 'js.edu.vn'.<br> В итоге получаем 15. Понимание работы генераторов важно, если вы хотите понять, как работает async/await."
    },
    {
      "id": "f287bdd1-a0fc-465e-8122-4474649c3cf6",
      "code": "const a = [1, 2, \"chó\", 3, 1, \"chó\", \"mèo\", 3];\n\nconst b = [...new Set(a)];\n\nb.length = \"chó\".length;\n\nconsole.log(b);",
      "answers": {
        "A": "A: 4",
        "B": "B: [1, 2, 'chó', 3, 'mèo']",
        "C": "C: [1, 2, 'chó', 'mèo']",
        "D": "D: [1, 2, 'chó']"
      },
      "right_answer": "D",
      "details": "... в массиве - это оператор распространения (spread), который похож на оператор rest (прочие параметры). Данный оператор позволяет объединять (изменять) и копировать массивы. В примере 'b' - это копия 'a'. Тем не менее, когда мы передаем 'a' в Set, возвращаются только уникальные значения. Это означает, что 'b' содержит [1, 2, 'chó', 3, 'mèo'].<br> Затем мы устанавливаем значение длины 'b' равное 3 ('chó'.length).<br> Таким образом, мы уменьшили длину массива. Вот почему в консоль выводится только [1, 2, 'chó']."
    },
    {
      "id": "842275b0-c1a8-4e07-a76a-dc642bd51e74",
      "code": "const mot = function (m) {\n    return arguments[0];\n};\n\nconst hai = function (...m) {\n    return arguments[arguments[0]];\n};\n\nconst a = [mot(123), hai(1, 2, 3)];\n\nconsole.log(typeof a !== \"object\" ? a[0] : a[1]);",
      "answers": {
        "A": "A: 1",
        "B": "B: 2",
        "C": "C: 3",
        "D": "D: 123"
      },
      "right_answer": "B",
      "details": "Прежде всего, следует заметить, что мы не можем использовать arguments в стрелочных функциях. arguments - это массивоподобный объект, который содержит параметры функции, переданные при ее вызове.<br> ... - это оператор rest (прочие параметры). Мы используем его в функции и массиве. Обратите внимание, что ... в массиве - это оператор распространения (spread), который ведет себя иначе, чем rest. При использовании ... в функции, мы можем передавать ей любое количество параметров.<br> Обратите внимание, что в функции 'hai' мы возвращаем 'arguments[arguments[0]]' или 'hai(1, 2, 3)', или 2, а не 1, поскольку arguments[0] возвращает 1, а arguments[1] - 2.<br> 'typeof a' возвращает 'object'. В итоге мы получаем 2 из a[1] или hai(1, 2, 3)."
    },
    {
      "id": "55ed8c40-3d89-46e6-866e-4385fce817db",
      "code": "class Component {\n    constructor(age) {\n        this.age = age + `${typeof Coder}`.length;\n    }\n\n    getAge() {\n        return ++this.age;\n    }\n}\n\nclass Coder extends Component {\n    constructor(age) {\n        super(age);\n        this.age = age - `${typeof Coder}`.length;\n    }\n}\n\nconst a = new Coder(16);\n\nconsole.log(a.getAge());",
      "answers": {
        "A": "A: 7",
        "B": "B: 8",
        "C": "C: 9",
        "D": "D: 10"
      },
      "right_answer": "C",
      "details": "У нас есть два простых класса, Coder расширяет Component. Ничего особенного. Поскольку 'typeof ClassName' возвращает function, а не class, мы получаем 8 из 'function'.length.<br> Поскольку мы используем super(age) в классе Coder, то перезаписываем конструктор родительского класса Component. Поэтому при инициализации объекта 'a' автоматически выполняется 'this.age = age - `${typeof Coder}`.length'. Разница между дочерним и родительским конструкторами заключается в арифметической операции.<br> Таким образом, мы получаем 16 - 8, а не 16 + 8, т.е. 8. Функция 'getAge()' возвращает 9.<br> Помните, что JavaScript - это не настоящий объектно-ориентированный язык, несмотря на то, что мы можем использовать в нем классы и объекты."
    },
    {
      "id": "745a551e-da2e-4ba9-b6b6-40bc15edefe2",
      "code": "class RemoveFalse {\n    constructor(element) {\n        this.element = element;\n\n        this.length = this.removeFalse().length;\n    }\n\n    removeFalse() {\n        this.element = this.element.filter(Boolean);\n\n        return this.element;\n    }\n}\n\nconst theArray = [true, false, 1, 0, NaN, undefined, \"\", null, \"js.edu.vn\"];\n\nconst a = new RemoveFalse(theArray);\n\nconsole.log(a.length);",
      "answers": {
        "A": "A: false",
        "B": "B: true",
        "C": "C: 2",
        "D": "D: 3"
      },
      "right_answer": "D",
      "details": "Основной вывод, который можно сделать из примера - filter(Boolean) может быть использован для удаления ложных значений в массиве. Для этого мы также можем использовать filter(callback). Обратите внимание, что мы должны передать filter функцию обратного вызова, а Boolean как раз является такой функцией. Вы можете убедиться в этом с помощью typeof Boolean.<br> Как и map или reduce, filter возвращает новый массив из существующего. '[true, false, 1, 0, NaN, undefined, '', null, 'js.edu.vn'].filter(Boolean)' возвращает '[true, 1, 'js.edu.vn']', поэтому вызов функции 'removeFalse()' возвращает 3."
    },
    {
      "id": "ef35c794-db2f-441a-a5ad-d5d09b1065ec",
      "code": "const coderfarm = [1, [], {}, [], 2, 3];\n\nconst converted = Number(coderfarm instanceof Array);\n\nconst result = coderfarm.indexOf(converted + true);\n\nconsole.log(result);",
      "answers": {
        "A": "A: []",
        "B": "B: {}",
        "C": "C: 2",
        "D": "D: 4"
      },
      "right_answer": "D",
      "details": "У нас есть массив, состоящий из нескольких чисел, двух массивов и объекта. Посредством встроенной функции 'Number' мы можем конвертировать любое переданное ей значение в число. 'codefarm instanceof Array' возвращает true, которое преобразуется в 1. Для проверки того, является ли значение массивом, также можно использовать 'Array.isArray(arrayToBeChecked)', возвращающий логическое значение. Оператор 'typeof []' возвращает object, а не array.<br> Встроенная функция 'indexOf' возвращает индекс искомого элемента. Поскольку 'converted + true' возвращает 2, мы ищем индекс элемента 2 в массиве codefarm.<br> Данный элемент находится на 4 позиции."
    },
    {
      "id": "b563b910-d497-4675-9008-5efa731806db",
      "code": "const converter = (arrayInput) => {\n    return { ...arrayInput };\n};\n\nconst content = [\"function\", \"object\", \"decorator\"];\n\nconst checking = content[Number(false)];\n\nconst result = typeof converter(content) === content[1];\n\nconsole.log(checking ? (result ? (typeof converter).length : false) : false);",
      "answers": {
        "A": "A: 6",
        "B": "B: NaN",
        "C": "C: true",
        "D": "D: 8"
      },
      "right_answer": "D",
      "details": "Оператор ... является очень полезным. В функции 'converted' нет ничего необычного, она использует преимущества ... (оператор rest || оператор spread) для преобразования массива в объект.<br> Константа 'checking' имеет значение 'function' из Number(false), что дает 0, т.е. значением checking является элемент массива content с индексом 0.<br> Константа 'result' имеет значение true, поскольку 'typeof converter(content)' возвращает function, как и content[1].<br> Таким образом, мы получаем 'checking = true' и 'result = true', поэтому получаем '(typeof converter).length' или 'function'.length, или 8.<br> Главный вывод здесь такой: мы можем использовать оператор распространения (spread) для преобразования массива в объект. Например: const a = ['hello', 2]; const b = {...a}, получаем b = {0: 'hello', 1: 2}. Ключом объекта в данном случае является индекс элемента в массиве."
    },
    {
      "id": "29f7adb5-ec8c-418e-8dcc-74d584a42cad",
      "code": "function* js(length) {\n    for (let i = length.length; i > 0; --i) {\n        yield i;\n    }\n}\n\nlet getJS = js(typeof js);\n\nlet result = getJS.next().value;\n\nconsole.log(result + getJS.next().value);",
      "answers": {
        "A": "A: 10",
        "B": "B: 14",
        "C": "C: 15",
        "D": "D: 16"
      },
      "right_answer": "C",
      "details": "Здесь мы имеем дело с функцией-генератором, которая определяется с помощью символа '*'.<br> Благодаря ключевому слову 'yield' мы можем хранить в функции любое количество значений.<br> Поскольку 'typeof js' возвращает function, длина этой строки равняется 8. Поэтому при вызове 'getJS.next().value' мы получаем 8. При следующем вызове мы получаем 7, затем 6. Вот почему генератор может хранить и возвращать любое количество значений.<br> В итоге мы получаем 8 + 7 = 15."
    },
    {
      "id": "0e86595d-685c-49de-8b71-79d5b88470a3",
      "code": "var ages = [10, 15, 20, 25];\n\nlet response = [];\n\nages.some(function (currentValue, index, ages) {\n    if (currentValue > ages[ages.length - index])\n        response.push(currentValue + ages.length);\n});\n\nconsole.log(response);",
      "answers": {
        "A": "A: [20]",
        "B": "B: [20, 25]",
        "C": "C: [25, 29]",
        "D": "D: [29]"
      },
      "right_answer": "D",
      "details": "Array.prototype.some() - это встроенная функция, позволяющая перебирать массив с помощью колбека. Колбек в примере имеет три параметра: currentValue (значение текущего элемента массива), index (индекс текущего элемента) и ages (сам массив).<br> Функция some() возвращает логическое значение. Код 'currentValue &gt; ages[ages.length - index]' возвращает true только один раз, поскольку речь идет о последнем элементе. Давайте рассмотрим код последовательно:<br>"
    },
    {
      "id": "a44aa2b6-eec0-4f7c-8721-8e29e354d4fd",
      "code": "const getSTring = (string, method = false) => {\n    if (method === true) {\n        return string.slice(1, 4).length;\n    }\n\n    return string.substr(1, 4).length;\n};\n\nconsole.log(getSTring(\"hello\", true) + getSTring(\"hello\"));",
      "answers": {
        "A": "A: 6",
        "B": "B: 7",
        "C": "C: 8",
        "D": "D: 9"
      },
      "right_answer": "B",
      "details": "getString() - это стрелочная функция с двумя параметрами. Как видите, параметр 'method' имеет значение по умолчанию, равное false, если не передать другое значение при вызове функции, будет использовано значение по умолчанию.<br> Основной вывод: разница между slice(1, 4), возвращающим 3, и substr(1, 4), возвращающим 4.<br> console.log(getSTring('hello', true) + getSTring('hello')) или console.log(string.substr(1, 4).length + string.slice(1, 4).length), или console.log(4 + 3) выводит в консоль 7."
    },
    {
      "id": "41298dd0-a74c-4edd-b573-634f8a1b21b4",
      "code": "(function (a, b, c) {\n    console.log(Boolean([...arguments].slice(2, 3)[0].slice(3, 4)));\n})(\"hello\", \"world\", \"new zealand\");",
      "answers": {
        "A": "A: 'new'",
        "B": "B: true",
        "C": "C: 'land'",
        "D": "D: false"
      },
      "right_answer": "B",
      "details": "Здесь мы имеем дело с самовызываемой функцией (IIFE). Такая функция вызывается сразу после объявления. У нас есть три параметра и три аргумента: 'hello', 'world' и 'new zealand'.<br> Сначала arguments возвращает объект, состоящий из аргументов, переданных функции при ее вызове. С помощью оператора распространения (...spread) мы преобразуем объект в массив. Мы также можем сделать это с помощью 'Array.from(object)'.<br> Далее slice(2, 3) извлекает элемент со второго по третий индекс, т.е. 'new zealand'. Это все еще массив. Затем мы извлекаем элемент с индексом 0 и получаем строку 'new zealand'.<br> Наконец, 'new zealand'.slice(3, 4) возвращает ' ' (пробел). Boolean(' ') возвращает true. Если бы строке не было пробела, мы получили бы false.<br>"
    },
    {
      "id": "07d21804-fda8-4885-b2d1-248a17a63aff",
      "code": "class HocCoBan {\n    name = \"hello world\";\n\n    getSlice(slice) {\n        return this.getName(slice).slice(true, this.name.length);\n    }\n\n    getName(space) {\n        return this.name.split(space);\n    }\n}\n\nHocCoBan.prototype.split = function (argument) {\n    return this.getSlice(argument);\n};\n\nconst a = new HocCoBan();\n\nconsole.log(a.split(\"\").length);",
      "answers": {
        "A": "A: NaN",
        "B": "B: true",
        "C": "C: 10",
        "D": "D: 11"
      },
      "right_answer": "C",
      "details": "В примере нет ничего необычного. Он намеренно запутан. У нас есть класс HocCoBan с двумя методами и одним свойством. Затем мы добавляем к нему еще один метод 'split', используя традиционный способ (через prototype). Помните, что class в JavaScript - это лишь синтаксический сахар function (typeof ClassName возвращает function).<br> При вызове split мы передаем ему пустую строку. Данный метод вызывает другие методы. Порядок следующий:<br> split('') -&gt; this.getSlice('') -&gt; this.getName('') -&gt; this.name.split(''). Здесь split - это функция, преобразующая строку в массив.<br> Обратите внимание, что в getSlice() мы используем '.slice(true, this.name.length)' для модификации массива с 1 по 11 индекс. Длина нового массива равна 10.<br> Данный код помогает понять, как работают прототипы в JavaScript, а также увидеть разницу между встроенными и пользовательскими методами."
    },
    {
      "id": "9c4cefdf-5e58-43e0-95a5-1ad0a21af90d",
      "code": "function javaScript(node) {\n    let mot = node.includes(\"I\") ? \"love\" : \"you\";\n\n    return function (deno = mot) {\n        let hai = node.replace(deno, \"done\");\n\n        return function (done = hai) {\n            return (node + deno + done).length;\n        };\n    };\n}\n\nconsole.log(javaScript(\"I love you\")()());",
      "answers": {
        "A": "A: 18",
        "B": "B: 24",
        "C": "C: 20",
        "D": "D: 25"
      },
      "right_answer": "B",
      "details": "Кроме изучения некоторых встроенных функций для работы со строками, таких как 'replace' и 'includes', здесь мы имеем дело с каррированием. Обратите внимание, что только внешняя (главная) функция имеет название, внутренние функции являются анонимными. У нас также имеется три ключевых слова 'return'.<br> При вызове функции необходимо использовать три пары круглых скобок - javaScript('I love you')()(). Мы не передаем аргументы вложенным функциям, поэтому они используют значения по умолчанию.<br> Результирующим выражением является 'return (node + deno + done).length', где node - 'I love you', deno - 'love' и done - 'I done you'. Результирующая длина равняется 24 (I love youyou I done you). Пробелы также принимаются в расчет."
    },
    {
      "id": "2aed2ddb-9558-43ed-a5b8-79e2b9cd3e47",
      "code": "const www = [\"hello\", \"coranovirus\", \"kiora\", \"world\", \"new zealand\"];\n\nconst found = www.find(function (world) {\n    return world > \"victory\";\n});\n\nconst result = found[1] < www[0][0] ? www[false ? 1 : 0] : www[true ? 0 : 1];\n\nconsole.log(result);",
      "answers": {
        "A": "A: 'hello'",
        "B": "B: 'world'",
        "C": "C: 'victory'",
        "D": "D: 'w'"
      },
      "right_answer": "A",
      "details": "Данный вопрос посвящен методу 'Array.prototype.find()'. Он возвращает первый элемент, удовлетворящий условию, определенному в колбеке, передаваемом функции. Массив перебирается поэлементно. В примере 'world' - это первый элемент, значение которого больше чем значение 'victory'. Запомните, при сравнении 'w' &gt; 'v' возвращается true. При сравнении двух слов, сравниваются только их первые буквы.<br> Значением 'found' является 'world' и поэтому found[1] возвращает 'w', а www[0][0] возвращает 'h' как первую букву 'hello'. Это объясняет, почему found[1] &lt; www[0][0] возвращает false.<br> В итоге мы получаем www[true ? 0 : 1] или www[0], или hello."
    },
    {
      "id": "f4b1f7b5-a57d-4599-8891-7f22e9ea6dbf",
      "code": "(function (flag) {\n    let age = Boolean(NaN === NaN ? false : flag);\n\n    console.log(age.toString()[Number(flag)]);\n})([]);",
      "answers": {
        "A": "A: 'f'",
        "B": "B: 't'",
        "C": "C: true",
        "D": "D: false"
      },
      "right_answer": "B",
      "details": "У нас есть самовызываемая функция с пустым массивом в качестве параметра. Обратите внимание, что NaN === NaN возвращает false, затем переменная 'age' получает значение flag, т.е. пустой массив. Boolean([]) возвращает true.<br> Функция 'toString()' возвращает строку 'true', а Number([]) - 0. Поэтому в консоль выводится 't'.<br> Запомните, что Boolean([]) = true, но Number([]) = 0. И NaN === NaN дает false."
    },
    {
      "id": "03f32c6b-72f7-4198-a83d-84cd08c6157b",
      "code": "console.log(Boolean([]));\nconsole.log(Number([]));\nconsole.log(Number(Boolean([])));\nconsole.log(Boolean(Number([])));\n\nconsole.log(Boolean({}));\nconsole.log(Number({}));\nconsole.log(Number(Boolean({})));\nconsole.log(Boolean(Number({})));\n\nconsole.log(Boolean(new Boolean(false)));",
      "answers": {
        "A": "A: true - 0 - 1 - false - true - 1 - 1 - false - false",
        "B": "B: true - 0 - 1 - false - false - NaN - 1 - false - true",
        "C": "C: true - 0 - 1 - false - false - false - 1 - false - false",
        "D": "D: true - 0 - 1 - false - true - NaN - 1 - false - true"
      },
      "right_answer": "B",
      "details": "JavaScript - это язык со слабой (динамической) типизацией. Тип данных переменной может меняться в зависимости от значения. При изменении одного значения на другое поведение JavaScript может быть весьма неожиданным.<br> Например, Number([]) возвращает 0, Number({}) - NaN, а Boolean([]) и Boolean({}) - true.<br> Boolean(new Boolean(false)) возвращает true, несмотря на то, что мы передаем конструктору функции Boolean значение false. Однако, если мы уберем ключевое слово 'new', то получим false. Boolean(new Boolean(false)) - это валидная операция, поэтому возвращается true. С другой стороны, Boolean(Boolean(false)) без ключевого слова 'new', возвращает false, поскольку значение 'false' не является операцией."
    },
    {
      "id": "b8ce9a11-674c-477c-9e8c-f65767ed9678",
      "code": "const myYoutube = {\n    name: \"hoccoban\",\n    address: \"youtube.com/hoccoban\",\n    getInfo() {\n        return this;\n    },\n    content: () => (this === window ? myYoutube.getInfo() : this),\n};\n\nconsole.log(myYoutube.content().name);",
      "answers": {
        "A": "A: 'hoccoban'",
        "B": "B: window (object)",
        "C": "C: NaN",
        "D": "D: undefined"
      },
      "right_answer": "A",
      "details": "Для того, чтобы правильно ответить на данный вопрос, нужно понимать концепцию this в JavaScript (в браузере). По умолчанию this указывает на объект window. Обратите внимание, что Window (с заглавной буквы) - это конструктор функции объекта window. Поэтому console.log(this === window) возвращает true, а console.log(this === Window) - false.<br> getInfo() - это стрелочная функция, this, объявленный внутри этой функции, указывает на window, поэтому myYoutube.content() возвращает myYoutube.getInfo(). Обратите внимание, что нам пришлось явно писать myYoutube.getInfo() для того, чтобы код работал корректно, поскольку this не указывает на текущий объект. В функции 'getInfo()' this указывает на текущий объект, поскольку getInfo() - это обычная функция.<br> В итоге мы получаем hoccoban как значение свойства name."
    },
    {
      "id": "8dfbf12d-e2d6-4086-91d1-7ee1bb62c60c",
      "code": "const myArray = [1, 2, 3];\n\nmyArray.someProperty = this;\n\nArray.prototype.someOtherProperty = \"hello\";\n\nlet result = [];\n\nfor (let key in myArray) {\n    result.push(key);\n}\n\nfor (let key in myArray) {\n    if (myArray.hasOwnProperty(key)) {\n        result.push(key);\n    }\n}\n\nconsole.log(result.length);",
      "answers": {
        "A": "A: 10",
        "B": "B: NaN",
        "C": "C: 9",
        "D": "D: 7"
      },
      "right_answer": "C",
      "details": "У нас есть простой массив с тремя элементами. При проверке типа массива с помощью typeof мы получаем object (для определения того, что значение является массивом, можно использовать Array.isArray(array) или array instanceof Array).<br> При объявлении myArray.someProperty мы добавляем новое свойство к данному массиву, при объявлении Array.prototype.someProperty = 'hello', мы добавляем новое свойство к каждому массиву.<br> Цикл for... in перебирает массив и возвращает пары ключ/значение, включая унаследованное свойство. На второй итерации мы используем метод hasOwnProperty(key), который перебирает только собственные (не унаследованные) ключи/значения.<br> Если коротко, на первой итерации мы получаем 5 (3 исходных элемента, 1 собственное свойство и еще 1 унаследованное). На второй - только 4 (унаследованное свойство не учитывается).<br> Для перебора массива обычно используется for... of или классический for. Использование for... in для этого является плохой практикой. for... in, как правило, используется для перебора объектов."
    },
    {
      "id": "142a58b6-6be6-4a13-941b-74144281b02d",
      "code": "const coderfarm = [1, 2, 3, 4, 5];\n\nconst [top, ...bottom] = (function (a) {\n    let result = a;\n\n    a.unshift(new Array(3));\n\n    return result;\n})(coderfarm);\n\nconsole.log(top.length + bottom.length);",
      "answers": {
        "A": "A: 8",
        "B": "B: 9",
        "C": "C: 10",
        "D": "D: 11"
      },
      "right_answer": "A",
      "details": "Здесь мы используем деструктуризацию для извлечения значений массива (или объекта) и оператор расптространения (...spread).<br> Деструктурируемый массив возвращается из самовызываемой функции. Сначала мы передаем аргумент 'codefarm' (параметр 'a' в функции). Затем мы обновляем этот массив, добавляя в начало (посредством unshift) массив из трех undefined (с помощью new Array(3)). После этого массив выглядит так: [[undefined, undefined, undefined], 1, 2, 3, 4, 5].<br> Переменная 'top' - это первый элемент массива или [undefined, undefined, undefined], длина которого равняется 3.<br> Переменная 'bottom' - это прочие элементы массива, ее длина равняется 5.<br> В итоге мы получаем 3 + 5 = 8."
    },
    {
      "id": "b9448c3c-b288-4445-b7f9-135fde02949f",
      "code": "let age = { number: 10 };\n\nconst getAge = (flag) => {\n    flag ? delete age.number : delete age;\n    return age.number++;\n};\n\nconsole.log(getAge(false));\n\nconsole.log(age.number);\n\nconsole.log(getAge(true));\n\nconsole.log(age.number);",
      "answers": {
        "A": "A: 10 - 10 - NaN - NaN",
        "B": "B: 10 - 10 - undefined - undefined",
        "C": "C: 10 - 11 - undefined - undefined",
        "D": "D: 10 - 11 - NaN - NaN"
      },
      "right_answer": "D",
      "details": "Оператор 'delete' удаляет свойство объекта, а не сам объект. У нас есть простая функция 'getAge()' с параметром flag. Если значением flag является true, выполняется код 'delete age.number', в противном случае, мы пытаемся удалить объект.<br> Поскольку delete не может удалить объект, можно сказать, что 'delete age' ничего не делает. console.log(getAge(false)) возвращает 10 и затем увеличивает значение age.number на 1. Данное значение хранится в памяти, поэтому console.log(age.number) возвращает 11.<br> Когда мы присваиваем flag значение true, console.log(getAge(true)) выполняет код 'delete age.number', что удаляет свойство age.number. Это означает, что age.number = undefined. Однако, поскольку мы пытаемся увеличить значение на 1 с помощью оператора ++, возвращается NaN."
    },
    {
      "id": "28959741-840c-4696-907d-9509ed74467e",
      "code": "const youtube = { name: \"hoccoban\" };\n\nconst copy = Object.create(youtube);\n\nconst cloneA = Object.assign({}, copy);\n\nconst cloneB = Object.assign({}, youtube);\n\nconsole.log(cloneA.name);\n\nconsole.log(cloneB.name);\n\nconsole.log(copy.name);",
      "answers": {
        "A": "A: undefined - 'hoccoban' - 'hoccoban'",
        "B": "B: 'hoccoban' - 'hoccoban' - 'hoccoban'",
        "C": "C: 'hoccoban' - 'hoccoban' - 'undefined'",
        "D": "D: undefined - 'undefined' - 'hoccoban'"
      },
      "right_answer": "A",
      "details": "Сначала 'console.log(cloneA.name)' выводит в консоль undefined, но почему? Мы используем Object.assign() для получения нового объекта из пустого объекта и объекта 'copy'. Объект 'copy' является копией объекта 'youtube', созданной с помощью Object.create(). Поскольку мы используем Object.create() объект 'copy' наследует данные объекта 'youtube', но сам остается пустым.<br> console.log(cloneB.name) и console.log(copy.name) выводят в консоль 'hoccoban', поскольку 'cloneB.name' имеет собственное свойство 'name', а 'copy.name' наследует свойство 'name' объекта 'youtube'."
    },
    {
      "id": "19f027ad-9528-4fa2-9e2f-51d2bbc0ab30",
      "code": "const strA = 'Привет!'\nlet strB = strA\nstrB = 'Пока!'\nconsole.log(strA)",
      "answers": null,
      "right_answer": null,
      "details": "Привет!"
    },
    {
      "id": "dc5bd983-2f24-47b7-bd98-a0736ceb4f8a",
      "code": "const objA ={ prop: 42 }\nlet objB = objA\nobjB.prop1 = 24\nconsole.log(objA)",
      "answers": null,
      "right_answer": null,
      "details": "{ prop: 24}"
    },
    {
      "id": "8e289247-66b4-427e-9f30-6bed4a3afe49",
      "code": "const objA = { prop: 42 }\nlet objB = objA\nobjB = {}\nconsole.log(objA)",
      "answers": null,
      "right_answer": null,
      "details": "{ prop: 42 }"
    },
    {
      "id": "4bbe8c5c-560a-4633-b64c-78e72d1be386",
      "code": "const arrA = [0, 1, 2, 3, 4, 5]\nlet arrB = arrA\narrB[0] = 42\nconsole.log(arrA)",
      "answers": null,
      "right_answer": null,
      "details": "[42, 1, 2, 3, 4, 5]"
    },
    {
      "id": "c01632ea-ae8d-42f2-8dc4-9f9895554dd7",
      "code": "const arrA = [0, 1, 2, 3, 4, 5]\nlet arrB = arrA.slice()\narrB[0] = 42\nconsole.log(arrA)",
      "answers": null,
      "right_answer": null,
      "details": "[0, 1, 2, 3, 4, 5]"
    },
    {
      "id": "13aa7aa5-fdf8-440f-9e07-71b10d655158",
      "code": "const arrA = [ {prop1: 'элемент массива А'} , {prop2: 'еще один элемент массива А'}, 3, 4, 5 ]\nlet arrB = arrA\narrB[0].prop1 = 42\nconsole.log(arrA)",
      "answers": null,
      "right_answer": null,
      "details": "[ {prop1: 42} , {prop2: 'еще один элемент массива А'}, 3, 4, 5 ]"
    },
    {
      "id": "09abdf46-eff6-43f1-bc14-f0910c6c43a1",
      "code": "const arrA = [ {prop1: 'элемент массива А'} , {prop2: 'еще один элемент массива А'}, 3, 4, 5 ]\nlet arrB = arrA.slice()\narrB[0].prop1 = 42\narrB[3] = 24\nconsole.log(arrA)",
      "answers": null,
      "right_answer": null,
      "details": "[ {prop1: 'элемент массива А'} , {prop2: 'еще один элемент массива А'}, 3, 4, 5 ]"
    },
    {
      "id": "4cc987e8-d0ee-4b46-bb42-1cff465a883e",
      "code": "console.log(id)",
      "answers": null,
      "right_answer": null,
      "details": "ReferenceError: id is not defined"
    },
    {
      "id": "2edd75a2-95fe-438b-8e30-92f64c76a7b4",
      "code": "console.log(id)\nvar id = '123abc'",
      "answers": null,
      "right_answer": null,
      "details": "undefined"
    },
    {
      "id": "50b9fa36-665f-4aeb-bae7-44b747eeebcf",
      "code": "var id = '123abc'\n(function () {\n    console.log(id)\n    var id = '321cba'\n})()",
      "answers": null,
      "right_answer": null,
      "details": "undefined"
    },
    {
      "id": "3c5f43a1-1427-42e4-a7f7-c9715c8c7dcd",
      "code": "var id = '123abc'\n(function () {\n    console.log(id)\n    var id = '321cba'\n    (function () {\n        var id = 'abc123'\n    })()\n})()",
      "answers": null,
      "right_answer": null,
      "details": "undefined"
    },
    {
      "id": "9c1352d7-62fa-4b2d-8fed-309675cc4950",
      "code": "(function () {\n    console.log(typeof f)\n    var f = function () {\n        console.log('Привет, я нахожусь внутри f.')\n    }\n})()",
      "answers": null,
      "right_answer": null,
      "details": "undefined"
    },
    {
      "id": "65a8327a-df01-4567-a244-6ace64e8c4df",
      "code": "var id = '123abc'\nfunction foo () {\n    id = 'abc123'\n    return;\n}\nfoo()\nconsole.log(id)",
      "answers": null,
      "right_answer": null,
      "details": "abc123"
    },
    {
      "id": "c82ea5cd-5d0e-4e51-beb2-4fcc1dd64605",
      "code": "var id = '123abc'\n\nfunction foo () {\n    id = 'abc123'\n    return;\n\n    function id () {}\n}\nfoo()\nconsole.log(id)",
      "answers": null,
      "right_answer": null,
      "details": "123abc"
    },
    {
      "id": "022f4a38-3753-4e58-8675-00793e106a13",
      "code": "var id = '123abc'\n\nfunction foo () {\n    id = 'abc123'\n    return;\n\n    function id () {\n        console.log(typeof id)\n    }\n}\nfoo()",
      "answers": null,
      "right_answer": null,
      "details": "function"
    },
    {
      "id": "67763dc5-697b-4b89-93c8-9976eb1574c4",
      "code": "function foo () {\n    id()\n    var product = 'Автомобиль'\n    return;\n\n    function id () {\n        console.log(product)\n    }\n}\n\nfoo()",
      "answers": null,
      "right_answer": null,
      "details": "undefined"
    },
    {
      "id": "bce0e31f-a5e5-419d-9a59-6e2d8275f23e",
      "code": "(function foo () {\n    bar()\n\n    function bar () {\n        baz()\n        console.log(typeof baz)\n    }\n\n    function baz() {\n        console.log(typeof bar)\n    }\n})()",
      "answers": null,
      "right_answer": null,
      "details": "function function"
    },
    {
      "id": "510c0105-1f0b-4f59-81b5-2962343edcc2",
      "code": "(function () {\n    'use strict'\n\n    var person = {\n        name: 'Ванька'\n    }\n    person.salary = '100000'\n    person['country'] = 'Россия'\n\n    Object.defineProperty(person, 'phone', {\n        value: '+123456789',\n        enumerable: true\n    })\n\n    console.log(Object.keys(person))\n})()",
      "answers": null,
      "right_answer": null,
      "details": "[ 'name', 'salary', 'country', 'phone' ]"
    },
    {
      "id": "4df25fd4-e713-49f1-9a13-a4deb31dcb3d",
      "code": "(function () {\n    'use strict'\n\n    var person = {\n        name: 'Ванька'\n    }\n    person.salary = '100000'\n    person['country'] = 'Россия'\n\n    Object.defineProperty(person, 'phone', {\n        value: '+123456789',\n        enumerable: false\n    })\n\n    console.log(Object.keys(person))\n}())",
      "answers": null,
      "right_answer": null,
      "details": "[ 'name', 'salary', 'country' ]"
    },
    {
      "id": "61ce07d5-e4cf-4361-95fa-ce7c044f3302",
      "code": "(() => {\n    const objA = {\n        foo: 'foo',\n        bar: 'bar'\n    }\n    const objB = {\n        foo: 'foo',\n        bar: 'bar'\n    }\n\n    console.log(objA == objB)\n    console.log(objA === objB)\n})()",
      "answers": null,
      "right_answer": null,
      "details": "false false"
    },
    {
      "id": "77a4a08f-b0ab-4e11-95e5-d219ea1f3dbc",
      "code": "(() => {\n    const objA = new Object({ foo: 'foo' })\n    const objB = new Object({ foo: 'foo' })\n\n    console.log(objA == objB)\n    console.log(objA === objB)\n})()",
      "answers": null,
      "right_answer": null,
      "details": "false false"
    },
    {
      "id": "4dbacc59-19a6-4a78-aebe-83281be3fceb",
      "code": "(() => {\n    const objA = Object.create({\n        foo: 'foo'\n    })\n    const objB = Object.create({\n        foo: 'foo'\n    })\n\n    console.log(objA == objB)\n    console.log(objA === objB)\n})()",
      "answers": null,
      "right_answer": null,
      "details": "false false"
    },
    {
      "id": "d173ead9-d958-4c74-888f-6faa85860410",
      "code": "!function () {\n    const objA = Object.create({\n        foo: 'foo'\n    })\n    const objB = Object.create(objA)\n\n    console.log(objA == objB)\n    console.log(objA === objB)\n}()",
      "answers": null,
      "right_answer": null,
      "details": "false false true"
    },
    {
      "id": "a783bfd6-6fc1-4339-b55c-fed3c3a94aa4",
      "code": "(function () {\n    const objA = Object.create({\n        foo: 'foo'\n    })\n    const objB = Object.create(objA)\n\n    console.log(objA.toString() == objB.toString())\n    console.log(objA.toString() === objB.toString())\n}())",
      "answers": null,
      "right_answer": null,
      "details": "true true"
    },
    {
      "id": "fd0fc805-b0eb-4caf-8b5a-20b58cbb0043",
      "code": "+function () {\n    const objA = Object.create({\n        foo: 'foo'\n    })\n    const objB = objA\n\n    console.log(objA == objB)\n    console.log(objA === objB)\n\n    console.log(objA.toString() == objB.toString())\n    console.log(objA.toString() === objB.toString())\n}()",
      "answers": null,
      "right_answer": null,
      "details": "true true true true NaN"
    },
    {
      "id": "c64b03f9-27c9-4377-b372-1a2c89397ca7",
      "code": "(() => {\n    const objA = Object.create({\n        foo: 'foo'\n    })\n    const objB = objA\n\n    objB.foo = 'bar'\n\n    console.log(objA.foo)\n    console.log(objB.foo)\n})()",
      "answers": null,
      "right_answer": null,
      "details": "bar bar"
    },
    {
      "id": "608f1709-6b98-4bdd-aebf-b8ef04d5849d",
      "code": "new function () {\n    const objA = Object.create({\n        foo: 'foo'\n    })\n    const objB = objA\n\n    objB.foo = 'bar'\n\n    delete objA.foo\n\n    console.log(objA.foo)\n    console.log(objB.foo)\n}",
      "answers": null,
      "right_answer": null,
      "details": "foo foo {}"
    },
    {
      "id": "36eddb8a-2eae-446a-be29-2216309e12f0",
      "code": "new function () {\n    const objA = {\n        foo: 'foo'\n    }\n    const objB = objA\n\n    objB.foo = 'bar'\n\n    delete objA.foo\n\n    console.log(objA.foo)\n    console.log(objB.foo)\n}()",
      "answers": null,
      "right_answer": null,
      "details": "undefined undefined {}"
    },
    {
      "id": "56408198-ff93-4cf4-a858-23aee80eac9f",
      "code": "(() => {\n    const array = new Array('100')\n    console.log(array)\n    console.log(array.length)\n})()",
      "answers": null,
      "right_answer": null,
      "details": "['100'] 1"
    },
    {
      "id": "f8ffe345-9472-44a8-a560-8f23eebabb21",
      "code": "(() => {\n    const array1 = []\n    const array2 = new Array(100)\n    const array3 = new Array(['1', 2, '3', 4, 5.6])\n\n    console.log(\n        array1,\n        array2,\n        array3,\n        array3.length\n    )\n})()",
      "answers": null,
      "right_answer": null,
      "details": "Зависит от браузера. В Chrome выводится следующее: [] (100)&nbsp;[empty × 100] [Array(5)] 1"
    },
    {
      "id": "6a393c76-3251-4d80-87f3-569aa1b6657e",
      "code": "(() => {\n    const array = new Array('a', 'b', 'c', 'd', 'e')\n    array[10] = 'f'\n    delete array[10]\n    console.log(array.length)\n})()",
      "answers": null,
      "right_answer": null,
      "details": "11"
    },
    {
      "id": "f479a3ae-52fd-4145-8266-320783437080",
      "code": "(() => {\n    const animals = ['корова', 'лошадь']\n\n    animals.push('кошка')\n    animals.push('собака', 'осел', 'козел')\n    console.log(animals.length)\n})()",
      "answers": null,
      "right_answer": null,
      "details": "6"
    },
    {
      "id": "88535190-30f4-42fd-a0c0-e496c1efc4d1",
      "code": "(() => {\n    const animals = ['корова', 'лошадь']\n\n    animals.push('кошка')\n    animals.unshift('собака', 'осел', 'козел')\n    console.log(animals)\n})()",
      "answers": null,
      "right_answer": null,
      "details": "['собака', 'осел', 'козел', 'корова', 'лошадь', 'кошка']"
    },
    {
      "id": "e1e2eb5e-8ac0-49d5-b256-196d1dab1e55",
      "code": "(() => {\n    const array = [1,2,3,4,5]\n\n    console.log(array.indexOf(2))\n\n    console.log([{ name: 'Ванька' }, { name: 'Петька' }].indexOf({ name: 'Ванька' }))\n\n    console.log([[1],[2],[3],[4]].indexOf(2))\n\n    console.log('abcdef'.indexOf('c'))\n})()",
      "answers": null,
      "right_answer": null,
      "details": "1 -1 -1 2"
    },
    {
      "id": "252f3a8c-0259-4ca7-9a14-dc67ec0c08ca",
      "code": "(() => {\n    const array = [1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 6]\n\n    console.log(array.indexOf(2))\n    console.log(array.indexOf(2,3))\n    console.log(array.indexOf(2,10))\n})()",
      "answers": null,
      "right_answer": null,
      "details": "1 6 -1"
    },
    {
      "id": "5f7a8e50-5c7f-4ca0-ac8b-78476c55a1ed",
      "code": "(() => {\n    const nums = [2, 3, 4, 8, 9, 11, 13, 12, 16]\n\n    const even = nums.filter((el, i) => el % 2 === 0)\n    console.log(even)\n\n    const divBy3 = nums.some((el, i) => el % 3 === 0)\n    console.log(divBy3)\n})()",
      "answers": null,
      "right_answer": null,
      "details": "[2, 4, 8, 12, 16] true"
    },
    {
      "id": "1d38f791-f919-4548-880e-27451070cd4a",
      "code": "(() => {\n    var array = [2, 0, false, '', '12', true]\n\n    var array = array.filter(Boolean)\n    console.log(array)\n\n    var array = array.filter(Number)\n    console.log(array)\n\n    var array = array.filter(String)\n    console.log(array)\n\n    var array = array.filter(Object)\n    console.log(array)\n})()",
      "answers": null,
      "right_answer": null,
      "details": "[2,'12',true] <br> [2,'12',true] <br> [2,'12',true] <br> [2,'12',true]"
    },
    {
      "id": "5a788198-0cc3-4ab6-95cf-3cfb7e043786",
      "code": "(() => {\n    const list = ['foo', 'bar', 'baz', 'qux']\n\n    console.log(`\n    ${list.slice(1)}\n\n    ${list.slice(1,3)}\n\n    ${list.slice()}\n\n    ${list.slice(2,2)}\n\n    ${list}\n    `)\n})()",
      "answers": null,
      "right_answer": null,
      "details": "bar, baz, qux <br> bar, baz <br> foo, bar, baz, qux <br> (пусто) <br> foo, bar, baz, qux <br>"
    },
    {
      "id": "64997e30-f3fc-4410-879f-4a53aefb3fe0",
      "code": "(() => {\n    const list = ['foo', 'bar', 'baz']\n\n    console.log(`\n    ${list.splice(1)}\n\n    ${list.slice(1,2)}\n\n    ${list}\n    `)\n})()",
      "answers": null,
      "right_answer": null,
      "details": "bar, baz <br> (пусто) <br> foo <br>"
    },
    {
      "id": "4a8ac917-614a-45bd-ab4f-5023adc54e11",
      "code": "(() => {\n    const nums = [2, 8, 15, 16, 23, 42]\n    nums.sort().reverse()\n    console.log(nums)\n\n    nums.reverse().sort((x, y) => x - y)\n    console.log(nums)\n})()",
      "answers": null,
      "right_answer": null,
      "details": "[8, 42, 23, 2, 16, 15] [2, 8, 15, 16, 23, 42]"
    },
    {
      "id": "7dc5a857-0ba5-4f84-9feb-060d77002585",
      "code": "function f1 () {\n    console.log('f1', this)\n    ;(function f2 () {\n        console.log('f2', this)\n        ;(function f3 () {\n            console.log('f3', this)\n        })()\n    })()\n}\n\nf1()",
      "answers": null,
      "right_answer": null,
      "details": "f1 Window&nbsp;{…} <br> f2 Window&nbsp;{…} <br> f3 Window&nbsp;{…}"
    },
    {
      "id": "b8b15712-0502-4b43-9be3-025e83fea6bd",
      "code": "const obj = {\n    message: 'Привет!',\n    innerMessage: !(() => {\n        console.log(this.message)\n    })()\n}\n\nobj.innerMessage()",
      "answers": null,
      "right_answer": null,
      "details": "undefined true"
    },
    {
      "id": "265e1828-6a2e-4125-8d0f-8e65ecb800f2",
      "code": "const obj = {\n    message: 'Привет!',\n    innerMessage: function () {\n        console.log(this.message)\n    }\n}\n\nconsole.log(obj.innerMessage())",
      "answers": null,
      "right_answer": null,
      "details": "Привет!"
    },
    {
      "id": "47287416-ad42-45a7-85f3-04579efce47c",
      "code": "const obj = {\n    message: 'Привет!',\n    innerMessage: () => {\n        (() => {\n            console.log(this.message)\n        })()\n    }\n}\nobj.innerMessage()",
      "answers": null,
      "right_answer": null,
      "details": "undefined"
    },
    {
      "id": "2c90db0b-79d4-4f24-8090-31f809217047",
      "code": "const obj = {\n    message: 'Привет!',\n    innerMessage: function () {\n        const self = this\n        ;(function () {\n            console.log(self.message)\n        })()\n    }\n}\nobj.innerMessage()",
      "answers": null,
      "right_answer": null,
      "details": "Привет!"
    },
    {
      "id": "518f99f7-1d14-4d3e-aeab-035722494515",
      "code": "function f () {\n    console.log(this.message)\n}\nf.message = 'Привет!'\n\nf()\nf.call(f)",
      "answers": null,
      "right_answer": null,
      "details": "undefined Привет!"
    },
    {
      "id": "7b5ca50c-0fd3-4760-9f17-ed313e9357fb",
      "code": "function f () {\n    console.log(f.message)\n}\nf.message = 'Привет!'\n\nf()\nf.bind(f)",
      "answers": null,
      "right_answer": null,
      "details": "Привет! f () {...}"
    },
    {
      "id": "e1a7fa31-78b8-427f-88d5-6f3a62bf6bcd",
      "code": "function f1 () {\n    f1.message = 'Привет!'\n    console.log(f1.message)\n}\nfunction f2 () {\n    f2.message = 'Пока!'\n}\nf1()\nf1.bind(f2)()",
      "answers": null,
      "right_answer": null,
      "details": "Привет! Привет!"
    },
    {
      "id": "8ccd44db-5833-4d68-a7ee-ed32ef1ec771",
      "code": "function f1 (par1, par2) {\n    console.log(arguments.length)\n    console.log(arguments)\n}\nfunction f2 (...rest) {\n    console.log(rest.length)\n    console.log(rest)\n}\n\nf1()\nf1(1, 2)\nf1(1, 2, 3, 4)\n\nf2()\nf2(1, 2)\nf2(1, 2, 3, 4)",
      "answers": null,
      "right_answer": null,
      "details": "2 [] 2 [1, 2] 2 [1, 2, 3, 4] <br> 0 [] 0 [1, 2] 0 [1, 2, 3, 4]"
    },
    {
      "id": "c902a864-4227-411e-b78d-79c7dabb2f3f",
      "code": "function f1 (par1, par2) {\n    console.log(arguments.length)\n}\nfunction f2 (...rest) {\n    console.log(rest.length)\n}\n\nf1()\nf1(1,2)\nf1(1,2,3,4)\n\nf2()\nf2(1,2)\nf2(1,2,3,4)",
      "answers": null,
      "right_answer": null,
      "details": "0 2 4 0 2 4"
    },
    {
      "id": "cb9ef554-7de3-4687-87ba-e79b30e26791",
      "code": "function f () {\n    const password = '12345'\n    this.name = 'Ванька'\n    return {\n        pwd: password\n    }\n}\nconst info = f()\nconsole.log(info.pwd)\nconsole.log(info.name)",
      "answers": null,
      "right_answer": null,
      "details": "12345 undefined"
    },
    {
      "id": "373ae4df-aba9-4576-ac0a-132c9b267d80",
      "code": "const id = '123abc'\nfunction F () {\n    this.id = 'abc123'\n}\nconsole.log(F.id)",
      "answers": null,
      "right_answer": null,
      "details": "undefined"
    },
    {
      "id": "f69be9be-7e0f-4d8c-8d5d-dc1bd154e6d2",
      "code": "const foo = 'foo'\nfunction F () {\n    this.foo = 'bar'\n}\nconsole.log(new F().foo)\n\nF.prototype.foo = 'baz'\nF.prototype.bar = 'qux'\nconsole.log(new F().bar)\nconsole.log(new F().foo)",
      "answers": null,
      "right_answer": null,
      "details": "bar qux bar"
    },
    {
      "id": "2f4319dd-2ab7-4ba9-9d5e-40273c3b9b4f",
      "code": "const foo = 'foo'\n;(function F () {\n    try {\n        throw 'bar'\n    } catch (foo) {\n        console.log(foo)\n    }\n    console.log(foo)\n})()",
      "answers": null,
      "right_answer": null,
      "details": "bar foo"
    },
    {
      "id": "8a8cdc1a-3d64-45c1-aabd-5578483861af",
      "code": "(() => {\n    const greet = 'Привет, народ!'\n    const toGreet = [].filter.call(greet, (el, i) => i < 6)\n    console.log(toGreet)\n})()",
      "answers": null,
      "right_answer": null,
      "details": "['П', 'р', 'и', 'в', 'е', 'т']"
    },
    {
      "id": "1b8ed487-2e51-463b-ac3e-4cafd0327afb",
      "code": "(() => {\n    const foo = {\n        name: 'foo',\n        amount: 4000,\n        deduct: function (amount) {\n            this.amount -= amount\n            return `Осталось ${this.amount}`\n        }\n    }\n\n    const bar = {\n        name: 'bar',\n        amount: 6000\n    }\n\n    const amountBy = total =>\n        foo.deduct.bind(bar, total)\n\n    console.log(amountBy(1000)())\n    console.log(amountBy(2000)())\n})()",
      "answers": null,
      "right_answer": null,
      "details": "Осталось 5000 Осталось 3000"
    },
    {
      "id": "ad7373cc-8d4d-4d8e-9326-e56718fb43f6",
      "code": "(() => {\n    const foo = {\n        name: 'foo',\n        amount: 4000,\n        deduct: function (amount) {\n            this.amount -= amount\n            return `Осталось ${this.amount}`\n        }\n    }\n\n    const bar = {\n        name: 'bar',\n        amount: 6000\n    }\n\n    const amountBy = total =>\n        foo.deduct.apply(bar, [total])\n\n    console.log(amountBy(1000))\n    console.log(amountBy(2000))\n})()",
      "answers": null,
      "right_answer": null,
      "details": "Осталось 5000 Осталось 3000"
    },
    {
      "id": "0245a7eb-6128-4177-a2d1-9b7c2f9779c0",
      "code": "const user1 = (name = 'Ванька', age = 24) => ({\n    name,\n    age,\n    getInfo() {\n        console.log(`${this.name} ${this.age}`)\n    }\n})\n\nconst user2 = (name = 'Петька', age = 42) => ({name, age})\n\nuser1().getInfo()\nuser1().getInfo.bind(user2())()\nuser1().getInfo.call(user2('Васька', 30))",
      "answers": null,
      "right_answer": null,
      "details": "Ванька 24 <br> Петька 42 <br> Васька 30"
    },
    {
      "id": "033e4253-2638-4933-b9e5-19bf6c8d3bfd",
      "code": "(function () {\n    console.log(`Привет, ${this.name}!`)\n}.bind({\n    name: 'Ванька'\n}))()\n\n;(function () {\n    console.log(`Пока, ${this.name}!`)\n}).call({\n    name: 'Петька'\n})",
      "answers": null,
      "right_answer": null,
      "details": "Привет, Ванька! <br> Пока, Петька!"
    },
    {
      "id": "90f13bce-f923-4ca7-bff5-aab2a4222965",
      "code": "function getData () {\n    const name = 'Ванька'\n    return {\n        then: function (f) {\n            f(name)\n        }\n    }\n}\n\ngetData().then(name => console.log(name))",
      "answers": null,
      "right_answer": null,
      "details": "Ванька"
    },
    {
      "id": "6e7a2060-af2a-402b-a956-4ca4cf249f48",
      "code": "(() => {\n    const nums = [2, 8, 15, 16, 23, 42]\n    Array.prototype.sort = (a, b) => a - b\n    nums.sort()\n    console.log(nums)\n})()\n\n;(() => {\n    const nums = [2, 8, 15, 16, 23, 42]\n    nums.sort((a, b) => {\n        (a === b)\n            ? 0\n            : a < b ? -1 : 1\n    })\n    console.log(nums)\n})()\n\n;(() => {\n    const nums = [2, 8, 15, 16, 23, 42]\n    nums.sort((a, b) => b - a)\n    console.log(nums)\n})()",
      "answers": null,
      "right_answer": null,
      "details": "[ 2, 8, 15, 16, 23, 42 ] <br> [ 2, 8, 15, 16, 23, 42 ] <br> [ 2, 8, 15, 16, 23, 42 ]"
    },
    {
      "id": "d0027d86-e043-498b-ba1c-4e9112964729",
      "code": "(() => {\n    function hello () {\n        const name = 'Ванька'\n        return\n        {\n            greet: `Привет, ${name}!`\n        }\n    }\n    console.log(hello().greet)\n})()",
      "answers": null,
      "right_answer": null,
      "details": "TypeError: Cannot read property 'greet' of undefined"
    },
    {
      "id": "cd4b30a4-4199-4337-87f1-c17ece939484",
      "code": "function getNums () {\n    return (2, 3, 4)\n}\nconst nums = getNums()\nconsole.log(nums)",
      "answers": null,
      "right_answer": null,
      "details": "4"
    },
    {
      "id": "603f83a0-c0f8-4bf2-8d9a-ff94a5ca9b2d",
      "code": "function getNum () {\n    return\n}\nconst num = getNum()\nconsole.log(num)",
      "answers": null,
      "right_answer": null,
      "details": "undefined"
    },
    {
      "id": "76403f64-4835-47b8-9389-9cea1877e878",
      "code": "function mult(x) {\n    return function (y) {\n        return [x * y, function (z) {\n            return x * y + z\n        }]\n    }\n}\nconsole.log(mult(2)(3)[0])\nconsole.log(mult(2)(3)[1](4))",
      "answers": null,
      "right_answer": null,
      "details": "6 10"
    },
    {
      "id": "258fca05-3125-4dc7-97c6-a10687873899",
      "code": "function mult(x) {\n    return function (y) {\n        return {\n            result: x * y,\n            add: function (z) {\n                return x * y + z\n            }\n        }\n    }\n}\nconsole.log(mult(2)(3).result)\nconsole.log(mult(2)(3).add(4))",
      "answers": null,
      "right_answer": null,
      "details": "6 10"
    },
    {
      "id": "81bf1a39-4659-4cf5-a50b-50f7c60d4088",
      "code": "const calc = a => b => c => d => {\n    switch (d) {\n        case '*': return a * b * c\n        case '/': return a / b / c\n        case '+': return a + b + c\n        case '-': return a - b - c\n        default: return 'Некорректная операция!'\n    }\n}\n\nconsole.log(calc(1)(2)(3)('*'))\nconsole.log(calc(2)(3)(4)('+'))\nconsole.log(calc(6)(3)(1)('-'))\nconsole.log(calc(6)(3)(2)('x'))",
      "answers": null,
      "right_answer": null,
      "details": "6 9 2 Некорректная операция!"
    },
    {
      "id": "638c1967-610a-4aa0-9bc0-5443e5b6c79a",
      "code": "function getName1() {\n    console.log(this.name)\n}\n\nObject.prototype.getName2 = () => console.log(this.name)\n\nconst person = {\n    name: 'Ванька',\n    displayName: getName1\n}\n\nperson.displayName()\nperson.getName2()",
      "answers": null,
      "right_answer": null,
      "details": "Ванька undefined"
    }
  ]
}
