[
  {
    "_id": "64518e2a78a3eb63645a9b79",
    "parentId": "64518e2a78a3eb63645a9b78",
    "content_type": "text",
    "order": 0,
    "content_data": "Существует несколько способов это сделать. Вот некоторые из них:"
  },
  {
    "_id": "64518e2a78a3eb63645a9b7a",
    "parentId": "64518e2a78a3eb63645a9b78",
    "content_type": "text",
    "order": 1,
    "content_data": "Литерал объекта:"
  },
  {
    "_id": "64518e2a78a3eb63645a9b7b",
    "parentId": "64518e2a78a3eb63645a9b78",
    "content_type": "code",
    "order": 2,
    "content_data": "const object = {}"
  },
  {
    "_id": "64518e2a78a3eb63645a9b7c",
    "parentId": "64518e2a78a3eb63645a9b78",
    "content_type": "text",
    "order": 3,
    "content_data": "Конструктор объекта (использовать не рекомендуется):"
  },
  {
    "_id": "64518e2a78a3eb63645a9b7d",
    "parentId": "64518e2a78a3eb63645a9b78",
    "content_type": "code",
    "order": 4,
    "content_data": "const object = new Object()"
  },
  {
    "_id": "64518e2a78a3eb63645a9b7e",
    "parentId": "64518e2a78a3eb63645a9b78",
    "content_type": "text",
    "order": 5,
    "content_data": "Метод Object.create()"
  },
  {
    "_id": "64518e2a78a3eb63645a9b7f",
    "parentId": "64518e2a78a3eb63645a9b78",
    "content_type": "text",
    "order": 6,
    "content_data": "При использовании данного метода ему в качестве аргумента передается объект, который станет прототипом нового объекта."
  },
  {
    "_id": "64518e2a78a3eb63645a9b80",
    "parentId": "64518e2a78a3eb63645a9b78",
    "content_type": "code",
    "order": 7,
    "content_data": "// создаем объект без прототипа - пустой объект\nconst object = Object.create(null)"
  },
  {
    "_id": "64518e2a78a3eb63645a9b81",
    "parentId": "64518e2a78a3eb63645a9b78",
    "content_type": "text",
    "order": 8,
    "content_data": "Функция-конструктор"
  },
  {
    "_id": "64518e2a78a3eb63645a9b82",
    "parentId": "64518e2a78a3eb63645a9b78",
    "content_type": "text",
    "order": 9,
    "content_data": "Создаем функцию-конструктор и применяем оператор \"new\" для создания экземпляра этой функции - объекта:"
  },
  {
    "_id": "64518e2a78a3eb63645a9b83",
    "parentId": "64518e2a78a3eb63645a9b78",
    "content_type": "code",
    "order": 10,
    "content_data": "function Person (name) {\n    const object = {}\n    object.name = name\n    object.age = 30\n    return object\n}\nconst user = new Person('Ванька')"
  },
  {
    "_id": "64518e2a78a3eb63645a9b84",
    "parentId": "64518e2a78a3eb63645a9b78",
    "content_type": "text",
    "order": 11,
    "content_data": "Класс:"
  },
  {
    "_id": "64518e2a78a3eb63645a9b85",
    "parentId": "64518e2a78a3eb63645a9b78",
    "content_type": "code",
    "order": 12,
    "content_data": "class Person {\n    constructor(name) {\n        this.name = name\n    }\n}\n\nconst user = new Person('Ванька')"
  },
  {
    "_id": "64518e2a78a3eb63645a9b89",
    "parentId": "64518e2a78a3eb63645a9b88",
    "content_type": "text",
    "order": 0,
    "content_data": "Прототипы используется для создания новых объектов на основе существующих. Такая техника называется прототипным наследованием. Прототип экземпляра объекта доступен через Object.getProtocontentTypeOf(object) или свойство __proto__ (внутреннее скрытое свойство [[ProtocontentType]]).",
    "content_image": "prototype.png"
  },
  {
    "_id": "64518e2a78a3eb63645a9b8d",
    "parentId": "64518e2a78a3eb63645a9b8c",
    "content_type": "text",
    "order": 0,
    "content_data": "Разницу между данными методами проще всего объяснить с помощью примеров."
  },
  {
    "_id": "64518e2a78a3eb63645a9b8e",
    "parentId": "64518e2a78a3eb63645a9b8c",
    "content_type": "text",
    "order": 1,
    "content_data": "Метод call() вызывает функцию с указанным значением this и аргументами через запятую."
  },
  {
    "_id": "64518e2a78a3eb63645a9b8f",
    "parentId": "64518e2a78a3eb63645a9b8c",
    "content_type": "code",
    "order": 2,
    "content_data": "const employee1 = { firstName: 'Иван', lastName: 'Иванов' }\nconst employee2 = { firstName: 'Петр', lastName: 'Петров' }\n\nfunction invite (greet1, greet2) {\n    console.log(`${greet1}, ${this.firstName} ${this.lastName}. ${greet2}`)\n}\n\ninvite.call(employee1, 'Привет', 'Как дела?') // Привет, Иван Иванов. Как дела?\ninvite.call(employee2, 'Привет', 'Как дела?') // Привет, Петр Петров. Как дела?"
  },
  {
    "_id": "64518e2a78a3eb63645a9b90",
    "parentId": "64518e2a78a3eb63645a9b8c",
    "content_type": "text",
    "order": 3,
    "content_data": "Метод apply() вызывает функцию с указанным значением this и аргументами в виде массива."
  },
  {
    "_id": "64518e2a78a3eb63645a9b91",
    "parentId": "64518e2a78a3eb63645a9b8c",
    "content_type": "code",
    "order": 4,
    "content_data": "const employee1 = { firstName: 'Иван', lastName: 'Иванов' }\nconst employee2 = { firstName: 'Петр', lastName: 'Петров' }\n\nfunction invite (greet1, greet2) {\n    console.log(`${greet1}, ${this.firstName} ${this.lastName}. ${greet2}`)\n}\n\ninvite.apply(employee1, ['Привет', 'Как дела?']) // Привет, Иван Иванов. Как дела?\ninvite.apply(employee2, ['Привет', 'Как дела?']) // Привет, Петр Петров. Как дела?"
  },
  {
    "_id": "64518e2a78a3eb63645a9b92",
    "parentId": "64518e2a78a3eb63645a9b8c",
    "content_type": "text",
    "order": 5,
    "content_data": "Метод bind() возвращает новую функцию с указанным значением this и позволяет передать ей массив или любое количество аргументов через запятую."
  },
  {
    "_id": "64518e2a78a3eb63645a9b93",
    "parentId": "64518e2a78a3eb63645a9b8c",
    "content_type": "code",
    "order": 6,
    "content_data": "const employee1 = { firstName: 'Иван', lastName: 'Иванов' }\nconst employee2 = { firstName: 'Петр', lastName: 'Петров' }\n\nfunction invite (greet1, greet2) {\n    console.log(`${greet1}, ${this.firstName} ${this.lastName}. ${greet2}`)\n}\n\nconst inviteEmployee1 = invite.bind(employee1)\nconst inviteEmployee2 = invite.bind(employee2)\ninviteEmployee1('Привет', 'Как дела?') // Привет, Иван Иванов. Как дела?\ninviteEmployee2('Привет', 'Как дела?') // Привет, Петр Петров. Как дела?"
  },
  {
    "_id": "64518e2a78a3eb63645a9b94",
    "parentId": "64518e2a78a3eb63645a9b8c",
    "content_type": "text",
    "order": 7,
    "content_data": "Таким образом, методы call() и apply() вызывают функцию после ее привязки к объекту. Разница между ними состоит в способе передачи аргументов. Эту разницу легко запомнить при помощи первых букв методов: call - это запятая (comma, c), apply - массив (array, a). Метод bind() возвращает новую функцию, привязанную к указаному объекту."
  },
  {
    "_id": "64518e2a78a3eb63645a9b9b",
    "parentId": "64518e2a78a3eb63645a9b9a",
    "content_type": "text",
    "order": 0,
    "content_data": "JSON - это текстовый формат данных, основанный на синтаксисе объектов JavaScript, изобретенный Дугласом Крокфордом. Он используется для передачи данных по сети и, обычно, имеет расширение .json и MIME-тип application/json."
  },
  {
    "_id": "64518e2a78a3eb63645a9b9c",
    "parentId": "64518e2a78a3eb63645a9b9a",
    "content_type": "text",
    "order": 1,
    "content_data": "Разбор (парсинг): преобразует строку в формате JSON в объект."
  },
  {
    "_id": "64518e2a78a3eb63645a9b9d",
    "parentId": "64518e2a78a3eb63645a9b9a",
    "content_type": "code",
    "order": 2,
    "content_data": "JSON.parse(text)"
  },
  {
    "_id": "64518e2a78a3eb63645a9b9e",
    "parentId": "64518e2a78a3eb63645a9b9a",
    "content_type": "text",
    "order": 3,
    "content_data": "Стрингификация: преобразует объект в строку в формате JSON для передачи по сети."
  },
  {
    "_id": "64518e2a78a3eb63645a9b9f",
    "parentId": "64518e2a78a3eb63645a9b9a",
    "content_type": "code",
    "order": 4,
    "content_data": "JSON.stringify(object)"
  },
  {
    "_id": "64518e2a78a3eb63645a9ba3",
    "parentId": "64518e2a78a3eb63645a9ba2",
    "content_type": "text",
    "order": 0,
    "content_data": "Метод slice() возвращает выбранные элементы массива в виде нового массива. Он возвращает элементы, начиная с индекса, указанного в первом аргументе, и заканчивая, но не включая, индексом, указанном во втором необязательном аргументе. Если второй аргумент отсутствует, то будут извлечены все элементы, начиная с индекса, указанного в первом аргументе."
  },
  {
    "_id": "64518e2a78a3eb63645a9ba4",
    "parentId": "64518e2a78a3eb63645a9ba2",
    "content_type": "code",
    "order": 1,
    "content_data": "const arrayIntegers = [1, 2, 3, 4, 5]\nconst arrayIntegers1 = arrayIntegers.slice(0, 2) // [1, 2]\nconst arrayIntegers2 = arrayIntegers.slice(2, 3) // [3]\nconst arrayIntegers3 = arrayIntegers.slice(4) // [5]"
  },
  {
    "_id": "64518e2a78a3eb63645a9ba5",
    "parentId": "64518e2a78a3eb63645a9ba2",
    "content_type": "text",
    "order": 2,
    "content_data": "Обратите внимание, что данный метод не изменяет исходный массив, а лишь возвращает его подмножество в виде нового массива."
  },
  {
    "_id": "64518e2a78a3eb63645a9ba9",
    "parentId": "64518e2a78a3eb63645a9ba8",
    "content_type": "text",
    "order": 0,
    "content_data": "Метод splice() используется для добавления или удаления элементов в или из массива. Первый аргумент определяет начальную позицию для добавления или удаления элементов, второй опциональный аргумент - количество удаляемых элементов. Каждый последующий аргумент (третий и т.д.) добавляется в массив:"
  },
  {
    "_id": "64518e2a78a3eb63645a9baa",
    "parentId": "64518e2a78a3eb63645a9ba8",
    "content_type": "code",
    "order": 1,
    "content_data": "let arrayOriginal1 = [1, 2, 3, 4, 5]\nlet arrayOriginal2 = [1, 2, 3, 4, 5]\nlet arrayOriginal3 = [1, 2, 3, 4, 5]\n\nlet array1 = arrayOriginal1.splice(0, 2) // возвращается [1, 2]; исходный массив = [3, 4, 5]\nlet array2 = arrayOriginal2.slice(3) // возвращается [4, 5]; исходный массив = [1, 2, 3]\nlet array3 = arrayOriginal3.slice(3, 1, 'a', 'b', 'c') // возвращается [4]; исходный массив = [1, 2, 3, 'a', 'b', 'c']"
  },
  {
    "_id": "64518e2a78a3eb63645a9bab",
    "parentId": "64518e2a78a3eb63645a9ba8",
    "content_type": "text",
    "order": 2,
    "content_data": "Обратите внимание, что метод splice() модифицирует исходный массив и возвращает массив извлеченных элементов."
  },
  {
    "_id": "64518e2a78a3eb63645a9baf",
    "parentId": "64518e2a78a3eb63645a9bae",
    "content_type": "text",
    "order": 0,
    "content_data": "Основные отличия состоят в следующем:"
  },
  {
    "_id": "64518e2a78a3eb63645a9bb0",
    "parentId": "64518e2a78a3eb63645a9bae",
    "content_type": "table",
    "order": 1,
    "content_data": [
      [
        "Slice",
        "Splice"
      ],
      [
        "Не изменяет исходный массив",
        "Изменяет исходный массив"
      ],
      [
        "Возвращает подмассив исходного массива",
        "Возвращает удаленные элементы в виде массива"
      ],
      [
        "Служит для извлечения элементов из массива",
        "Служит для добавления/удаления элементов в/из массива"
      ]
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9bb5",
    "parentId": "64518e2a78a3eb63645a9bb4",
    "content_type": "text",
    "order": 0,
    "content_data": "Объекты похожи на карты в том, что они оба позволяют устанавливать ключи для значений, извлекать значения, удалять ключи и определять наличие значения по ключу. По этой причине объекты раньше использовались как карты. Однако, между ними существуют некоторые отличия, которые делают использование карт более предпочтительным в определенных случаях."
  },
  {
    "_id": "64518e2a78a3eb63645a9bb6",
    "parentId": "64518e2a78a3eb63645a9bb4",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "Ключами объекта могут быть только строки и символы, а ключами карты - любые значения, включая функции и объекты",
      "Ключи карты упорядочены, а ключи объекта нет. Поэтому при итерации ключи карты возвращаются в порядке их добавления",
      "Вы можете получить размер карты с помощью свойства size, а количество свойств объекта определяется вручную",
      "Карта является итерируемой сущностью, а для итерации по объекту необходимо сначала каким-то образом получить его ключи, а затем их перебрать",
      "При использовании объекта в качестве карты следует помнить о том, что любой объект имеет прототип, поэтому собственные ключи такой карты могут пересекаться с пользовательскими ключами. Поэтому для создания карты-объекта следует использовать Object.create(null), но сейчас такой способ используется редко",
      "Объект уступает карте в плане производительности, когда речь идет о быстром добавлении/удалении ключей"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9bba",
    "parentId": "64518e2a78a3eb63645a9bb9",
    "content_type": "text",
    "order": 0,
    "content_data": "JavaScript предоставляет два способа для сравнения значений: строгое (===, !==) и абстрактное (==, !==). При строгом сравнении значения сравниваются как есть, а при нестрогом, при необходимости, осуществляется неявное преобразование (приведение) типов значений. Строгие операторы используют следующие правила для сравнения различных типов значений:"
  },
  {
    "_id": "64518e2a78a3eb63645a9bbb",
    "parentId": "64518e2a78a3eb63645a9bb9",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "Две строки являются строго равными, когда они имеют одинаковый набор символов, одинаковую длину и одинаковые символы на одних и тех же позициях",
      "Два числа являются строго равными, если равны их значения. Существует два особых случая:\nNaN не равно ничему, включая NaN\nПоложительный и отрицательный нули равны друг другу",
      "NaN не равно ничему, включая NaN",
      "Положительный и отрицательный нули равны друг другу",
      "Логические значение являются строго равными, когда оба являются истинными или ложными, т.е. true или false",
      "Два объекта являются строго равными, если ссылаются на один и тот же объект (место в памяти)",
      "null === undefined возвращает false, а null == undefined - true"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9bbc",
    "parentId": "64518e2a78a3eb63645a9bb9",
    "content_type": "text",
    "order": 2,
    "content_data": "Несколько примеров:"
  },
  {
    "_id": "64518e2a78a3eb63645a9bbd",
    "parentId": "64518e2a78a3eb63645a9bb9",
    "content_type": "code",
    "order": 3,
    "content_data": "0 == false // true\n0 === false // false\n1 == \"1\" // true\n1 === \"1\" // false\nnull == undefined // true\nnull === undefined // false\n'0' == false // true\n'0' === false // false\n[] == [] // или\n[] === [] // false, ссылаются на разные места в памяти\n{} == {} // или\n{} === {} // false, ссылаются на разные места в памяти"
  },
  {
    "_id": "64518e2a78a3eb63645a9bc1",
    "parentId": "64518e2a78a3eb63645a9bc0",
    "content_type": "text",
    "order": 0,
    "content_data": "Стрелочные функции - это сокращенный способ записи функциональных выражений. Они не имеют собственных this, arguments, super и new.target. Эти функции служат хорошей альтернативой функциям, не имеющим методов, но не могут использоваться как конструкторы."
  },
  {
    "_id": "64518e2a78a3eb63645a9bc2",
    "parentId": "64518e2a78a3eb63645a9bc0",
    "content_type": "code",
    "order": 1,
    "content_data": "function regularSum (x, y) {\n    return x + y\n}\n\nconst arrowSum = (x, y) => x + y"
  },
  {
    "_id": "64518e2a78a3eb63645a9bc6",
    "parentId": "64518e2a78a3eb63645a9bc5",
    "content_type": "text",
    "order": 0,
    "content_data": "В JavaScript функции являются объектами первого класса. Это означает, что функции могут использоваться как обычные переменные."
  },
  {
    "_id": "64518e2a78a3eb63645a9bc7",
    "parentId": "64518e2a78a3eb63645a9bc5",
    "content_type": "text",
    "order": 1,
    "content_data": "Например, функция может передаваться в качестве аргумента другой функции, возвращаться как значение из другой функции и присваиваться переменной. В следующем примере функция присваиваивается обработчику:"
  },
  {
    "_id": "64518e2a78a3eb63645a9bc8",
    "parentId": "64518e2a78a3eb63645a9bc5",
    "content_type": "code",
    "order": 2,
    "content_data": "const handler = () => console.log('Я - функция обработки клика')\ndocument.addEventListener('click', handler)"
  },
  {
    "_id": "64518e2a78a3eb63645a9bcc",
    "parentId": "64518e2a78a3eb63645a9bcb",
    "content_type": "text",
    "order": 0,
    "content_data": "Функция первого порядка - это функция, которая не принимает другую функцию в качестве аргумента и не возвращает функцию как значение:"
  },
  {
    "_id": "64518e2a78a3eb63645a9bcd",
    "parentId": "64518e2a78a3eb63645a9bcb",
    "content_type": "code",
    "order": 1,
    "content_data": "const firstOrder = () => console.log('Я - функция первого порядка')"
  },
  {
    "_id": "64518e2a78a3eb63645a9bd1",
    "parentId": "64518e2a78a3eb63645a9bd0",
    "content_type": "text",
    "order": 0,
    "content_data": "Функция высшего порядка - это функция, которая принимает другую функцию в качестве аргумента или возращает другую функцию как значение:"
  },
  {
    "_id": "64518e2a78a3eb63645a9bd2",
    "parentId": "64518e2a78a3eb63645a9bd0",
    "content_type": "code",
    "order": 1,
    "content_data": "const firstOrderFun = () => console.log('Я - функция высшего порядка')\nconst higherOrder = returnFirstOrderFun => returnFirstOrderFun()\nhigherOrder(firstOrderFunc)"
  },
  {
    "_id": "64518e2a78a3eb63645a9bd6",
    "parentId": "64518e2a78a3eb63645a9bd5",
    "content_type": "text",
    "order": 0,
    "content_data": "Унарная функция (функция-монада) - это функция, принимающая только один аргумент:"
  },
  {
    "_id": "64518e2a78a3eb63645a9bd7",
    "parentId": "64518e2a78a3eb63645a9bd5",
    "content_type": "code",
    "order": 1,
    "content_data": "const unaryFun = a => console.log(a + 10) // прибавляем 10 к переданному аргументу и выводим результат в консоль"
  },
  {
    "_id": "64518e2a78a3eb63645a9bdb",
    "parentId": "64518e2a78a3eb63645a9bda",
    "content_type": "text",
    "order": 0,
    "content_data": "Каррирование - это процесс преобразования функции с несколькими параметрами в несколько функций с одним параметром. Данный процесс назван в четь математика Хаскелла Карри. Каррирование превращает одну n-арную функцию в несколько унарных функций (уменьшает арность функции):"
  },
  {
    "_id": "64518e2a78a3eb63645a9bdc",
    "parentId": "64518e2a78a3eb63645a9bda",
    "content_type": "code",
    "order": 1,
    "content_data": "const sum = (a, b, c) => a + b + c\nconst currySum = a => b => c => a + b + c\n\ncurrySum(1) // возвращает функцию: b => c => 1 + b + c\ncurrySum(1)(2) // возвращает функцию: c => 3 + c\ncurrySum(1)(2)(3) // возвращает число 6"
  },
  {
    "_id": "64518e2a78a3eb63645a9bdd",
    "parentId": "64518e2a78a3eb63645a9bda",
    "content_type": "text",
    "order": 2,
    "content_data": "Каррирование применяется в целях обеспечения возможности повторного использования кода (частичное применение функции) и создания композиции из функций."
  },
  {
    "_id": "64518e2a78a3eb63645a9be0",
    "parentId": "64518e2a78a3eb63645a9bdf",
    "content_type": "text",
    "order": 0,
    "content_data": "Чистая функция - это функция, возвращаемое значение которой зависит только от передаваемых аргументов, без побочных эффектов. Проще говоря, если вы вызывается функцию n раз с n аргументами, и функция всегда возвращает одно и тоже значение, значит, она является чистой:"
  },
  {
    "_id": "64518e2a78a3eb63645a9be1",
    "parentId": "64518e2a78a3eb63645a9bdf",
    "content_type": "code",
    "order": 1,
    "content_data": "// не чистая\nlet numberArray = []\nconst impureAddNumber = number => numberArray.push(number)\n// чистая\nconst pureAddNumber = number => argNumberArray => argNumberArray.concat([number])\n\nconsole.log(impureAddNumber(1)) // 1\nconsole.log(numberArray) // [1]\nconsole.log(pureAddNumber(2)(numberArray)) // [1, 2]\nconsole.log(numberArray) // [1]"
  },
  {
    "_id": "64518e2a78a3eb63645a9be2",
    "parentId": "64518e2a78a3eb63645a9bdf",
    "content_type": "text",
    "order": 2,
    "content_data": "В приведенном примере impureAddNumber не является чистой функцией, поскольку метод push() возвращает новую длину массива, которая не зависит от передаваемого аргумента. Вторая функция является чистой, поскольку метод concat() объединяет два массива без побочных эффектов и возвращает новый массив. Чистые функции важны для юнит-тестирования и не нуждаются во внедрении зависимостей. Отсутствие побочных эффектов повышает надежность приложения за счет более слабых связей между его элементами. Одним из воплощений данного принципа является концепция неизменности (иммутабельности), представленная в ES6, и заключающаяся в предпочтении const перед let."
  },
  {
    "_id": "64518e2a78a3eb63645a9be6",
    "parentId": "64518e2a78a3eb63645a9be5",
    "content_type": "text",
    "order": 0,
    "content_data": "Ключевое слово \"let\" служит для объявления локальной переменной, имеющей блочную область видимости. Область видимости такой переменной органичена блоком, оператором или выражением, в котором она используется. Переменные, объявленные с помощью ключевого слова \"var\", имеют глобальную область видимости или область видимости функции, в которой они определены:"
  },
  {
    "_id": "64518e2a78a3eb63645a9be7",
    "parentId": "64518e2a78a3eb63645a9be5",
    "content_type": "code",
    "order": 1,
    "content_data": "let counter = 1\nif (counter === 1) {\n    let counter = 2\n    console.log(counter) // 2\n}\nconsole.log(counter) // 1 (переменная counter, объявленная в блоке, здесь не существует)"
  },
  {
    "_id": "64518e2a78a3eb63645a9beb",
    "parentId": "64518e2a78a3eb63645a9bea",
    "content_type": "text",
    "order": 0,
    "content_data": "Основные отличия состоят в следующем:"
  },
  {
    "_id": "64518e2a78a3eb63645a9bec",
    "parentId": "64518e2a78a3eb63645a9bea",
    "content_type": "table",
    "order": 1,
    "content_data": [
      [
        "var",
        "let"
      ],
      [
        "Доступно с момента появления JavaScript",
        "Представлено в ES6"
      ],
      [
        "Имеет глобальную или функциональную область видимости",
        "Имеет блочную область видимости"
      ],
      [
        "Переменные поднимаются в начало области видимости",
        "Переменные также поднимаются, но не инициализируются (поднимается только объявление, но не присвоение значения)"
      ]
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9bed",
    "parentId": "64518e2a78a3eb63645a9bea",
    "content_type": "text",
    "order": 2,
    "content_data": "Несколько примеров:"
  },
  {
    "_id": "64518e2a78a3eb63645a9bee",
    "parentId": "64518e2a78a3eb63645a9bea",
    "content_type": "code",
    "order": 3,
    "content_data": "function userDetails(username) {\n    if (username) {\n        console.log(salary)\n        console.log(age)\n        let age = 30\n        var salary = 10000\n    }\n    console.log(salary) // 10000 (область видимости функции)\n    console.log(age) // SyntaxError: \"age\" is not defined (блочная область видимости)\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9bf3",
    "parentId": "64518e2a78a3eb63645a9bf2",
    "content_type": "text",
    "order": 0,
    "content_data": "Let (пусть) - это математический оператор, который использовался ранними языками программирования, такими как Scheme и Basic. В настоящее время let используется большим количеством языков программирования, так что данное слово является наиболее близкой альтернативой сокращению \"var\" (variable - переменная)."
  },
  {
    "_id": "64518e2a78a3eb63645a9bf7",
    "parentId": "64518e2a78a3eb63645a9bf6",
    "content_type": "text",
    "order": 0,
    "content_data": "Если вы попытаетесь переопределить переменную, объявленную с помощью ключевого слова \"let\" в блоке switch, то получите ошибку:"
  },
  {
    "_id": "64518e2a78a3eb63645a9bf8",
    "parentId": "64518e2a78a3eb63645a9bf6",
    "content_type": "code",
    "order": 1,
    "content_data": "let counter = 1\nswitch(x) {\n    case 0:\n        let name\n        break\n    case 1:\n        let name // SyntaxError\n        break\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9bf9",
    "parentId": "64518e2a78a3eb63645a9bf6",
    "content_type": "text",
    "order": 2,
    "content_data": "Для решения данной задачи необходимо создать новый блок внутри case - новую лексическую область видимости:"
  },
  {
    "_id": "64518e2a78a3eb63645a9bfa",
    "parentId": "64518e2a78a3eb63645a9bf6",
    "content_type": "code",
    "order": 3,
    "content_data": "let counter = 1\nswitch(x) {\n    case 0: {\n        let name\n        break\n    }\n    case 1: {\n        let name\n        break\n    }\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9bfe",
    "parentId": "64518e2a78a3eb63645a9bfd",
    "content_type": "text",
    "order": 0,
    "content_data": "При попытке доступа к переменным, объявленным с помощью ключевого слова \"let\" или \"const\" (но не \"var\"), до их определения (т.е. до присваивания им значения внутри текущей области видимости) будет выброшено исключение ReferenceError (ошибка ссылки). Другими словами, временной мертвой зоной называется время между созданием контекста (области видимости) переменной и ее определением:"
  },
  {
    "_id": "64518e2a78a3eb63645a9bff",
    "parentId": "64518e2a78a3eb63645a9bfd",
    "content_type": "code",
    "order": 1,
    "content_data": "function someMethod () {\n    console.log(counter1) // undefined\n    console.log(counter2) // ReferenceError\n    var counter1 = 1\n    const counter2 = 2\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9c02",
    "parentId": "64518e2a78a3eb63645a9c01",
    "content_type": "text",
    "order": 0,
    "content_data": "IIFE - это функция, которая вызывается сразу после определения. Синтаксис такой функции может выглядеть так (один из вариантов, наиболее распространенный):"
  },
  {
    "_id": "64518e2a78a3eb63645a9c03",
    "parentId": "64518e2a78a3eb63645a9c01",
    "content_type": "code",
    "order": 1,
    "content_data": "(function () {\n    // код\n})()\n\n// или, если речь идет о стрелочной функции\n(() => {\n    // код\n})()"
  },
  {
    "_id": "64518e2a78a3eb63645a9c04",
    "parentId": "64518e2a78a3eb63645a9c01",
    "content_type": "text",
    "order": 2,
    "content_data": "Главная причина использования IIFE заключается в обеспечении приватности переменных, поскольку доступ к переменным, объявленным внутри IIFE, нельзя получить из внешнего окружения:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c05",
    "parentId": "64518e2a78a3eb63645a9c01",
    "content_type": "code",
    "order": 3,
    "content_data": "(function () {\n    var message = 'IIFE'\n    console.log(message)\n})()\nconsole.log(message) // SyntaxError: \"message\" is not defined"
  },
  {
    "_id": "64518e2a78a3eb63645a9c09",
    "parentId": "64518e2a78a3eb63645a9c08",
    "content_type": "text",
    "order": 0,
    "content_data": "Среди прочего, можно назвать следующее:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c0a",
    "parentId": "64518e2a78a3eb63645a9c08",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "Повышение читаемости и облегчение поддержки кода",
      "Возможность повторного использования кода",
      "Сохранение чистоты глобального пространства имен"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9c0e",
    "parentId": "64518e2a78a3eb63645a9c0d",
    "content_type": "text",
    "order": 0,
    "content_data": "Мемоизация - это способ повышения производительности функции за счет сохранения в кэше ранее полученных результатов выполнения этой функции. При каждом вызове функции переданный ей аргумент становится индексом кэша. Если данные имеются в кэше, они возвращаются без повторного выполнения функции. В противном случае, функция выполняется, а результат записывается в кэш:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c0f",
    "parentId": "64518e2a78a3eb63645a9c0d",
    "content_type": "code",
    "order": 1,
    "content_data": "const memoAdd = () => {\n    let cache = {}\n    return value => {\n        if (value in cache) {\n            console.log('Получение данных из кэша')\n            return cache[value] // в данном случае, cache.value не может быть использовано в качестве названия свойства, поскольку названия свойств в JavaScript не могут начинаться с числа. Поэтому используется скобочная нотация\n        } else {\n            console.log('Результат вычисляется')\n            let result = value + 20\n            cache[value] = result\n            return result\n        }\n    }\n}\n// возвращаем функцию из memoAdd\nconst add = memoAdd()\nconsole.log(add(20)) // Результат вычисляется 40\nconsole.log(add(20)) // Получения данных из кэша 40"
  },
  {
    "_id": "64518e2a78a3eb63645a9c11",
    "parentId": "64518e2a78a3eb63645a9c10",
    "content_type": "text",
    "order": 0,
    "content_data": "Поднятие - это процесс перемещения переменных и функциональных выражений в начало их области видимости перед выполнением кода. Запомните: поднимаются только сами переменные и выражения, а не их инициализация (т.е. поднимается объявление переменной, а не присваивание ей значения):"
  },
  {
    "_id": "64518e2a78a3eb63645a9c12",
    "parentId": "64518e2a78a3eb63645a9c10",
    "content_type": "code",
    "order": 1,
    "content_data": "console.log(message) // undefined\nvar message = 'Привет!'"
  },
  {
    "_id": "64518e2a78a3eb63645a9c13",
    "parentId": "64518e2a78a3eb63645a9c10",
    "content_type": "text",
    "order": 2,
    "content_data": "Для интерпретатора данный код выглядит так:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c14",
    "parentId": "64518e2a78a3eb63645a9c10",
    "content_type": "code",
    "order": 3,
    "content_data": "var message\nconsole.log(message)\nmessage = 'Привет!'"
  },
  {
    "_id": "64518e2a78a3eb63645a9c18",
    "parentId": "64518e2a78a3eb63645a9c17",
    "content_type": "text",
    "order": 0,
    "content_data": "Классы, представленные в ES6, являются синтаксическим сахаром (оберткой, абстракцией или надстройкой) для протипного наследования (для прототипа функции-конструктора). Пример функции-конструктора:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c19",
    "parentId": "64518e2a78a3eb63645a9c17",
    "content_type": "code",
    "order": 1,
    "content_data": "function Bike(model, color) {\n    this.model = model\n    this.color = color\n}\n\nBike.protocontentType.getDetails = function () {\n    return 'Эта ' + this.model + ' велосипеда имеет ' + this.color + ' цвет.'\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9c1a",
    "parentId": "64518e2a78a3eb63645a9c17",
    "content_type": "text",
    "order": 2,
    "content_data": "Тот же пример с использованием класса:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c1b",
    "parentId": "64518e2a78a3eb63645a9c17",
    "content_type": "code",
    "order": 3,
    "content_data": "class Bike {\n    constructor (color, model) {\n        this.color = color\n        this.model = model\n    }\n\n    getDetails () {\n        return `Эта ${this.model} велосипеда имеет ${this.color} цвет.`\n    }\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9c1f",
    "parentId": "64518e2a78a3eb63645a9c1e",
    "content_type": "text",
    "order": 0,
    "content_data": "Замыкание - это комбинация функции и ее лексического окружения. Проще говоря, замыкание - это когда внутренняя функция имеет доступ к переменным, объявленным во внешней функции. Замыкание имеет цепочку из трех областей видимости:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c20",
    "parentId": "64518e2a78a3eb63645a9c1e",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "Собственная область видимости",
      "Область видимости внешней функции",
      "Глобальная область видимости"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9c21",
    "parentId": "64518e2a78a3eb63645a9c1e",
    "content_type": "code",
    "order": 2,
    "content_data": "const welcome = name => {\n    const greet = message => {\n        console.log(`${message}, ${name}!`)\n    }\n    return greet\n}\n\nconst fun = welcome('Ванька')\nfun('Привет') // Привет, Ванька!"
  },
  {
    "_id": "64518e2a78a3eb63645a9c25",
    "parentId": "64518e2a78a3eb63645a9c24",
    "content_type": "text",
    "order": 0,
    "content_data": "Модули - это небольшие части независимого переиспользуемого кода, лежащие в основе многих шаблонов проектирования. Большинство модулей экспортируется в качестве объектов, функций или конструкторов."
  },
  {
    "_id": "64518e2a78a3eb63645a9c29",
    "parentId": "64518e2a78a3eb63645a9c28",
    "content_type": "text",
    "order": 0,
    "content_data": "Область видимости определяет доступность переменных, функций и объектов в разных местах кода во время его выполнения. Другими словами, область видимости - это видимость переменных и других ресурсов в текущем контексте выполнения кода."
  },
  {
    "_id": "64518e2a78a3eb63645a9c2c",
    "parentId": "64518e2a78a3eb63645a9c2b",
    "content_type": "text",
    "order": 0,
    "content_data": "Сервис-воркер - это скрипт, который выполняется независимо от веб-страницы, на которой он запущен, и действий пользователя. Фактически сервис-воркер выполняет роль прокси-сервера между приложением и браузером. Основными возможностями сервис-воркеров является следующее: обеспечение работы приложения в режиме оффлайн, периодическая фоновая синхронизация, пуш-уведомления, перехват и обработка сетевых запросов и программное управление кэшем."
  },
  {
    "_id": "64518e2a78a3eb63645a9c2f",
    "parentId": "64518e2a78a3eb63645a9c2e",
    "content_type": "text",
    "order": 0,
    "content_data": "Сервис-воркеры не имеют прямого доступа к DOM. Однако, они могут взаимодействовать со страницей через интерфейс postMessage, а страница - может изменять DOM."
  },
  {
    "_id": "64518e2a78a3eb63645a9c33",
    "parentId": "64518e2a78a3eb63645a9c32",
    "content_type": "text",
    "order": 0,
    "content_data": "Одной из проблем сервис-воркеров является то, что их выполнение прекращается, когда они не используются, и повторно запускается при необходимости. Это не позволяет добавлять обработчики событий fetch и message глобально. Для повторного использования информации необходимо обеспечить взаимодействие сервис-воркеров с индексированной базой данных (IndexedDB) или локальным хранилищем (local storage)."
  },
  {
    "_id": "64518e2a78a3eb63645a9c36",
    "parentId": "64518e2a78a3eb63645a9c35",
    "content_type": "text",
    "order": 0,
    "content_data": "IndexedDB - это низкоуровневый прикладной интерфейс для хранения большого объема структурированных данных, включая файлы и blobs, на стороне клиента. Данный интерфейс использует индексы для повышения скорости поиска данных."
  },
  {
    "_id": "64518e2a78a3eb63645a9c3a",
    "parentId": "64518e2a78a3eb63645a9c39",
    "content_type": "text",
    "order": 0,
    "content_data": "Веб-хранилище - это интерфейс, позволяющий хранить данные в виде пар ключ/значение локально, т.е. в браузере пользователя, более удобным способом, чем при использовании куки. Веб-хранилище предоставляет два механизма хранения данных:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c3b",
    "parentId": "64518e2a78a3eb63645a9c39",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "Локальное хранилище (local stotage) - хранит данные текущего пользователя неограниченное количество времени",
      "Сессионное хранилище (session storage) - хранит данные на протяжении текущей сессии, т.е. при закрытии вкладки браузера данные будут потеряны"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9c3f",
    "parentId": "64518e2a78a3eb63645a9c3e",
    "content_type": "text",
    "order": 0,
    "content_data": "postMessage - это способ коммуникации разных источников объекта window (например, страницы и генерируемого ею поп-апа (всплывающего окна) или страницы и встроенного в нее фрейма (iframe)). Обычно, скрипты одной страницы не имеют доступа к другой странице, если данная страница следует Политике общего происхождения или одного источника (источник - протокол, хост и порт)."
  },
  {
    "_id": "64518e2a78a3eb63645a9c42",
    "parentId": "64518e2a78a3eb63645a9c41",
    "content_type": "text",
    "order": 0,
    "content_data": "Куки - это небольшой фрагмент данных, который сохраняется на компьютере пользователя для последующего использования браузером. Куки сохраняются в виде пар ключ/значение:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c43",
    "parentId": "64518e2a78a3eb63645a9c41",
    "content_type": "code",
    "order": 1,
    "content_data": "document.cookie = 'username=Ванька'",
    "content_image": "cookie.png"
  },
  {
    "_id": "64518e2a78a3eb63645a9c47",
    "parentId": "64518e2a78a3eb63645a9c46",
    "content_type": "text",
    "order": 0,
    "content_data": "Куки используются для сохранения информации о пользователе (не рекомендуется использовать для хранения конфиденциальной информации). Обычно, данный процесс состоит из двух этапов:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c48",
    "parentId": "64518e2a78a3eb63645a9c46",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "При первом посещении страницы профиль пользователя сохраняется в куки",
      "При повторном посещении страницы профиль пользователя извлекается из куки"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9c4c",
    "parentId": "64518e2a78a3eb63645a9c4b",
    "content_type": "text",
    "order": 0,
    "content_data": "По умолчанию, куки удаляются при закрытии браузера, однако это можно изменить, установив время жизни (expires) в формате UTC:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c4d",
    "parentId": "64518e2a78a3eb63645a9c4b",
    "content_type": "code",
    "order": 1,
    "content_data": "document.cookie = 'username=Ванька; expires=Sat, 5 Sep 2020 12:00:00 UTC'"
  },
  {
    "_id": "64518e2a78a3eb63645a9c4e",
    "parentId": "64518e2a78a3eb63645a9c4b",
    "content_type": "text",
    "order": 2,
    "content_data": "По умолчанию, куки принадлежат текущей странице, однако это также можно изменить, установив путь (path):"
  },
  {
    "_id": "64518e2a78a3eb63645a9c4f",
    "parentId": "64518e2a78a3eb63645a9c4b",
    "content_type": "code",
    "order": 3,
    "content_data": "document.cookie = 'username=Ванька; path=/services'"
  },
  {
    "_id": "64518e2a78a3eb63645a9c53",
    "parentId": "64518e2a78a3eb63645a9c52",
    "content_type": "text",
    "order": 0,
    "content_data": "Удалить куки можно, установив прошедшее время в качестве времени жизни. В этом случае не нужно определять значение куки:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c54",
    "parentId": "64518e2a78a3eb63645a9c52",
    "content_type": "code",
    "order": 1,
    "content_data": "document.cookie = 'username=; expires=Sat, 05 Jun 2020 00:00:00 UTC; path=/;'"
  },
  {
    "_id": "64518e2a78a3eb63645a9c55",
    "parentId": "64518e2a78a3eb63645a9c52",
    "content_type": "text",
    "order": 2,
    "content_data": "Обратите внимание, что в данном случае необходимо определить путь для удаления правильного куки. Некоторые браузеры не позволяют удалить куки без указания этого параметра."
  },
  {
    "_id": "64518e2a78a3eb63645a9c59",
    "parentId": "64518e2a78a3eb63645a9c58",
    "content_type": "text",
    "order": 0,
    "content_data": "Основные отличия состоят в следующем:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c5a",
    "parentId": "64518e2a78a3eb63645a9c58",
    "content_type": "table",
    "order": 1,
    "content_data": [
      [
        "Критерий",
        "Куки",
        "Локальное хранилище",
        "Сессионное хранилище"
      ],
      [
        "Доступность",
        "Как на сервере, так и на клиенте",
        "Только на клиенте",
        "Только на клиенте"
      ],
      [
        "Время жизни",
        "Устанавливается с помощью expires",
        "До удаления пользователем",
        "До закрытия вкладки браузера"
      ],
      [
        "Поддержка шифрования",
        "Поддерживается",
        "Не поддерживается",
        "Не поддерживается"
      ],
      [
        "Максимальный размер данных",
        "4 Кб",
        "Около 5 Мб (зависит от браузера)",
        "Около 5 Мб (зависит от браузера)"
      ]
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9c60",
    "parentId": "64518e2a78a3eb63645a9c5f",
    "content_type": "text",
    "order": 0,
    "content_data": "Локальное хранилище - это тоже самое, что и сессионное хранилище, за исключением того, что в первом данные сохраняются даже при закрытии и перезагрузке браузера, а во втором данные удаляются по окончании сессии (закрытие вкладки браузера)."
  },
  {
    "_id": "64518e2a78a3eb63645a9c64",
    "parentId": "64518e2a78a3eb63645a9c63",
    "content_type": "text",
    "order": 0,
    "content_data": "Объект window предоставляет объекты WindowLocalStorage и WindowSessionStorage, которые имеют свойства localStorage и sessionStorage, соответственно. Эти свойства создают экземпляр объекта Storage, с помощью которого можно записывать, извлекать и удалять данные для определенного домена и типа хранилища (сессионное или локальное):"
  },
  {
    "_id": "64518e2a78a3eb63645a9c65",
    "parentId": "64518e2a78a3eb63645a9c63",
    "content_type": "code",
    "order": 1,
    "content_data": "// сохраняем данные\nlocalStorage.setItem('data', document.querySelector('.data').value)\n// получаем данные\nlocalStorage.getItem('data')"
  },
  {
    "_id": "64518e2a78a3eb63645a9c69",
    "parentId": "64518e2a78a3eb63645a9c68",
    "content_type": "text",
    "order": 0,
    "content_data": "Сессионное хранилище предоставляет методы для чтения, записи и удаления данных:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c6a",
    "parentId": "64518e2a78a3eb63645a9c68",
    "content_type": "code",
    "order": 1,
    "content_data": "// записываем данные\nsessionStorage.setItem('key', 'value')\n\n// получаем данные\nconst data = sessionStorage.getItem('key')\n\n// удаляем определенные данные\nsessionStorage.removeItem('key')\n\n// удаляем все данные\nsessionStorage.clear()"
  },
  {
    "_id": "64518e2a78a3eb63645a9c6e",
    "parentId": "64518e2a78a3eb63645a9c6d",
    "content_type": "text",
    "order": 0,
    "content_data": "При изменении хранилища в контексте другого документа возникает событие storage:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c6f",
    "parentId": "64518e2a78a3eb63645a9c6d",
    "content_type": "code",
    "order": 1,
    "content_data": "window.onstorage = function () {}"
  },
  {
    "_id": "64518e2a78a3eb63645a9c70",
    "parentId": "64518e2a78a3eb63645a9c6d",
    "content_type": "text",
    "order": 2,
    "content_data": "Пример обработки данного события:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c71",
    "parentId": "64518e2a78a3eb63645a9c6d",
    "content_type": "code",
    "order": 3,
    "content_data": "window.onstorage = event => {\n    console.log(`${event.key} был изменен.\n    Старое значение: ${event.oldValue}.\n    Новое значение: ${event.newValue}.`)\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9c72",
    "parentId": "64518e2a78a3eb63645a9c6d",
    "content_type": "text",
    "order": 4,
    "content_data": "Данное событие позволяет реализовать своего рода чат."
  },
  {
    "_id": "64518e2a78a3eb63645a9c76",
    "parentId": "64518e2a78a3eb63645a9c75",
    "content_type": "text",
    "order": 0,
    "content_data": "Веб-хранилище является более безопасным и может хранить больший объем данных, чем куки, что не влияет на производительность. Кроме того, данные не отправляются на сервер (в случае с куки данные включаются в заголовки запроса и ответа при каждом обращении клиента к серверу). Поэтому такой способ хранения данных является более предпочтительным, чем куки."
  },
  {
    "_id": "64518e2a78a3eb63645a9c7a",
    "parentId": "64518e2a78a3eb63645a9c79",
    "content_type": "text",
    "order": 0,
    "content_data": "Перед использованием веб-хранилища рекомендуется проверить поддержку данного интерфейса браузерами:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c7b",
    "parentId": "64518e2a78a3eb63645a9c79",
    "content_type": "code",
    "order": 1,
    "content_data": "if (contentTypeof(Storage) !== 'undefined') {\n    // код\n} else {\n    // веб-хранилище не поддерживается\n}\n\n// или\nif ('Storage' in window) {\n    console.log('ok')\n} else {\n    console.warn('не ok')\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9c7c",
    "parentId": "64518e2a78a3eb63645a9c79",
    "content_type": "text",
    "order": 2,
    "content_data": "По данным CanIUse поддержка веб-хранилища на сегодняшний день составляет 98%."
  },
  {
    "_id": "64518e2a78a3eb63645a9c80",
    "parentId": "64518e2a78a3eb63645a9c7f",
    "content_type": "text",
    "order": 0,
    "content_data": "Перед использованием сервис-воркеров рекомендуется проверить поддержку данного интерфейса браузерами:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c81",
    "parentId": "64518e2a78a3eb63645a9c7f",
    "content_type": "code",
    "order": 1,
    "content_data": "if (contentTypeof(Worker) !== undefined) {\n    // код\n} else {\n    // сервис-воркеры не поддерживаются\n}\n// или\nif ('Worker' in window) {\n    console.log('ok')\n} else {\n    console.warn('не ok')\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9c82",
    "parentId": "64518e2a78a3eb63645a9c7f",
    "content_type": "text",
    "order": 2,
    "content_data": "По данным CanIUse поддержка сервис-воркеров на сегодняшний день составляет 94%."
  },
  {
    "_id": "64518e2a78a3eb63645a9c85",
    "parentId": "64518e2a78a3eb63645a9c84",
    "content_type": "text",
    "order": 0,
    "content_data": "Для использования веб-воркера необходимости сделать следующее."
  },
  {
    "_id": "64518e2a78a3eb63645a9c86",
    "parentId": "64518e2a78a3eb63645a9c84",
    "content_type": "text",
    "order": 1,
    "content_data": "Создать файл для воркера, например, get-current-time.js:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c87",
    "parentId": "64518e2a78a3eb63645a9c84",
    "content_type": "code",
    "order": 2,
    "content_data": "const getCurrentTime = () => {\n    let time = new Date().toLocaleTimeString()\n    postMessage(time)\n    setTimeout(() => getCurrentTime(), 1000)\n}\n\ngetCurrentTime()"
  },
  {
    "_id": "64518e2a78a3eb63645a9c88",
    "parentId": "64518e2a78a3eb63645a9c84",
    "content_type": "text",
    "order": 3,
    "content_data": "Метод postMessage() используется для отправки сообщений странице."
  },
  {
    "_id": "64518e2a78a3eb63645a9c89",
    "parentId": "64518e2a78a3eb63645a9c84",
    "content_type": "text",
    "order": 4,
    "content_data": "Создаем объект воркера:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c8a",
    "parentId": "64518e2a78a3eb63645a9c84",
    "content_type": "code",
    "order": 5,
    "content_data": "const worker = new Worker('get-current-time.js')"
  },
  {
    "_id": "64518e2a78a3eb63645a9c8b",
    "parentId": "64518e2a78a3eb63645a9c84",
    "content_type": "text",
    "order": 6,
    "content_data": "После этого обрабатываем получение сообщений от воркера:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c8c",
    "parentId": "64518e2a78a3eb63645a9c84",
    "content_type": "code",
    "order": 7,
    "content_data": "<output></output>\n<button>Стоп</button>\n\nworker\n    .addEventListener('message', event => document.querySelector('output')\n    .textContent = event.data)"
  },
  {
    "_id": "64518e2a78a3eb63645a9c8d",
    "parentId": "64518e2a78a3eb63645a9c84",
    "content_type": "text",
    "order": 8,
    "content_data": "Воркер будет продолжать обрабатывать событие message даже после того, как внешний скрипт выполнит свою работу, поэтому его нужно останавливать принудительно:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c8e",
    "parentId": "64518e2a78a3eb63645a9c84",
    "content_type": "code",
    "order": 9,
    "content_data": "document.querySelector('button')\n    .addEventListener('click', () => worker.terminate())"
  },
  {
    "_id": "64518e2a78a3eb63645a9c8f",
    "parentId": "64518e2a78a3eb63645a9c84",
    "content_type": "text",
    "order": 10,
    "content_data": "Если присвоить воркеру значение undefined, его можно будет использовать повторно:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c90",
    "parentId": "64518e2a78a3eb63645a9c84",
    "content_type": "code",
    "order": 11,
    "content_data": "worker = undefined"
  },
  {
    "_id": "64518e2a78a3eb63645a9c93",
    "parentId": "64518e2a78a3eb63645a9c92",
    "content_type": "text",
    "order": 0,
    "content_data": "Поскольку веб-воркеры создаются в отдельном файле, они не имеют доступа к следующим объектам:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c94",
    "parentId": "64518e2a78a3eb63645a9c92",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "window",
      "Document",
      "Родительский объект - объект, запустивший воркер"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9c97",
    "parentId": "64518e2a78a3eb63645a9c96",
    "content_type": "text",
    "order": 0,
    "content_data": "Промис (общание) - это объект, который либо выполняется с некоторым значением, либо отклоняется с ошибкой. Разрешение промиса происходит либо после истечения определенного времени, либо после возникновения определенного события. Промис может иметь одно из трех состояний: находится в режиме ожидания (pending), выполнен (fulfilled), отклонен (rejected)."
  },
  {
    "_id": "64518e2a78a3eb63645a9c98",
    "parentId": "64518e2a78a3eb63645a9c96",
    "content_type": "text",
    "order": 1,
    "content_data": "Синтаксис промиса:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c99",
    "parentId": "64518e2a78a3eb63645a9c96",
    "content_type": "code",
    "order": 2,
    "content_data": "const promise = new Promise((resolve, reject) => {\n    // код\n})\n\n// или, когда мы уверены, что промис выполнится успешно\nconst promise = Promise.resolve(value)\npromise.then(value => {\n    // код\n})"
  },
  {
    "_id": "64518e2a78a3eb63645a9c9a",
    "parentId": "64518e2a78a3eb63645a9c96",
    "content_type": "text",
    "order": 3,
    "content_data": "Пример использования промиса:"
  },
  {
    "_id": "64518e2a78a3eb63645a9c9b",
    "parentId": "64518e2a78a3eb63645a9c96",
    "content_type": "code",
    "order": 4,
    "content_data": "const promise = new Promise(resolve => {\n    const timer = setTimeout(() => {\n        resolve('Привет от промиса!')\n        clearTimeout(timer)\n    }, 5000);\n}, reject => {\n    reject('Что-то пошло не так')\n})\n\npromise\n    .then(value => console.log(value))\n    .catch(error => console.error(error))\n    .finally(() => console.log('Мы закончили')) // в консоль будет выведено \"Привет от промиса!\" через 5 секунд и затем \"Мы закончили\""
  },
  {
    "_id": "64518e2a78a3eb63645a9c9c",
    "parentId": "64518e2a78a3eb63645a9c96",
    "content_type": "text",
    "order": 5,
    "content_data": "Алгоритм разрешения промиса:",
    "content_image": "promise.png"
  },
  {
    "_id": "64518e2a78a3eb63645a9ca0",
    "parentId": "64518e2a78a3eb63645a9c9f",
    "content_type": "text",
    "order": 0,
    "content_data": "Промисы используются для работы с асинхронным кодом. Они представляют собой альтернативу функциям обратного вызова, позволяя избежать так называемого \"ада колбэков\", делают код более чистым и читаемым."
  },
  {
    "_id": "64518e2a78a3eb63645a9ca4",
    "parentId": "64518e2a78a3eb63645a9ca3",
    "content_type": "text",
    "order": 0,
    "content_data": "У промисов существует три состояния:"
  },
  {
    "_id": "64518e2a78a3eb63645a9ca5",
    "parentId": "64518e2a78a3eb63645a9ca3",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "Ожидание (pending): стадия перед началом выполнения операции",
      "Выполнен (fulfilled): успешное завершение операции",
      "Отклонен (rejected): неудачное выполнение операции. Выбрасывается исключение"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9ca9",
    "parentId": "64518e2a78a3eb63645a9ca8",
    "content_type": "text",
    "order": 0,
    "content_data": "Колбэк - это функция, которая передается другой функции в качестве аргумента. Данная функция (внутренняя) вызывается внутри родительской (внешней) для выполнения операции при возникновении определенного события. Рассмотрим простой пример:"
  },
  {
    "_id": "64518e2a78a3eb63645a9caa",
    "parentId": "64518e2a78a3eb63645a9ca8",
    "content_type": "code",
    "order": 1,
    "content_data": "function callback(name) {\n    alert(`Привет, ${name}!`)\n}\n\nfunction outer(cb) {\n    const name = prompt('Пожалуйста, введите свое имя')\n    cb(name)\n}\nouter(callback)"
  },
  {
    "_id": "64518e2a78a3eb63645a9cab",
    "parentId": "64518e2a78a3eb63645a9ca8",
    "content_type": "text",
    "order": 2,
    "content_data": "В приведенном примере функция outer запрашивает имя пользователя и записывает его в переменную name. Затем данная функция передает name функции callback, которая выводит приветствие с именем пользователя."
  },
  {
    "_id": "64518e2a78a3eb63645a9caf",
    "parentId": "64518e2a78a3eb63645a9cae",
    "content_type": "text",
    "order": 0,
    "content_data": "Колбэки нужны, поскольку JavaScript - язык, управляемый событиями. Это означает, что, например, вместо ожидания получения ответа на запрос или завершения обработки определенного события, JavaScript продолжает реагировать на другие события. Рассмотрим пример, в котором одна функция обращается к интерфейсу, а другая - выводит сообщение в консоль:"
  },
  {
    "_id": "64518e2a78a3eb63645a9cb0",
    "parentId": "64518e2a78a3eb63645a9cae",
    "content_type": "code",
    "order": 1,
    "content_data": "function first () {\n    // имитируем обращение к API\n    setTimeout(() => console.log('Вызвана первая функция'), 1000)\n}\n\nfunction second () {\n    console.log('Вызвана вторая функция')\n}\n\nfirst()\nsecond()\n// сначала будет выведено \"Вызвана вторая функция\", затем \"Вызвана первая функция\""
  },
  {
    "_id": "64518e2a78a3eb63645a9cb1",
    "parentId": "64518e2a78a3eb63645a9cae",
    "content_type": "text",
    "order": 2,
    "content_data": "Как видите, JavaScript не ожидает завершения первой функции, а продолжает выполнение кода. Поэтому колбэки используются для имитации асинхронности, предотвращая блокировку основного потока выполнения программы."
  },
  {
    "_id": "64518e2a78a3eb63645a9cb5",
    "parentId": "64518e2a78a3eb63645a9cb4",
    "content_type": "text",
    "order": 0,
    "content_data": "Ад колбэков - это антипаттерн, когда множество функций обратного вызова вложены друг в друга для реализации асинхронной логики. Такая структура кода сложна для восприятия и поддержки. Это может выглядеть так:"
  },
  {
    "_id": "64518e2a78a3eb63645a9cb6",
    "parentId": "64518e2a78a3eb63645a9cb4",
    "content_type": "code",
    "order": 1,
    "content_data": "function first () {\n    return function second () {\n        return function third () {\n            return function fourth () {\n                // и т.д.\n            }\n        }\n    }\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9cb7",
    "parentId": "64518e2a78a3eb63645a9cb4",
    "content_type": "text",
    "order": 2,
    "content_data": "Такой подход к написанию кода считается плохой практикой, кроме случаев каррирования, частичного применения или композиции функций."
  },
  {
    "_id": "64518e2a78a3eb63645a9cbb",
    "parentId": "64518e2a78a3eb63645a9cba",
    "content_type": "text",
    "order": 0,
    "content_data": "События, отправляемые сервером - это технология пуш-уведомлений, позволяющая браузерам получать от сервера обновленные данные через HTTP-соединение без отправки запроса. Это один из способов коммуникации клиента и сервера, когда сообщения отправляются только сервером. Данная технология используется для обновления Facebook/Twitter, цен в магазинах, новостных лент и т.д."
  },
  {
    "_id": "64518e2a78a3eb63645a9cbf",
    "parentId": "64518e2a78a3eb63645a9cbe",
    "content_type": "text",
    "order": 0,
    "content_data": "Для этого используется объект EventSource:"
  },
  {
    "_id": "64518e2a78a3eb63645a9cc0",
    "parentId": "64518e2a78a3eb63645a9cbe",
    "content_type": "code",
    "order": 1,
    "content_data": "if('EventSource' in window) {\n    const source = new EventSource('sse.js')\n    source.addEventListener('message', event => document.querySelector('output')\n        .textContent = event.data)\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9cc4",
    "parentId": "64518e2a78a3eb63645a9cc3",
    "content_type": "text",
    "order": 0,
    "content_data": "Это делается так:"
  },
  {
    "_id": "64518e2a78a3eb63645a9cc5",
    "parentId": "64518e2a78a3eb63645a9cc3",
    "content_type": "code",
    "order": 1,
    "content_data": "if (contentTypeof EventSource !== 'undefined') {\n    // код\n} else {\n    // SSE не поддерживается\n}\n\n// или\n('EventSource' in window)\n    ? console.log('ok')\n    : console.warn('!не ok')"
  },
  {
    "_id": "64518e2a78a3eb63645a9cc6",
    "parentId": "64518e2a78a3eb63645a9cc3",
    "content_type": "text",
    "order": 2,
    "content_data": "По данным CanIUse на сегодняшний день SSE поддерживается 95% браузеров."
  },
  {
    "_id": "64518e2a78a3eb63645a9cca",
    "parentId": "64518e2a78a3eb63645a9cc9",
    "content_type": "text",
    "order": 0,
    "content_data": "Вот список этих событий:"
  },
  {
    "_id": "64518e2a78a3eb63645a9ccb",
    "parentId": "64518e2a78a3eb63645a9cc9",
    "content_type": "table",
    "order": 1,
    "content_data": [
      [
        "Событие",
        "Описание"
      ],
      [
        "open",
        "Возникает при открытии соединения с сервером"
      ],
      [
        "message",
        "Возникает при получении сообщения от сервера"
      ],
      [
        "error",
        "Возникает при выбрасывании исключения"
      ]
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9ccf",
    "parentId": "64518e2a78a3eb63645a9cce",
    "content_type": "text",
    "order": 0,
    "content_data": "Основными правилами работы с промисами является следующее:"
  },
  {
    "_id": "64518e2a78a3eb63645a9cd0",
    "parentId": "64518e2a78a3eb63645a9cce",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "Промис - это объект, содержащий встроенный или стандартный метод then()",
      "Стадия ожидания промиса, обычно, заканчивается стадией его выполнения или отклонения",
      "Состояние выполненного или отклоненного промиса не должно меняться после его разрешения",
      "После разрешения промиса его значение также не должно меняться"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9cd4",
    "parentId": "64518e2a78a3eb63645a9cd3",
    "content_type": "text",
    "order": 0,
    "content_data": "Вы можете вкладывать колбеки друг в друга с целью последовательного выполнения определенных операций:"
  },
  {
    "_id": "64518e2a78a3eb63645a9cd5",
    "parentId": "64518e2a78a3eb63645a9cd3",
    "content_type": "code",
    "order": 1,
    "content_data": "loadScript('/script1.js', script => {\n    console.log(`Скрипт ${script} загружен`)\n\n    loadScript('/script2.js', script => {\n        console.log(`Скрипт ${script} загружен`)\n\n        loadScript('/script3.js', script => {\n            console.log(`Скрипт ${script} загружен`)\n        })\n    })\n})"
  },
  {
    "_id": "64518e2a78a3eb63645a9cd9",
    "parentId": "64518e2a78a3eb63645a9cd8",
    "content_type": "text",
    "order": 0,
    "content_data": "Последовательное выполнение нескольких асинхронных задач с помощью промисов называется цепочкой промисов. Рассмотрим пример:"
  },
  {
    "_id": "64518e2a78a3eb63645a9cda",
    "parentId": "64518e2a78a3eb63645a9cd8",
    "content_type": "code",
    "order": 1,
    "content_data": "new Promise((resolve, reject) => {\n    const id = setTimeout(() => {\n        resolve(1)\n        clearTimeout(id)\n    }, 1000)\n}).then(result => {\n    console.log(result) // 1\n    return result * 2\n}).then(result2 => {\n    console.log(result2) // 2\n    return result2 * 3\n}).then(result3 => {\n    console.log(result3) // 6\n}).catch(error => console.error(error))"
  },
  {
    "_id": "64518e2a78a3eb63645a9cdb",
    "parentId": "64518e2a78a3eb63645a9cd8",
    "content_type": "text",
    "order": 2,
    "content_data": "Алгоритм выполнения:"
  },
  {
    "_id": "64518e2a78a3eb63645a9cdc",
    "parentId": "64518e2a78a3eb63645a9cd8",
    "content_type": "list",
    "order": 3,
    "content_data": [
      "Первый промис разрешается со значением 1",
      "После этого, первый метод then() выводит это значение в консоль и возвращает его, умножая на 2",
      "Второй then() выводит результат первого then() в консоль (2) и возвращает результат, умножая его на 3",
      "Последний then() выводит результат второго then() в консоль (6)",
      "Блок catch служит для обработки ошибок"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9ce0",
    "parentId": "64518e2a78a3eb63645a9cdf",
    "content_type": "text",
    "order": 0,
    "content_data": "Promise.all() - это промис, принимающий массив других промисов в качестве аргумента и возвращающий результаты выполненных промисов или ошибку при отклонении одного из них. Синтаксис:"
  },
  {
    "_id": "64518e2a78a3eb63645a9ce1",
    "parentId": "64518e2a78a3eb63645a9cdf",
    "content_type": "code",
    "order": 1,
    "content_data": "Promise.all([Promise1, Promise2, Promise3])\n    .then(results => console.log(results))\n    .catch(error => console.error(error))"
  },
  {
    "_id": "64518e2a78a3eb63645a9ce2",
    "parentId": "64518e2a78a3eb63645a9cdf",
    "content_type": "text",
    "order": 2,
    "content_data": "Помните, что порядок получения результатов зависит от порядка промисов в массиве."
  },
  {
    "_id": "64518e2a78a3eb63645a9ce6",
    "parentId": "64518e2a78a3eb63645a9ce5",
    "content_type": "text",
    "order": 0,
    "content_data": "Promise.race() возвращает результат первого выполненного или отклоненного промиса из переданных ему в виде массива промисов:"
  },
  {
    "_id": "64518e2a78a3eb63645a9ce7",
    "parentId": "64518e2a78a3eb63645a9ce5",
    "content_type": "code",
    "order": 1,
    "content_data": "const promise1 = new Promise((resolve, reject) => setTimeout(resolve, 500, 'раз'))\n\nconst promise2 = new Promise((resolve, reject) => setTimeout(resolve, 100, 'два'))\n\nPromise.race([promise1, promise2]).then(value => console.log(value)) // \"два\""
  },
  {
    "_id": "64518e2a78a3eb63645a9ceb",
    "parentId": "64518e2a78a3eb63645a9cea",
    "content_type": "text",
    "order": 0,
    "content_data": "Для включения строго режима используется инструкция 'use strict' (или \"use strict\") в начале всего кода или отдельной функции. Строгий режим был представлен в ES5. В данном режиме запрещены некоторые действия и выбрасывается больше исключений."
  },
  {
    "_id": "64518e2a78a3eb63645a9cef",
    "parentId": "64518e2a78a3eb63645a9cee",
    "content_type": "text",
    "order": 0,
    "content_data": "Строгий режим позволяет писать более безопасный код, предотвращая возникновение многих ошибок. Например, он запрещает случайное создание глобальных переменных (без ключевого слова, variable = value), присваивание значения свойству, доступному только для чтения, свойству, которое можно получить только с помощью геттера, несуществующему свойству и несуществующей переменной или объекту. В нестрогом режиме во всех этих случаях исключение не выбрасывается."
  },
  {
    "_id": "64518e2a78a3eb63645a9cf3",
    "parentId": "64518e2a78a3eb63645a9cf2",
    "content_type": "text",
    "order": 0,
    "content_data": "Строгий режим включается с помощью инструкции 'use strict' (или \"use strict\") в начале кода или функции. Обычно, данная инструкция указывается в самом начале скрипта, т.е. в глобальном пространстве имен:"
  },
  {
    "_id": "64518e2a78a3eb63645a9cf4",
    "parentId": "64518e2a78a3eb63645a9cf2",
    "content_type": "code",
    "order": 1,
    "content_data": "'use strict'\nx = 3.14 // ReferenceError: \"x\" is not defined"
  },
  {
    "_id": "64518e2a78a3eb63645a9cf5",
    "parentId": "64518e2a78a3eb63645a9cf2",
    "content_type": "text",
    "order": 2,
    "content_data": "Если 'use strict' указывается в функции, то действие строгого режима распространяется только на эту функцию:"
  },
  {
    "_id": "64518e2a78a3eb63645a9cf6",
    "parentId": "64518e2a78a3eb63645a9cf2",
    "content_type": "code",
    "order": 3,
    "content_data": "x = 3.14 // все в порядке\nf() // ReferenceError: \"y\" is not defined\n\nfunction f () {\n    'use strict'\n    y = 3.14\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9cfa",
    "parentId": "64518e2a78a3eb63645a9cf9",
    "content_type": "text",
    "order": 0,
    "content_data": "Двойное отрицание (!!) преобразует значение в логическое. Если значение является ложным, то возвращается false, иначе - true:"
  },
  {
    "_id": "64518e2a78a3eb63645a9cfb",
    "parentId": "64518e2a78a3eb63645a9cf9",
    "content_type": "code",
    "order": 1,
    "content_data": "const x = 1\nconsole.log(x) // 1\nconsole.log(!!x) // true\nconst y = ''\nconsole.log(y) // ''\nconsole.log(!!str) // false"
  },
  {
    "_id": "64518e2a78a3eb63645a9cfc",
    "parentId": "64518e2a78a3eb63645a9cf9",
    "content_type": "text",
    "order": 2,
    "content_data": "Обратите внимание: !! - это не отдельный оператор, а два оператора !."
  },
  {
    "_id": "64518e2a78a3eb63645a9d00",
    "parentId": "64518e2a78a3eb63645a9cff",
    "content_type": "text",
    "order": 0,
    "content_data": "Данный оператор служит для удаления свойств объектов и значений этих свойств:"
  },
  {
    "_id": "64518e2a78a3eb63645a9d01",
    "parentId": "64518e2a78a3eb63645a9cff",
    "content_type": "code",
    "order": 1,
    "content_data": "'use strict'\nconst user = {\n    name: 'Ванька',\n    age: 30\n}\n\ndelete user.age\n\nconsole.log(user) // { name: \"Ванька\" }\n\ndelete user // SyntaxError: Delete of an unqualified identifier in strict mode"
  },
  {
    "_id": "64518e2a78a3eb63645a9d02",
    "parentId": "64518e2a78a3eb63645a9cff",
    "content_type": "text",
    "order": 2,
    "content_data": "Обратите внимание, что в нестрогом режиме попытка удаления объекта тихо завершится ничем."
  },
  {
    "_id": "64518e2a78a3eb63645a9d03",
    "parentId": "64518e2a78a3eb63645a9cff",
    "content_type": "text",
    "order": 3,
    "content_data": "Поскольку массив - это тоже объект, применение delete к элементу массива удалит его значение и запишет в него undefined, т.е. индекс удаленного элемента массива сохранится и длина массива не изменится."
  },
  {
    "_id": "64518e2a78a3eb63645a9d07",
    "parentId": "64518e2a78a3eb63645a9d06",
    "content_type": "text",
    "order": 0,
    "content_data": "Данный оператор используется для определения типа переменной или выражения:"
  },
  {
    "_id": "64518e2a78a3eb63645a9d08",
    "parentId": "64518e2a78a3eb63645a9d06",
    "content_type": "code",
    "order": 1,
    "content_data": "contentTypeof 1 // number\ncontentTypeof [] // object\ncontentTypeof 'Ванька' // string\ncontentTypeof (1 + 2) // number\n\ncontentTypeof null // object\ncontentTypeof NaN // number"
  },
  {
    "_id": "64518e2a78a3eb63645a9d0c",
    "parentId": "64518e2a78a3eb63645a9d0b",
    "content_type": "text",
    "order": 0,
    "content_data": "undefined - это неопределенное (но не отсутствующее) стандартное значение (значение по умолчанию) переменной, которой не было присвоено значение, а также необъявленной переменной. Это один из примитивных типов данных:"
  },
  {
    "_id": "64518e2a78a3eb63645a9d0d",
    "parentId": "64518e2a78a3eb63645a9d0b",
    "content_type": "code",
    "order": 1,
    "content_data": "let name\nconsole.log(contentTypeof name) // undefined\nconsole.log(contentTypeof age) // undefined"
  },
  {
    "_id": "64518e2a78a3eb63645a9d0e",
    "parentId": "64518e2a78a3eb63645a9d0b",
    "content_type": "text",
    "order": 2,
    "content_data": "Данное значение может присваиваться переменной явно:"
  },
  {
    "_id": "64518e2a78a3eb63645a9d0f",
    "parentId": "64518e2a78a3eb63645a9d0b",
    "content_type": "code",
    "order": 3,
    "content_data": "user = undefined"
  },
  {
    "_id": "64518e2a78a3eb63645a9d13",
    "parentId": "64518e2a78a3eb63645a9d12",
    "content_type": "text",
    "order": 0,
    "content_data": "null - значение, представляющее собой отсутствие значения, установленное явно. Это один из примитивных типов данных. С помощью null можно удалить значение переменной:"
  },
  {
    "_id": "64518e2a78a3eb63645a9d14",
    "parentId": "64518e2a78a3eb63645a9d12",
    "content_type": "code",
    "order": 1,
    "content_data": "const user = null\nconsole.log(contentTypeof user) // object"
  },
  {
    "_id": "64518e2a78a3eb63645a9d18",
    "parentId": "64518e2a78a3eb63645a9d17",
    "content_type": "text",
    "order": 0,
    "content_data": "Основные отличия состоят в следующем:"
  },
  {
    "_id": "64518e2a78a3eb63645a9d19",
    "parentId": "64518e2a78a3eb63645a9d17",
    "content_type": "table",
    "order": 1,
    "content_data": [
      [
        "Null",
        "Undefined"
      ],
      [
        "Присваивается в качестве индикатора отсутствия значения",
        "Является значением по умолчанию для переменных, которым не было присвоено значение, или необъявленных переменных"
      ],
      [
        "Тип - object",
        "Тип - undefined"
      ],
      [
        "Примитивный тип, означающий нуль, отсутствие значения или ссылки",
        "Примитивный тип, означающий, что переменной не было присвоено значения"
      ],
      [
        "Указывает на отсутствие значения переменной",
        "Указывает на отсутствие переменной или неопределенность ее значения"
      ]
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9d1f",
    "parentId": "64518e2a78a3eb63645a9d1e",
    "content_type": "text",
    "order": 0,
    "content_data": "Функция eval() вычисляет переданную ей строку. Строка может быть выражением, переменной, одним или несколькими операторами:"
  },
  {
    "_id": "64518e2a78a3eb63645a9d20",
    "parentId": "64518e2a78a3eb63645a9d1e",
    "content_type": "code",
    "order": 1,
    "content_data": "console.log(eval('1 + 2')) // 3\n\n// пример с каррированием\nconst curryCalc = x => operator => y =>\n    new Promise((resolve, reject) =>\n        resolve(eval(`x${operator}y`))\n    ).then(\n        result => console.log(result),\n        error => console.error('Некорректная операция!')\n    )\n\ncurryCalc(1)('+')(2) // 3\ncurryCalc(4)('-')(3) // 1\ncurryCalc(5)('x')(6) // Некорректная операция!"
  },
  {
    "_id": "64518e2a78a3eb63645a9d21",
    "parentId": "64518e2a78a3eb63645a9d1e",
    "content_type": "text",
    "order": 2,
    "content_data": "Использовать не рекомендуется."
  },
  {
    "_id": "64518e2a78a3eb63645a9d25",
    "parentId": "64518e2a78a3eb63645a9d24",
    "content_type": "text",
    "order": 0,
    "content_data": "Информацию об истории перемещений между страницами в браузере содержит свойство history объекта window. Для перехода к предыдущей или следующей странице следует использовать методы back(), next() или go():"
  },
  {
    "_id": "64518e2a78a3eb63645a9d26",
    "parentId": "64518e2a78a3eb63645a9d24",
    "content_type": "code",
    "order": 1,
    "content_data": "const goBack = () => {\n    history.back()\n    // или\n    history.go(-1)\n}\n\nconst goForward = () => history.forward()"
  },
  {
    "_id": "64518e2a78a3eb63645a9d29",
    "parentId": "64518e2a78a3eb63645a9d28",
    "content_type": "text",
    "order": 0,
    "content_data": "В JavaScript есть 8 основных типов:"
  },
  {
    "_id": "64518e2a78a3eb63645a9d2a",
    "parentId": "64518e2a78a3eb63645a9d28",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "number для любых чисел: целочисленных или чисел с плавающей точкой, целочисленные значения ограничены диапазоном ±253",
      "bigint для целых чисел произвольной длины",
      "string для строк. Строка может содержать один или больше символов, нет отдельного символьного типа",
      "boolean для true/false",
      "null для неизвестных значений – отдельный тип, имеющий одно значение null",
      "undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined",
      "object для более сложных структур данных",
      "symbol для уникальных идентификаторов"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9d2e",
    "parentId": "64518e2a78a3eb63645a9d2d",
    "content_type": "text",
    "order": 0,
    "content_data": "Функция isNaN() преобразует значение в число и проверяет, является ли оно NaN."
  },
  {
    "_id": "64518e2a78a3eb63645a9d2f",
    "parentId": "64518e2a78a3eb63645a9d2d",
    "content_type": "code",
    "order": 1,
    "content_data": "isNaN('hello') // true\nisNaN(100) // false"
  },
  {
    "_id": "64518e2a78a3eb63645a9d30",
    "parentId": "64518e2a78a3eb63645a9d2d",
    "content_type": "text",
    "order": 2,
    "content_data": "Более надежной версией данной функции является метод Number.isNaN(), представленный в ES6."
  },
  {
    "_id": "64518e2a78a3eb63645a9d34",
    "parentId": "64518e2a78a3eb63645a9d33",
    "content_type": "text",
    "order": 0,
    "content_data": "Основные отличия заключаются в следующем:"
  },
  {
    "_id": "64518e2a78a3eb63645a9d35",
    "parentId": "64518e2a78a3eb63645a9d33",
    "content_type": "table",
    "order": 1,
    "content_data": [
      [
        "Необъявленные",
        "Неопределенные"
      ],
      [
        "Не существуют в программе",
        "Были объявлены без присвоения значения"
      ],
      [
        "Попытка доступа заканчивается ошибкой",
        "При попытке получить доступ возвращается undefined"
      ],
      [
        "Поднимается (всплывает) в начало текущей области видимости",
        "Также поднимается, но без присвоенного значения, т.е. со значением undefined (поднимается только объявление, но не инициализация)"
      ]
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9d39",
    "parentId": "64518e2a78a3eb63645a9d38",
    "content_type": "text",
    "order": 0,
    "content_data": "В браузере глобальные функции и переменные, объявленные с помощью ключевого слова \"var\", или без использованию ключевого слова (в нестрогом режиме), становятся свойствами глобального объекта window (не работает в модулях). Такие переменные доступны из любого места программы. Использовать глобальные переменные не рекомендуется. При необходимости создания глобальной переменной лучше сделать это явно:"
  },
  {
    "_id": "64518e2a78a3eb63645a9d3a",
    "parentId": "64518e2a78a3eb63645a9d38",
    "content_type": "code",
    "order": 1,
    "content_data": "window.currentUser = {\n    name: 'Ванька'\n}\n\n// или\nglobalThis.currentUser = {\n    name: 'Ванька'\n}\n\nconsole.log(currentUser.name) // Ванька"
  },
  {
    "_id": "64518e2a78a3eb63645a9d3d",
    "parentId": "64518e2a78a3eb63645a9d3c",
    "content_type": "text",
    "order": 0,
    "content_data": "Создание глобальных переменных приводит к загрязнению глобального пространства имен, что может вызвать конфликт между названиями переменных. Это также усложняет отладку и тестирование кода."
  },
  {
    "_id": "64518e2a78a3eb63645a9d40",
    "parentId": "64518e2a78a3eb63645a9d3f",
    "content_type": "text",
    "order": 0,
    "content_data": "Глобальное свойство NaN является значением, представляющим собой не число (Not-a-Number). Точнее, NaN указывает на то, что значение является неправильным, но все-таки числом. Поэтому contentTypeof NaN возвращает number."
  },
  {
    "_id": "64518e2a78a3eb63645a9d41",
    "parentId": "64518e2a78a3eb63645a9d3f",
    "content_type": "code",
    "order": 1,
    "content_data": "parseInt('bla') // NaN\nMath.sqrt(-1) // NaN"
  },
  {
    "_id": "64518e2a78a3eb63645a9d44",
    "parentId": "64518e2a78a3eb63645a9d43",
    "content_type": "text",
    "order": 0,
    "content_data": "Глобальная функция isFinite() преобразует аргумент в число и возвращает true, если оно является обычным (конечным) числом, т.е. не NaN, Infinity (положительная бесконечность), -Infinity (отрицательная бесконечность). В противном случае, возвращается false."
  },
  {
    "_id": "64518e2a78a3eb63645a9d45",
    "parentId": "64518e2a78a3eb63645a9d43",
    "content_type": "code",
    "order": 1,
    "content_data": "isFinite(Infinity) // false\nisFinite(-Infinity) // false\nisFinite(NaN) // false\n\nisFinite(100) // true"
  },
  {
    "_id": "64518e2a78a3eb63645a9d46",
    "parentId": "64518e2a78a3eb63645a9d43",
    "content_type": "text",
    "order": 2,
    "content_data": "Также существует метод Number.isFinite(), который в отличие от isFinite() не преобразует аргумент в число перед проверкой."
  },
  {
    "_id": "64518e2a78a3eb63645a9d4a",
    "parentId": "64518e2a78a3eb63645a9d49",
    "content_type": "text",
    "order": 0,
    "content_data": "Поток событий (распространение событий) - это порядок, в котором событие возникает на странице. Когда вы кликаете по элементу, вложенному в другие элементы, перед тем как событие достигнет целевого элемента, оно последовательно пройдет через всех его предков, начиная от глобального объекта window. Существует три стадии распространения события:"
  },
  {
    "_id": "64518e2a78a3eb63645a9d4b",
    "parentId": "64518e2a78a3eb63645a9d49",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "Сверху вниз - стадия захвата или погружения",
      "Целевая стадия",
      "Снизу вверх - стадия всплытия или поднятия (не путать с поднятием переменных - hoisting)"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9d4e",
    "parentId": "64518e2a78a3eb63645a9d4d",
    "content_type": "text",
    "order": 0,
    "content_data": "Всплытие - это стадия распространения события, когда событие сначала регистрируется на целевом элементе, а затем по цепочке из предков данного элемента поднимается до самого верхнего (внешнего) элемента - глобального объекта window."
  },
  {
    "_id": "64518e2a78a3eb63645a9d51",
    "parentId": "64518e2a78a3eb63645a9d50",
    "content_type": "text",
    "order": 0,
    "content_data": "Погружение - это стадия возникновения события, когда оно сначала регистрируется на самом верхнем (внешнем) элементе (глобальном объекте window), а затем спускается вниз по цепочке из предков до целевого элемента."
  },
  {
    "_id": "64518e2a78a3eb63645a9d54",
    "parentId": "64518e2a78a3eb63645a9d53",
    "content_type": "text",
    "order": 0,
    "content_data": "Это можно сделать разными способами:"
  },
  {
    "_id": "64518e2a78a3eb63645a9d55",
    "parentId": "64518e2a78a3eb63645a9d53",
    "content_type": "code",
    "order": 1,
    "content_data": "function submitForm() {\n    document.forms[0].submit()\n}\n\nform.onsubmit = function(event) {\n    event.preventDefault()\n    // код\n}\n\nform.addEventListener('submit', event => {\n    event.preventDefault()\n    // код\n})"
  },
  {
    "_id": "64518e2a78a3eb63645a9d56",
    "parentId": "64518e2a78a3eb63645a9d53",
    "content_type": "text",
    "order": 2,
    "content_data": "Любая кнопка в форме по умолчанию имеет тип submit, т.е. служит для отправки формы."
  },
  {
    "_id": "64518e2a78a3eb63645a9d5a",
    "parentId": "64518e2a78a3eb63645a9d59",
    "content_type": "text",
    "order": 0,
    "content_data": "Данную информацию содержит глобальный объект navigator. Некоторую часть этой информации можно получить через его свойство platform:"
  },
  {
    "_id": "64518e2a78a3eb63645a9d5b",
    "parentId": "64518e2a78a3eb63645a9d59",
    "content_type": "code",
    "order": 1,
    "content_data": "console.log(navigator.platform)"
  },
  {
    "_id": "64518e2a78a3eb63645a9d5e",
    "parentId": "64518e2a78a3eb63645a9d5d",
    "content_type": "text",
    "order": 0,
    "content_data": "Событие DOMContentLoaded возникает, когда первоначальный HTML документ полностью загружен и разобран без ожидания полной загрузки таблиц стилей, изображений или фреймов. Событие load возникает после полной загрузки страницы, включая все дополнительные ресурсы."
  },
  {
    "_id": "64518e2a78a3eb63645a9d63",
    "parentId": "64518e2a78a3eb63645a9d62",
    "content_type": "text",
    "order": 0,
    "content_data": "Нативные объекты (native objects) являются частью языка и определяются в спецификации ECMAScript. Такими объектами являются, например, Number, String, Function, Object, Math, RegExp, Date и т.д. Хостовые объекты (host objects) предоставляются браузером или другой средой выполнения, например, Node.js. Такими объектами являются, например, window, document (DOM), XMLHttpRequest, Web API (стек вызовов - call stack, очередь задач - task queue) и др. Пользовательскими объектами (user objects) являются любые объекты, создаваемые в коде, например, объект, содержащий информацию о пользователе:"
  },
  {
    "_id": "64518e2a78a3eb63645a9d64",
    "parentId": "64518e2a78a3eb63645a9d62",
    "content_type": "code",
    "order": 1,
    "content_data": "const user = {\n    name: 'Ванька',\n    age: 30\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9d68",
    "parentId": "64518e2a78a3eb63645a9d67",
    "content_type": "text",
    "order": 0,
    "content_data": "Такими средствами являются:"
  },
  {
    "_id": "64518e2a78a3eb63645a9d69",
    "parentId": "64518e2a78a3eb63645a9d67",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "Инструменты разработчика в браузере, например, Chrome DevTools",
      "Выражение debugger",
      "Старый-добрый console.log()"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9d6e",
    "parentId": "64518e2a78a3eb63645a9d6d",
    "content_type": "text",
    "order": 0,
    "content_data": "Преимущества:"
  },
  {
    "_id": "64518e2a78a3eb63645a9d6f",
    "parentId": "64518e2a78a3eb63645a9d6d",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "Предотвращают ад колбэков",
      "Позволяют выполнять асинхронный код последовательно с помощью then()",
      "Позволяют выполнять асинхронный код параллельно с помощью Promise.all()",
      "Решают многие проблемы колбэков (слишком поздний или слишком ранний вызов, несколько вызовов вместо одного, скрытие ошибок)"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9d70",
    "parentId": "64518e2a78a3eb63645a9d6d",
    "content_type": "text",
    "order": 2,
    "content_data": "Недостатки"
  },
  {
    "_id": "64518e2a78a3eb63645a9d71",
    "parentId": "64518e2a78a3eb63645a9d6d",
    "content_type": "list",
    "order": 3,
    "content_data": [
      "Код становится сложнее писать",
      "Для обеспечения поддержки старыми браузерами нужен полифил (таких браузеров на сегодняшний день почти не осталось)"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9d77",
    "parentId": "64518e2a78a3eb63645a9d76",
    "content_type": "text",
    "order": 0,
    "content_data": "Когда браузер загружает страницу, он разбирает HTML и генерирует из него DOM-объекты. Для узлов-элементов большинство стандартных HTML-атрибутов автоматически становятся свойствами DOM-объектов. Т.е. атрибут элемента указывается в разметке, а его свойство в DOM. Например, для тега body с атрибутом id=\"page\" у DOM-объекта будет свойство body.id=\"page\"."
  },
  {
    "_id": "64518e2a78a3eb63645a9d78",
    "parentId": "64518e2a78a3eb63645a9d76",
    "content_type": "code",
    "order": 1,
    "content_data": "<input contentType=\"text\" value=\"Доброе утро!\">\n// данный элемент имеет два атрибута: contentType и value\n\nconst input = document.querySelector('input')\n// получаем атрибут\nconsole.log(input.getAttribute('value'))\n// получаем свойство\nconsole.log(input.value)\n\n// меняем значение атрибута\ninput.setAttribute('value', 'Добрый вечер!')\n// меняем значение свойства\ninput.value = 'Добрый вечер!'"
  },
  {
    "_id": "64518e2a78a3eb63645a9d79",
    "parentId": "64518e2a78a3eb63645a9d76",
    "content_type": "text",
    "order": 2,
    "content_data": "Обратите внимание, что спецификация ECMAScript также определяет атрибуты свойств объекта - [[Value]], [[Writable]], [[Enumerable]] и [[Configurable]]."
  },
  {
    "_id": "64518e2a78a3eb63645a9d7c",
    "parentId": "64518e2a78a3eb63645a9d7b",
    "content_type": "text",
    "order": 0,
    "content_data": "Политика общего происхождения (одинакового источника) блокирует доступ к данным из другого источника. Источником является сочетание протокола, хоста и порта. По умолчанию, совместное использование ресурсов (cross-origin resource sharing, CORS) запрещено, т.е. данные предоставляются только в ответ на запрос из того же источника, в котором они находятся. Это поведение можно изменить с помощью специальных HTTP-заголовков."
  },
  {
    "_id": "64518e2a78a3eb63645a9d81",
    "parentId": "64518e2a78a3eb63645a9d80",
    "content_type": "text",
    "order": 0,
    "content_data": "Оператор void вычисляет переданное выражение и возвращает undefined. Обычно, когда мы кликаем по ссылке, браузер загружает новую сраницу или перезагружает текущую. С помощью выражения \"void(0)\" можно этого избежать:"
  },
  {
    "_id": "64518e2a78a3eb63645a9d82",
    "parentId": "64518e2a78a3eb63645a9d80",
    "content_type": "code",
    "order": 1,
    "content_data": "<a href=\"javascript:void(0)\" onclick=\"alert('Привет!')\">Нажми на меня!\n</a>"
  },
  {
    "_id": "64518e2a78a3eb63645a9d83",
    "parentId": "64518e2a78a3eb63645a9d80",
    "content_type": "text",
    "order": 2,
    "content_data": "Перезагрузку страницы также можно предотвратить с помощью простой заглушки:"
  },
  {
    "_id": "64518e2a78a3eb63645a9d84",
    "parentId": "64518e2a78a3eb63645a9d80",
    "content_type": "code",
    "order": 3,
    "content_data": "<a href=\"#\">Битая ссылка</a>\n// в этом случае символ \"#\" добавляется к URL в адресной строке"
  },
  {
    "_id": "64518e2a78a3eb63645a9d87",
    "parentId": "64518e2a78a3eb63645a9d86",
    "content_type": "text",
    "order": 0,
    "content_data": "Сам по себе JavaScript - это интерпретируемый язык программирования. Движок (engine) разбирает код, интерпретирует каждую строку и выполняет ее. Однако, в современных браузерах используется технология под названием \"компиляция на лету\" (just-in-time, JIT compilation), когда код компилируется (оптимизируется) перед выполнением. Это увеличивает время подготовки к выполнению кода, но существенно ускоряет само выполнение. Например, в V8, движке, используемом в Chrome и Node.js, для разбора кода применяется интерпретатор Ignition, а для оптимизации кода - компилятор TurboFan."
  },
  {
    "_id": "64518e2a78a3eb63645a9d8b",
    "parentId": "64518e2a78a3eb63645a9d8a",
    "content_type": "text",
    "order": 0,
    "content_data": "Да, JavaScript чувствителен к регистру. Поэтому ключевые слова, названия переменных, функций и объектов должны быть идентичными при их использовании. Например, const somename и const someName - это разные переменные, contentTypeof(1) - number, а contentTypeOf 1 - ReferenceError: contentTypeOf is not defined."
  },
  {
    "_id": "64518e2a78a3eb63645a9d8f",
    "parentId": "64518e2a78a3eb63645a9d8e",
    "content_type": "text",
    "order": 0,
    "content_data": "Нет, это два разных языка программирования. Однако, они оба относятся к объектно-ориентированным языкам и, как и множество других языков, используют похожий синтаксис (if, else, for, switch, break, continue и т.д.). По сути, Java в JavaScript - это маркетинговый ход."
  },
  {
    "_id": "64518e2a78a3eb63645a9d93",
    "parentId": "64518e2a78a3eb63645a9d92",
    "content_type": "text",
    "order": 0,
    "content_data": "Событие - это реакция браузера на определенное действие. Таким действием может быть действие пользователя, например, нажатие кнопки или ввод текста, загрузка страницы, получение ответа на запрос и т.д. (действия, приводящие к возникновению событий, не обязательно зависят от пользователя). События регистрируются с целью их дальнейшей обработки."
  },
  {
    "_id": "64518e2a78a3eb63645a9d94",
    "parentId": "64518e2a78a3eb63645a9d92",
    "content_type": "code",
    "order": 1,
    "content_data": "button.onclick = () => alert('Привет!')\n\ninput.addEventListener('change', function() {\n    p.textContent = this.value\n})\n\nwindow.onload = () => console.log('Страница полностью загружена')"
  },
  {
    "_id": "64518e2a78a3eb63645a9d98",
    "parentId": "64518e2a78a3eb63645a9d97",
    "content_type": "text",
    "order": 0,
    "content_data": "JavaScript был создан Бренданом Эйхом во время его работы в Netscape Communications. Первоначально язык назывался Mocha, затем был переименован в LiveScript и предназначался как для программирования на стороне клиента, так и для программирования на стороне сервера (там он должен был называться LiveWire)."
  },
  {
    "_id": "64518e2a78a3eb63645a9d9c",
    "parentId": "64518e2a78a3eb63645a9d9b",
    "content_type": "text",
    "order": 0,
    "content_data": "Данный метод отключает стандартную обработку событий браузером. Например, с его помощью можно предотвратить отправку формы или открытие новой страницы при клике по ссылке."
  },
  {
    "_id": "64518e2a78a3eb63645a9d9d",
    "parentId": "64518e2a78a3eb63645a9d9b",
    "content_type": "code",
    "order": 1,
    "content_data": "link.addEventListener('click', event => {\n    event.preventDefault()\n    // код\n})"
  },
  {
    "_id": "64518e2a78a3eb63645a9d9e",
    "parentId": "64518e2a78a3eb63645a9d9b",
    "content_type": "text",
    "order": 2,
    "content_data": "Обратите внимание: не все события отменяемы."
  },
  {
    "_id": "64518e2a78a3eb63645a9da2",
    "parentId": "64518e2a78a3eb63645a9da1",
    "content_type": "text",
    "order": 0,
    "content_data": "Данный метод используется для предотвращения всплытия или поднятия события вверх по цепочке из предков целевого элемента. Другими словами, он прекращает передачу события от целевого элемента к его предкам. Рассмотрим пример:"
  },
  {
    "_id": "64518e2a78a3eb63645a9da3",
    "parentId": "64518e2a78a3eb63645a9da1",
    "content_type": "code",
    "order": 1,
    "content_data": "<div onclick=\"f2()\">\n    <div onclick=\"f1()\"></div>\n</div>\n\nfunction f1(event) {\n    event.stopPropagation()\n    console.log('Внутренний контейнер')\n}\n\nfunction f2() {\n    console.log('Внешний контейнер')\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9da4",
    "parentId": "64518e2a78a3eb63645a9da1",
    "content_type": "text",
    "order": 2,
    "content_data": "При клике по вложенному контейнеру в консоль выводится сообщение \"Внутренний контейнер\". Если убрать event.stopPropagation(), то при клике по вложенному контейнеру, в консоль будут выведены оба сообщения."
  },
  {
    "_id": "64518e2a78a3eb63645a9da8",
    "parentId": "64518e2a78a3eb63645a9da7",
    "content_type": "text",
    "order": 0,
    "content_data": "Данная инструкция используется в обработчиках событий для:"
  },
  {
    "_id": "64518e2a78a3eb63645a9da9",
    "parentId": "64518e2a78a3eb63645a9da7",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "Отмены стандартного поведения браузера",
      "Предотвращения распространения события по DOM",
      "Остановки выполнения колбэка и возврата управления вызвавшей его функции"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9daa",
    "parentId": "64518e2a78a3eb63645a9da7",
    "content_type": "text",
    "order": 2,
    "content_data": "Обратите внимание: без указания возвращаемого значения оператор return возвращает undefined."
  },
  {
    "_id": "64518e2a78a3eb63645a9dae",
    "parentId": "64518e2a78a3eb63645a9dad",
    "content_type": "text",
    "order": 0,
    "content_data": "BOM или (Browser Object Model - объектная модель браузера) позволяет JavaScript взаимодействовать с браузером. Данная модель включает в себя такие объекты, как navigator, location, history, screen, XMLHttpRequest и т.п. Другими словами, BOM - это дополнительные объекты, предоставляемые браузером, чтобы работать со всем, кроме документа."
  },
  {
    "_id": "64518e2a78a3eb63645a9daf",
    "parentId": "64518e2a78a3eb63645a9dad",
    "content_type": "text",
    "order": 1,
    "content_data": "Обратите внимание: BOM не стандартизирована, поэтому ее реализация может отличаться в разных браузерах.",
    "content_image": "bom.png"
  },
  {
    "_id": "64518e2a78a3eb63645a9db2",
    "parentId": "64518e2a78a3eb63645a9db1",
    "content_type": "text",
    "order": 0,
    "content_data": "Данный метод используется для отложенного выполнения задачи. Другими словами, он позволяет запустить выполнение функции или вычисление выражения через определенное время (в миллисекундах). В следующем примере мы выводим сообщение в консоль через 2 секунды:"
  },
  {
    "_id": "64518e2a78a3eb63645a9db3",
    "parentId": "64518e2a78a3eb63645a9db1",
    "content_type": "code",
    "order": 1,
    "content_data": "setTimeout(() => console.log('Привет!'), 2000)\n\n// во избежание утечек памяти, рекомендуется делать так\nconst timer = setTimeout(() => {\n    console.log('Привет!')\n    clearTimeout(timer)\n}, 2000)"
  },
  {
    "_id": "64518e2a78a3eb63645a9db7",
    "parentId": "64518e2a78a3eb63645a9db6",
    "content_type": "text",
    "order": 0,
    "content_data": "Данный метод используется для периодического выполнения задачи. Другим словами, он позволяет запускать выполнение функции или вычисление выражения через определенный промежуток времени (в миллисекундах). В следующем примере мы выводим сообщение в консоль каждые 2 секунды:"
  },
  {
    "_id": "64518e2a78a3eb63645a9db8",
    "parentId": "64518e2a78a3eb63645a9db6",
    "content_type": "code",
    "order": 1,
    "content_data": "setInterval(() => console.log('Привет!'), 2000)\n\n// во избежание утечек памяти, не забывайте отключать таймер\n// после достижения поставленной цели\nlet i = 0\nconst timer = setInterval(() => {\n    console.log('Привет!')\n    i++\n\n    if (i == 2) {\n        clearInterval(timer)\n    }\n}, 2000)"
  },
  {
    "_id": "64518e2a78a3eb63645a9db9",
    "parentId": "64518e2a78a3eb63645a9db6",
    "content_type": "text",
    "order": 2,
    "content_data": "Во втором примере сообщение \"Привет!\" выведется в консоль два раза, после чего таймер будет остановлен"
  },
  {
    "_id": "64518e2a78a3eb63645a9dbd",
    "parentId": "64518e2a78a3eb63645a9dbc",
    "content_type": "text",
    "order": 0,
    "content_data": "JavaScript является однопоточным или синхронным языком программирования. Это означает, что в один момент времени может выполняться только одна задача. Если задача является сложной, ее выполнение может занять продолжительное время и все это время основной поток выполнения кода будет заблокирован. Блокировка потока, в свою очередь, означает отсутствие интерактивности на странице. Браузер перестает реагировать на действия пользователя и другие события. Для решения данной проблемы применяются колбэки, промисы, async/await, воркеры и другие инструменты для работы с асинхронным кодом. В JavaScript в отличие, например, от Java, Go или C++ нет возможности создавать дополнительные потоки или процессы."
  },
  {
    "_id": "64518e2a78a3eb63645a9dc1",
    "parentId": "64518e2a78a3eb63645a9dc0",
    "content_type": "text",
    "order": 0,
    "content_data": "Делегирование событий - это техника, при которой событие регистрируется на родительском элементе для обработки событий, вызываемых дочерними элементами."
  },
  {
    "_id": "64518e2a78a3eb63645a9dc2",
    "parentId": "64518e2a78a3eb63645a9dc0",
    "content_type": "text",
    "order": 1,
    "content_data": "Часто применяется для обработки нажатия кнопок в группирующем контейнере или изменения полей для ввода текста в формах, например:"
  },
  {
    "_id": "64518e2a78a3eb63645a9dc3",
    "parentId": "64518e2a78a3eb63645a9dc0",
    "content_type": "code",
    "order": 2,
    "content_data": "<form>\n    <input contentType=\"text\" class=\"first-input\">\n    <input contentType=\"text\" class=\"second-input\">\n</form>\n\n<div>\n    <button class=\"first-button\">click</button>\n    <button class=\"second-button\">click</button>\n</div>\n\nconst form = document.querySelector('form')\nconst buttons = document.querySelector('div')\n\nform.addEventListener('input', event => {\n    console.log(event.target.className)\n})\n\nbuttons.addEventListener('click', event => {\n    console.log(event.target.className)\n})"
  },
  {
    "_id": "64518e2a78a3eb63645a9dc4",
    "parentId": "64518e2a78a3eb63645a9dc0",
    "content_type": "text",
    "order": 3,
    "content_data": "В приведенном примере вместо регистрации обработчиков на дочерних элементах, мы регистрируем их на родительских элементах. Ввод текста в поле или нажатие кнопки приводят к выводу названия класса соответствующего элемента в консоль."
  },
  {
    "_id": "64518e2a78a3eb63645a9dc7",
    "parentId": "64518e2a78a3eb63645a9dc6",
    "content_type": "text",
    "order": 0,
    "content_data": "ECMAScript - это язык программирования, лежащий в основе JavaScript. Это своего рода шаблон или схема, по которой \"строится\" JavaScript. ECMAScript стандартизирован в спецификации ECMA-262 организацией по стандартам Ecma International."
  },
  {
    "_id": "64518e2a78a3eb63645a9dcb",
    "parentId": "64518e2a78a3eb63645a9dca",
    "content_type": "text",
    "order": 0,
    "content_data": "Синтаксис JSON имеет следующие особенности:"
  },
  {
    "_id": "64518e2a78a3eb63645a9dcc",
    "parentId": "64518e2a78a3eb63645a9dca",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "Данные представляют собой пары ключ/значение",
      "Ключ и значение оборачиваются в двойные кавычки, кроме случаев, когда значение является числом (\"key\": \"value\")",
      "Данные разделяются запятыми",
      "Объекты оборачиваются в фигурные скобки",
      "Массивы - в квадратные"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9dd0",
    "parentId": "64518e2a78a3eb63645a9dcf",
    "content_type": "text",
    "order": 0,
    "content_data": "При отправке данных на сервер, они должны иметь специальный строковый формат. Для преобразования объекта в строку в формате JSON используется метод JSON.stringify():"
  },
  {
    "_id": "64518e2a78a3eb63645a9dd1",
    "parentId": "64518e2a78a3eb63645a9dcf",
    "content_type": "code",
    "order": 1,
    "content_data": "const user = { name: 'Ванька', age: 30 }\nconst str = JSON.stringify(user)\nconsole.log(str) // {\"name\":\"Ванька\",\"age\":30}"
  },
  {
    "_id": "64518e2a78a3eb63645a9dd5",
    "parentId": "64518e2a78a3eb63645a9dd4",
    "content_type": "text",
    "order": 0,
    "content_data": "При получении данных от сервера, они имеют специальный строковый формат. Для преобразования этих данных в JavaScript объект используется метод JSON.parse():"
  },
  {
    "_id": "64518e2a78a3eb63645a9dd6",
    "parentId": "64518e2a78a3eb63645a9dd4",
    "content_type": "code",
    "order": 1,
    "content_data": "const str = { \"name\":\"Ванька\",\"age\":30 }\nconst user = JSON.parse(str)\nconsole.log(user) // {name: \"Ванька\", age: 30}"
  },
  {
    "_id": "64518e2a78a3eb63645a9dda",
    "parentId": "64518e2a78a3eb63645a9dd9",
    "content_type": "text",
    "order": 0,
    "content_data": "При обмене данными между клиентом и сервером, эти данные могут быть только строками. Поскольку JSON - это текст, он прекрасно для этого подходит. Также он может использоваться как формат для данных любым языком программирования, наряду с другими форматами, такими как XML или Protobuf."
  },
  {
    "_id": "64518e2a78a3eb63645a9dde",
    "parentId": "64518e2a78a3eb63645a9ddd",
    "content_type": "text",
    "order": 0,
    "content_data": "Если кратко, то PWA - это веб-сайты, которые ведут себя подобно нативным приложениям. Они могут быть установлены на телефон или компьютер, а также, как правило, работают в оффлайне. Для последнего используются сервис-воркеры и интерфейс кэширования. Преимуществом PWA перед мобильными приложениями является их размер и относительная легкость разработки. Также не нужно тратить ресурсы на создание двух приложений для одного сайта - веб и мобильного. При этом сохраняется хороший пользовательский опыт."
  },
  {
    "_id": "64518e2a78a3eb63645a9de1",
    "parentId": "64518e2a78a3eb63645a9de0",
    "content_type": "text",
    "order": 0,
    "content_data": "Данный метод используется для остановки таймера, запущенного с помощью setTimeout(). Для этого идентификатор таймера записывается в переменную, которая затем передается clearTimeout() в качестве аргумента."
  },
  {
    "_id": "64518e2a78a3eb63645a9de2",
    "parentId": "64518e2a78a3eb63645a9de0",
    "content_type": "code",
    "order": 1,
    "content_data": "const timer = setTimeout(() => {\n    console.log('Привет!')\n    clearTimeout(timer)\n}, 2000)"
  },
  {
    "_id": "64518e2a78a3eb63645a9de3",
    "parentId": "64518e2a78a3eb63645a9de0",
    "content_type": "text",
    "order": 2,
    "content_data": "В приведенном примере через две секунды в консоль выводится сообщение \"Привет!\", после чего таймер останавливается. Это делается для того, чтобы сборщик мусора мог удалить выполненный таймер."
  },
  {
    "_id": "64518e2a78a3eb63645a9de7",
    "parentId": "64518e2a78a3eb63645a9de6",
    "content_type": "text",
    "order": 0,
    "content_data": "Данный метод используется для остановки таймера, запущенного с помощью setInterval(). Для этого идентификатор таймера записывается в переменную, которая затем передается clearInterval() в качестве аргумента."
  },
  {
    "_id": "64518e2a78a3eb63645a9de8",
    "parentId": "64518e2a78a3eb63645a9de6",
    "content_type": "code",
    "order": 1,
    "content_data": "let i = 1\nconst timer = setInterval(() => {\n    console.log(i)\n    i++\n\n    if (i === 3) clearInterval(timer)\n}, 1000)"
  },
  {
    "_id": "64518e2a78a3eb63645a9de9",
    "parentId": "64518e2a78a3eb63645a9de6",
    "content_type": "text",
    "order": 2,
    "content_data": "В приведенном примере в консоль каждую секунду выводится значение переменной i, которое каждый раз увеличивается на 1 (1, 2). Когда значение i становится равным 3, таймер останавливается."
  },
  {
    "_id": "64518e2a78a3eb63645a9ded",
    "parentId": "64518e2a78a3eb63645a9dec",
    "content_type": "text",
    "order": 0,
    "content_data": "Для этого можно использовать свойство location объекта window:"
  },
  {
    "_id": "64518e2a78a3eb63645a9dee",
    "parentId": "64518e2a78a3eb63645a9dec",
    "content_type": "code",
    "order": 1,
    "content_data": "location.href = 'newPage.html'\n// или\nlocation.replace('newPage.html')\n// или\nlocation.assign('newPage.html')"
  },
  {
    "_id": "64518e2a78a3eb63645a9df1",
    "parentId": "64518e2a78a3eb63645a9df0",
    "content_type": "text",
    "order": 0,
    "content_data": "Существует, как минимум, три способа это сделать."
  },
  {
    "_id": "64518e2a78a3eb63645a9df2",
    "parentId": "64518e2a78a3eb63645a9df0",
    "content_type": "text",
    "order": 1,
    "content_data": "String.protocontentType.includes()"
  },
  {
    "_id": "64518e2a78a3eb63645a9df3",
    "parentId": "64518e2a78a3eb63645a9df0",
    "content_type": "code",
    "order": 2,
    "content_data": "const mainStr = 'hello'\nconst subStr = 'hel'\nmainStr.includes(subStr) // true"
  },
  {
    "_id": "64518e2a78a3eb63645a9df4",
    "parentId": "64518e2a78a3eb63645a9df0",
    "content_type": "text",
    "order": 3,
    "content_data": "String.protocontentType.indexOf()"
  },
  {
    "_id": "64518e2a78a3eb63645a9df5",
    "parentId": "64518e2a78a3eb63645a9df0",
    "content_type": "code",
    "order": 4,
    "content_data": "const mainStr = 'hello'\nconst subStr = 'hel'\nmainStr.indexOf(subStr) !== -1 // true"
  },
  {
    "_id": "64518e2a78a3eb63645a9df6",
    "parentId": "64518e2a78a3eb63645a9df0",
    "content_type": "text",
    "order": 5,
    "content_data": "RegExp"
  },
  {
    "_id": "64518e2a78a3eb63645a9df7",
    "parentId": "64518e2a78a3eb63645a9df0",
    "content_type": "code",
    "order": 6,
    "content_data": "const mainStr = 'hello'\nconst regex = /hel/\nregex.test(mainStr) // true"
  },
  {
    "_id": "64518e2a78a3eb63645a9dfd",
    "parentId": "64518e2a78a3eb63645a9dfc",
    "content_type": "text",
    "order": 0,
    "content_data": "Это можно сделать средствами HTML, установив тип поля для ввода в значение email (<input contentType=\"email\">). Однако, данный способ считается не очень надежным. Поэтому, обычно, email валидируется с помощью регулярного выражения. Это рекомендуется делать на стороне сервера, поскольку на клиенте может быть отключен JavaScript:"
  },
  {
    "_id": "64518e2a78a3eb63645a9dfe",
    "parentId": "64518e2a78a3eb63645a9dfc",
    "content_type": "code",
    "order": 1,
    "content_data": "const validateEmail = email =>\n    /S+@S+.S+/\n        .test(email.toString()\n        .toLowerCase())\nconst email = 'myemail@example.com'\nvalidateEmail(email) // true"
  },
  {
    "_id": "64518e2a78a3eb63645a9dff",
    "parentId": "64518e2a78a3eb63645a9dfc",
    "content_type": "text",
    "order": 2,
    "content_data": "В приведенном примере используется одно из самых простых регулярных выражений для валидации адреса электронной почты. Более надежное выражение выглядит так (RFC 2822): [a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?"
  },
  {
    "_id": "64518e2a78a3eb63645a9e01",
    "parentId": "64518e2a78a3eb63645a9e00",
    "content_type": "text",
    "order": 0,
    "content_data": "Для этого можно использовать свойство location объекта window или свойство URL объекта document:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e02",
    "parentId": "64518e2a78a3eb63645a9e00",
    "content_type": "code",
    "order": 1,
    "content_data": "console.log('Текущий URL', location.href)\nconsole.log('Текущий URL', document.URL) // в Chrome в пустой вкладке получаем \"Текущий URL chrome-search://local-ntp/local-ntp.html\""
  },
  {
    "_id": "64518e2a78a3eb63645a9e06",
    "parentId": "64518e2a78a3eb63645a9e05",
    "content_type": "text",
    "order": 0,
    "content_data": "Свойства объекта location могут использоваться для получения частей URL текущей страницы:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e07",
    "parentId": "64518e2a78a3eb63645a9e05",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "href - полный URL",
      "origin - протокол, хост и порт (источник, используется в Политике общего происхождения (SOP) и Совместном использовании ресурсов (CORS))",
      "protocol",
      "host - хост и порт",
      "hostname - хост",
      "port",
      "pathname - путь",
      "search - строка запроса после ?",
      "hash - строка запроса после # (якоря)",
      "username - имя пользователя перед доменом",
      "password - пароль перед доменом"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9e0a",
    "parentId": "64518e2a78a3eb63645a9e09",
    "content_type": "text",
    "order": 0,
    "content_data": "Для этого можно использовать конструктор URL:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e0b",
    "parentId": "64518e2a78a3eb63645a9e09",
    "content_type": "code",
    "order": 1,
    "content_data": "const url = new URL('https://example.com?foo=1&bar=2')\nconsole.log(url.search) // ?foo=1&bar=2\nconsole.log(url.searchParams.get('foo')) // 1"
  },
  {
    "_id": "64518e2a78a3eb63645a9e0e",
    "parentId": "64518e2a78a3eb63645a9e0d",
    "content_type": "text",
    "order": 0,
    "content_data": "Для этого существует, как минимум, три способа."
  },
  {
    "_id": "64518e2a78a3eb63645a9e0f",
    "parentId": "64518e2a78a3eb63645a9e0d",
    "content_type": "text",
    "order": 1,
    "content_data": "Оператор in"
  },
  {
    "_id": "64518e2a78a3eb63645a9e10",
    "parentId": "64518e2a78a3eb63645a9e0d",
    "content_type": "code",
    "order": 2,
    "content_data": "const user = { name: 'Ванька' }\nconsole.log('name' in user) // true\nconsole.log(!('age' in user)) // true"
  },
  {
    "_id": "64518e2a78a3eb63645a9e11",
    "parentId": "64518e2a78a3eb63645a9e0d",
    "content_type": "text",
    "order": 3,
    "content_data": "Метод hasOwnProperty()"
  },
  {
    "_id": "64518e2a78a3eb63645a9e12",
    "parentId": "64518e2a78a3eb63645a9e0d",
    "content_type": "code",
    "order": 4,
    "content_data": "const user = { name: 'Ванька' }\nconsole.log(user.hasOwnProperty('name')) // true\nconsole.log(!user.hasOwnProperty('age')) // true"
  },
  {
    "_id": "64518e2a78a3eb63645a9e13",
    "parentId": "64518e2a78a3eb63645a9e0d",
    "content_type": "text",
    "order": 5,
    "content_data": "Сравнение с undefined"
  },
  {
    "_id": "64518e2a78a3eb63645a9e14",
    "parentId": "64518e2a78a3eb63645a9e0d",
    "content_type": "code",
    "order": 6,
    "content_data": "const user = { name: 'Ванька' }\nconsole.log(user.name !== undefined) // true\nconsole.log(user.age === undefined) // true"
  },
  {
    "_id": "64518e2a78a3eb63645a9e19",
    "parentId": "64518e2a78a3eb63645a9e18",
    "content_type": "text",
    "order": 0,
    "content_data": "Для этого можно использовать цикл for...in совместно с методом hasOwnProperty() для исключения унаследованных свойств."
  },
  {
    "_id": "64518e2a78a3eb63645a9e1a",
    "parentId": "64518e2a78a3eb63645a9e18",
    "content_type": "code",
    "order": 1,
    "content_data": "const user = {\n    name: 'Ванька',\n    age: 30\n}\n\nfor (key in user) {\n    if (user.hasOwnProperty(key)) {\n        console.log(`${key}: ${user[key]}`) // name: Ванька age: 30\n    }\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9e1e",
    "parentId": "64518e2a78a3eb63645a9e1d",
    "content_type": "text",
    "order": 0,
    "content_data": "Для этого существует, как минимум, три способа."
  },
  {
    "_id": "64518e2a78a3eb63645a9e1f",
    "parentId": "64518e2a78a3eb63645a9e1d",
    "content_type": "text",
    "order": 1,
    "content_data": "Метод Object.entries()"
  },
  {
    "_id": "64518e2a78a3eb63645a9e20",
    "parentId": "64518e2a78a3eb63645a9e1d",
    "content_type": "code",
    "order": 2,
    "content_data": "const obj = {}\nconsole.log(Object.entries(obj).length === 0) // true\n// для исключения из проверки объекта Date\nconst obj2 = new Date()\nconsole.log(Object.entries(obj2).length === 0 && obj2.constructor === Object) // false"
  },
  {
    "_id": "64518e2a78a3eb63645a9e21",
    "parentId": "64518e2a78a3eb63645a9e1d",
    "content_type": "text",
    "order": 3,
    "content_data": "Метод Object.keys()"
  },
  {
    "_id": "64518e2a78a3eb63645a9e22",
    "parentId": "64518e2a78a3eb63645a9e1d",
    "content_type": "code",
    "order": 4,
    "content_data": "const obj = {}\nconsole.log(Object.keys(obj).length === 0) // true\n// для исключения из проверки объекта Date\nconst obj2 = new Date()\nconsole.log(Object.keys(obj2).length === 0 && obj2.constructor === Object) // false"
  },
  {
    "_id": "64518e2a78a3eb63645a9e23",
    "parentId": "64518e2a78a3eb63645a9e1d",
    "content_type": "text",
    "order": 5,
    "content_data": "Цикл for...in и метод Object.hasOwnProperty()"
  },
  {
    "_id": "64518e2a78a3eb63645a9e24",
    "parentId": "64518e2a78a3eb63645a9e1d",
    "content_type": "code",
    "order": 6,
    "content_data": "const obj = {}\nconst obj2 = {key: 'value'}\n\nconst isEmpty = obj => {\n    for (key in obj) {\n        if (obj.hasOwnProperty(key)) return false\n    }\n    return true\n}\n\nconsole.log(isEmpty(obj)) // true\nconsole.log(isEmpty(obj2)) // false"
  },
  {
    "_id": "64518e2a78a3eb63645a9e2c",
    "parentId": "64518e2a78a3eb63645a9e2b",
    "content_type": "text",
    "order": 0,
    "content_data": "arguments - это массивоподобный объект (псевдомассив), содержащий переданные функции аргументы:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e2d",
    "parentId": "64518e2a78a3eb63645a9e2b",
    "content_type": "code",
    "order": 1,
    "content_data": "function sum () {\n    let total = 0\n    for (let i = 0; i < arguments.length; i++) {\n        total += arguments[i]\n    }\n    return total\n\n    // или\n    let total = 0\n    for (const i of arguments) {\n        total += i\n    }\n    return total\n\n    // или\n    return Array.from(arguments).reduce((acc, cur) => acc + cur)\n\n}\n\nsum(1, 2, 3) // 6"
  },
  {
    "_id": "64518e2a78a3eb63645a9e2e",
    "parentId": "64518e2a78a3eb63645a9e2b",
    "content_type": "text",
    "order": 2,
    "content_data": "Обратите внимание, что стрелочные функции не имеют arguments. Вместо arguments рекомендуется использовать оператор rest ... (прочие параметры), который работает как в обычных, так и в стрелочных функциях:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e2f",
    "parentId": "64518e2a78a3eb63645a9e2b",
    "content_type": "code",
    "order": 3,
    "content_data": "const sum = (...rest) => rest.reduce((acc, cur) => acc + cur)\n\nsum(1, 2, 3) // 6"
  },
  {
    "_id": "64518e2a78a3eb63645a9e33",
    "parentId": "64518e2a78a3eb63645a9e32",
    "content_type": "text",
    "order": 0,
    "content_data": "Это можно сделать с помощью методов charAt(), toUpperCase() и slice():"
  },
  {
    "_id": "64518e2a78a3eb63645a9e34",
    "parentId": "64518e2a78a3eb63645a9e32",
    "content_type": "code",
    "order": 1,
    "content_data": "String.protocontentType.capitilize = function () {\n    return this.charAt(0).toUpperCase() + this.slice(1)\n}\n\nconsole.log('hello'.capitilize()) // Hello"
  },
  {
    "_id": "64518e2a78a3eb63645a9e3a",
    "parentId": "64518e2a78a3eb63645a9e39",
    "content_type": "text",
    "order": 0,
    "content_data": "Это можно сделать с помощью объекта Date или конструктора Intl.DateTimeFormat:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e3b",
    "parentId": "64518e2a78a3eb63645a9e39",
    "content_type": "code",
    "order": 1,
    "content_data": "console.log(new Date().toLocaleDateString()) // 02.09.2020\n\nconsole.log(new Intl.DateTimeFormat(\n    'ru-Ru',\n    {\n        weekday: 'long',\n        day: 'numeric',\n        month: 'long',\n        year: 'numeric'\n    }\n).format(new Date())) // среда, 2 сентября 2020 г."
  },
  {
    "_id": "64518e2a78a3eb63645a9e41",
    "parentId": "64518e2a78a3eb63645a9e40",
    "content_type": "text",
    "order": 0,
    "content_data": "Для этого следует сравнивать не сами объекты, а, например, значения, возвращаемые методом getTime():"
  },
  {
    "_id": "64518e2a78a3eb63645a9e42",
    "parentId": "64518e2a78a3eb63645a9e40",
    "content_type": "code",
    "order": 1,
    "content_data": "const d1 = new Date()\nconst d2 = new Date(d1)\n\nconsole.log(d1.getTime() === d2.getTime()) // true\nconsole.log(d1 === d2) // false"
  },
  {
    "_id": "64518e2a78a3eb63645a9e46",
    "parentId": "64518e2a78a3eb63645a9e45",
    "content_type": "text",
    "order": 0,
    "content_data": "Для этого можно использовать встроенный метод startsWith():"
  },
  {
    "_id": "64518e2a78a3eb63645a9e47",
    "parentId": "64518e2a78a3eb63645a9e45",
    "content_type": "code",
    "order": 1,
    "content_data": "console.log('Good morning'.startsWith('Good')) // true\nconsole.log('Good morning'.startsWith('morning')) // false"
  },
  {
    "_id": "64518e2a78a3eb63645a9e48",
    "parentId": "64518e2a78a3eb63645a9e45",
    "content_type": "text",
    "order": 2,
    "content_data": "По данным CanIUse данный метод поддерживает почти 94% браузеров"
  },
  {
    "_id": "64518e2a78a3eb63645a9e4c",
    "parentId": "64518e2a78a3eb63645a9e4b",
    "content_type": "text",
    "order": 0,
    "content_data": "Для этого можно использовать встроенные методы trimStart() (начало строки), trimEnd() (конец строки) и trim() (начало и конец строки):"
  },
  {
    "_id": "64518e2a78a3eb63645a9e4d",
    "parentId": "64518e2a78a3eb63645a9e4b",
    "content_type": "code",
    "order": 1,
    "content_data": "console.log('  hello world   '.trim()) // hello world"
  },
  {
    "_id": "64518e2a78a3eb63645a9e4e",
    "parentId": "64518e2a78a3eb63645a9e4b",
    "content_type": "text",
    "order": 2,
    "content_data": "trim не работает для пробелов между словами. В этом случае можно воспользоваться методом replace() и регулярным выражением:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e4f",
    "parentId": "64518e2a78a3eb63645a9e4b",
    "content_type": "code",
    "order": 3,
    "content_data": "console.log('hello   world'.replace(/s+/, ' ')) // hello world\n// можно уточнить количество пробелов\nconsole.log('hello   world'.replace(/s{2,}/, ' ')) // hello world\nconsole.log('key   value'.replace(/s{2,}/, ' -> ')) // key -> value"
  },
  {
    "_id": "64518e2a78a3eb63645a9e50",
    "parentId": "64518e2a78a3eb63645a9e4b",
    "content_type": "text",
    "order": 4,
    "content_data": "По данным CanIUse методы trimStart() и trimEnd() поддерживает 93% браузеров."
  },
  {
    "_id": "64518e2a78a3eb63645a9e53",
    "parentId": "64518e2a78a3eb63645a9e52",
    "content_type": "text",
    "order": 0,
    "content_data": "Существует два способа это сделать. Предположим, что у нас есть такой объект:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e54",
    "parentId": "64518e2a78a3eb63645a9e52",
    "content_type": "code",
    "order": 1,
    "content_data": "const obj = {\n    name: 'Ванька',\n    age: 30\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9e55",
    "parentId": "64518e2a78a3eb63645a9e52",
    "content_type": "text",
    "order": 2,
    "content_data": "Мы можем добавить в него новое свойство, использую либо точечную, либо скобочную нотацию:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e56",
    "parentId": "64518e2a78a3eb63645a9e52",
    "content_type": "code",
    "order": 3,
    "content_data": "obj.job = 'разработчик'\nobj['job'] = 'разработчик'"
  },
  {
    "_id": "64518e2a78a3eb63645a9e57",
    "parentId": "64518e2a78a3eb63645a9e52",
    "content_type": "text",
    "order": 4,
    "content_data": "Одним из отличий указанных методов является то, что при использовании скобочной нотации добавляемый ключ может быть числом:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e58",
    "parentId": "64518e2a78a3eb63645a9e52",
    "content_type": "code",
    "order": 5,
    "content_data": "const obj = {}\nobj[1] = 'один'\nconsole.log(obj) // { 1: 'один' }\nobj.2 = 'два' // SyntaxError: Unexpected number"
  },
  {
    "_id": "64518e2a78a3eb63645a9e5c",
    "parentId": "64518e2a78a3eb63645a9e5b",
    "content_type": "text",
    "order": 0,
    "content_data": "Нет, не является. Это комбинация двух операторов: оператора ! (логическое не) и оператора -- (декремент). Если использовать указанное выражение с каким-либо значением, то сначала это значение будет уменьшено на единицу, затем преобразовано в логический тип и инвертировано:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e5d",
    "parentId": "64518e2a78a3eb63645a9e5b",
    "content_type": "code",
    "order": 1,
    "content_data": "const fun = val => !--val\nconst a = 1\nconst b = 2\nconsole.log(fun(a)) // !0 -> not false -> true\nconsole.log(fun(b)) // !1 -> not true -> false"
  },
  {
    "_id": "64518e2a78a3eb63645a9e62",
    "parentId": "64518e2a78a3eb63645a9e61",
    "content_type": "text",
    "order": 0,
    "content_data": "Для этого можно использовать оператор || (логическое или):"
  },
  {
    "_id": "64518e2a78a3eb63645a9e63",
    "parentId": "64518e2a78a3eb63645a9e61",
    "content_type": "code",
    "order": 1,
    "content_data": "const a = b || 'default'"
  },
  {
    "_id": "64518e2a78a3eb63645a9e64",
    "parentId": "64518e2a78a3eb63645a9e61",
    "content_type": "text",
    "order": 2,
    "content_data": "В данном случае переменной a будет присвоено значение default в случае, если значение переменной b будет ложным (false, undefined, null, NaN, 0, '')."
  },
  {
    "_id": "64518e2a78a3eb63645a9e65",
    "parentId": "64518e2a78a3eb63645a9e61",
    "content_type": "text",
    "order": 3,
    "content_data": "Если речь идет о стандартных значениях параметров функции, то их можно присвоить следующим образом:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e66",
    "parentId": "64518e2a78a3eb63645a9e61",
    "content_type": "code",
    "order": 4,
    "content_data": "const greet = (name = 'незнакомец') => `Привет, ${name}!`\nconsole.log(greet('Ванька')) // Привет, Ванька!\nconsole.log(greet()) // Привет, незнакомец!"
  },
  {
    "_id": "64518e2a78a3eb63645a9e67",
    "parentId": "64518e2a78a3eb63645a9e61",
    "content_type": "text",
    "order": 5,
    "content_data": "Более того, последующие параметры могут использовать значения предыдущих в качестве стандартных значений:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e68",
    "parentId": "64518e2a78a3eb63645a9e61",
    "content_type": "code",
    "order": 6,
    "content_data": "const sum = (a = 1, b = a + 2) => a + b\nconsole.log(sum()) // 4"
  },
  {
    "_id": "64518e2a78a3eb63645a9e6c",
    "parentId": "64518e2a78a3eb63645a9e6b",
    "content_type": "text",
    "order": 0,
    "content_data": "Раньше это делали примерно так (конкатенация и управляющие символы переноса строки):"
  },
  {
    "_id": "64518e2a78a3eb63645a9e6d",
    "parentId": "64518e2a78a3eb63645a9e6b",
    "content_type": "code",
    "order": 1,
    "content_data": "const str =\n    'Аз есмь' + ' ' +\n    'очень длинная' + ' ' +\n    'строка!'\n\n// или\nconst str = 'Аз есмь a\n очень длинная\n строка!'\nconsole.log(str)\n/*\n    Аз есмь\n    очень длинная\n    строка!\n*/"
  },
  {
    "_id": "64518e2a78a3eb63645a9e6e",
    "parentId": "64518e2a78a3eb63645a9e6b",
    "content_type": "text",
    "order": 2,
    "content_data": "Сейчас это делают так (шаблонный литерал):"
  },
  {
    "_id": "64518e2a78a3eb63645a9e6f",
    "parentId": "64518e2a78a3eb63645a9e6b",
    "content_type": "code",
    "order": 3,
    "content_data": "const str =\n    `Аз есмь\n    очень длинная\n    строка!`"
  },
  {
    "_id": "64518e2a78a3eb63645a9e73",
    "parentId": "64518e2a78a3eb63645a9e72",
    "content_type": "text",
    "order": 0,
    "content_data": "Поскольку функции - это тоже объекты, мы вполне можем добавлять им свойства. Значением свойства функции может быть другая функция:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e74",
    "parentId": "64518e2a78a3eb63645a9e72",
    "content_type": "code",
    "order": 1,
    "content_data": "function someFun () {}\nsomeFun.somePropName = 'somePropValue'\n\nconsole.log(someFun.somePropName) // somePropValue\n// дефолтное свойство\nconsole.log(someFun.name) // someFun\n\nconst sum = (x, y) => x + y\nconsole.log(sum(1, 2)) // 3\n\nsum.curry = x => y => x + y\nconsole.log(sum.curry(1)(2)) // 3"
  },
  {
    "_id": "64518e2a78a3eb63645a9e78",
    "parentId": "64518e2a78a3eb63645a9e77",
    "content_type": "text",
    "order": 0,
    "content_data": "Для этого можно использовать свойство length:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e79",
    "parentId": "64518e2a78a3eb63645a9e77",
    "content_type": "code",
    "order": 1,
    "content_data": "const sum = (a, b, c) => +a + +b + +c\nconsole.log(sum(1, '1', true)) // 3\nconsole.log(sum(0, '', [])) // 0\n\nconsole.log(sum.length) // 3"
  },
  {
    "_id": "64518e2a78a3eb63645a9e7c",
    "parentId": "64518e2a78a3eb63645a9e7b",
    "content_type": "text",
    "order": 0,
    "content_data": "Полифилы используются для обеспечения работы современного JavaScript-кода в старых браузерах. Это делается за счет реализации новых возможностей языка на старом синтаксисе. Сам процесс преобразования нового кода в старый называется транспиляцией. Самым популярным транспилятором JavaScript-кода является Babel."
  },
  {
    "_id": "64518e2a78a3eb63645a9e7d",
    "parentId": "64518e2a78a3eb63645a9e7b",
    "content_type": "text",
    "order": 1,
    "content_data": "Например, одной из последних возможностей JavaScript является метод Promise.allSettled(), который, в отличие от Promise.all(), не завершается при отклонении любого из переданных ему промисов."
  },
  {
    "_id": "64518e2a78a3eb63645a9e7e",
    "parentId": "64518e2a78a3eb63645a9e7b",
    "content_type": "text",
    "order": 2,
    "content_data": "Однако, на сегодняшний день его поддержка браузерами по данным CanIUse составляет 80%, поэтому нужен полифил:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e7f",
    "parentId": "64518e2a78a3eb63645a9e7b",
    "content_type": "code",
    "order": 3,
    "content_data": "const promise1 = Promise.resolve('promise1')\nconst promise2 = Promise.reject('promise2')\nconst promise3 = Promise.resolve('promise3')\n\n// вот как выглядит встроенный Promise.allSettled()\nPromise\n    .allSettled([promise1, promise2, promise3])\n    .then(console.log)\n/*\n    [\n        {status: \"fulfilled\", value: \"promise1\"},\n        {status: \"rejected\", reason: \"promise2\"},\n        {status: \"fulfilled\", value: \"promise3\"},\n    ]\n*/\n\n// а вот его полифил\n// поддержка Promise.all() = 94%\nconst allSettled = promises => {\n    const wrappedPromises = promises\n        .map(p => Promise.resolve(p)\n        .then(\n            val => ({\n                status: 'fulfilled',\n                value: val\n            }),\n            err => ({\n                status: 'rejected',\n                reason: err\n            })))\n    return Promise.all(wrappedPromises)\n}\nallSettled([promise1,promise2,promise3])\n    .then(console.log)"
  },
  {
    "_id": "64518e2a78a3eb63645a9e83",
    "parentId": "64518e2a78a3eb63645a9e82",
    "content_type": "text",
    "order": 0,
    "content_data": "Оператор break используется для выхода из цикла. После остановки итерации код выполняется дальше:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e84",
    "parentId": "64518e2a78a3eb63645a9e82",
    "content_type": "code",
    "order": 1,
    "content_data": "const obj = {\n    1: 'Everything',\n    2: 'is',\n    3: 'impossible'\n}\n\nfor (key in obj) {\n    if (obj[key] === 'impossible') break\n\n    console.log(obj[key]) // Everything is\n}\n\nconsole.log('possible') // possible"
  },
  {
    "_id": "64518e2a78a3eb63645a9e85",
    "parentId": "64518e2a78a3eb63645a9e82",
    "content_type": "text",
    "order": 2,
    "content_data": "Оператор continue используется для пропуска итерации:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e86",
    "parentId": "64518e2a78a3eb63645a9e82",
    "content_type": "code",
    "order": 3,
    "content_data": "const obj = {\n    1: 'Everything',\n    2: 'is',\n    3: 'impossible',\n    4: 'possible'\n}\n\nfor (key in obj) {\n    if (obj[key] === 'impossible') continue\n\n    console.log(obj[key]) // Everything is possible\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9e8a",
    "parentId": "64518e2a78a3eb63645a9e89",
    "content_type": "text",
    "order": 0,
    "content_data": "Метки позволяют именовать циклы и блоки кода. Они могут использоваться, например, для выхода из цикла или в качестве условия выполнения кода:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e8b",
    "parentId": "64518e2a78a3eb63645a9e89",
    "content_type": "code",
    "order": 1,
    "content_data": "loop1:\nfor (let i = 0; i < 3; i++) {\n    loop2:\n    for (let j = 0; j < 3; j++) {\n        if (i === j) continue loop1\n\n        console.log(`i = ${i}, j = ${j}`)\n    }\n}\n\n/*\n    i = 1, j = 0\n    i = 2, j = 0\n    i = 2, j = 1\n*/"
  },
  {
    "_id": "64518e2a78a3eb63645a9e8c",
    "parentId": "64518e2a78a3eb63645a9e89",
    "content_type": "text",
    "order": 2,
    "content_data": "Использование меток считается плохой практикой."
  },
  {
    "_id": "64518e2a78a3eb63645a9e8f",
    "parentId": "64518e2a78a3eb63645a9e8e",
    "content_type": "text",
    "order": 0,
    "content_data": "Рекомендуется объявлять переменные в начала каждого скрипта или фукнции. Это дает следующие преимущества:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e90",
    "parentId": "64518e2a78a3eb63645a9e8e",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "Делает код чистым",
      "Все переменные находятся в одном месте",
      "Позволяет избежать случайного создания глобальных переменных",
      "Предотвращает нежелательное переопределение переменных"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9e94",
    "parentId": "64518e2a78a3eb63645a9e93",
    "content_type": "text",
    "order": 0,
    "content_data": "Рекомендуется инициализировать все переменные в момент объявления. Это дает следующие преимущества:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e95",
    "parentId": "64518e2a78a3eb63645a9e93",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "Делает код чистым",
      "Переменные и их значения находятся в одном месте",
      "Предотвращает присвоение неинициализированным переменным значения undefined"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9e99",
    "parentId": "64518e2a78a3eb63645a9e98",
    "content_type": "text",
    "order": 0,
    "content_data": "Для создания объекта вместо конструктора объекта new Object() рекмондуется использовать скобочную нотацию {}. Также в зависимости от типа значения, рекомендуется использовать следующее:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e9a",
    "parentId": "64518e2a78a3eb63645a9e98",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "строку, например, '' вместо new String()",
      "число, например, 0 вместо new Number()",
      "логическое значение, например, false вместо new Boolean()",
      "[] вместо new Array()",
      "// вместо new RegExp()",
      "function (){} вместо new Function()"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9e9e",
    "parentId": "64518e2a78a3eb63645a9e9d",
    "content_type": "text",
    "order": 0,
    "content_data": "JSON-массив представляет собой массив JSON-объектов, например:"
  },
  {
    "_id": "64518e2a78a3eb63645a9e9f",
    "parentId": "64518e2a78a3eb63645a9e9d",
    "content_type": "code",
    "order": 1,
    "content_data": "[\n    { \"name\": \"Ванька\", \"age\": 30 },\n    { \"name\": \"Петька\", \"age\": 20 }\n]"
  },
  {
    "_id": "64518e2a78a3eb63645a9ea3",
    "parentId": "64518e2a78a3eb63645a9ea2",
    "content_type": "text",
    "order": 0,
    "content_data": "Такую функцию можно реализовать с помощью методов Math.random() и Math.floor() объекта Math:"
  },
  {
    "_id": "64518e2a78a3eb63645a9ea4",
    "parentId": "64518e2a78a3eb63645a9ea2",
    "content_type": "code",
    "order": 1,
    "content_data": "const getRandomInteger = (min, max) => Math.floor(min + Math.random() * (max + 1 - min))"
  },
  {
    "_id": "64518e2a78a3eb63645a9ea9",
    "parentId": "64518e2a78a3eb63645a9ea8",
    "content_type": "text",
    "order": 0,
    "content_data": "Tree shaking - это удаление кода неиспользуемых модулей. Такие модули не включаются в окончательную сборку (бандл). Для того, чтобы сборщик модулей (бандлер) мог определить, какие модули используются, а какие нет, структура программы должна быть основана на ES6 модулях. Данная техника была популяризована бандлером Rollup."
  },
  {
    "_id": "64518e2a78a3eb63645a9eac",
    "parentId": "64518e2a78a3eb63645a9eab",
    "content_type": "text",
    "order": 0,
    "content_data": "Tree shaking может существенно уменьшить размер сборки (бандла) за счет удаления из нее кода неиспользуемых модулей. Чем меньше размер сборки, тем выше производительность приложения. Tree shaking реализован в таких сборщиках модулей, как Rollup и Webpack."
  },
  {
    "_id": "64518e2a78a3eb63645a9eaf",
    "parentId": "64518e2a78a3eb63645a9eae",
    "content_type": "text",
    "order": 0,
    "content_data": "Регулярное выражение - это последовательность символов, формирующая поисковый шаблон. Этот шаблон может использоваться для поиска данных в тексте, например, подстроки в строке. Регулярные выражения широко используются многими языками программирования для операций поиска и замены текста. Общий шаблон регулярного выражения выглядит так:"
  },
  {
    "_id": "64518e2a78a3eb63645a9eb0",
    "parentId": "64518e2a78a3eb63645a9eae",
    "content_type": "code",
    "order": 1,
    "content_data": "/шаблон/модификатор"
  },
  {
    "_id": "64518e2a78a3eb63645a9eb1",
    "parentId": "64518e2a78a3eb63645a9eae",
    "content_type": "text",
    "order": 2,
    "content_data": "Пример:"
  },
  {
    "_id": "64518e2a78a3eb63645a9eb2",
    "parentId": "64518e2a78a3eb63645a9eae",
    "content_type": "code",
    "order": 3,
    "content_data": "const regex = /java/i\nconst str = 'JavaScript'\nconsole.log(regex.test(str)) // true"
  },
  {
    "_id": "64518e2a78a3eb63645a9eb3",
    "parentId": "64518e2a78a3eb63645a9eae",
    "content_type": "text",
    "order": 4,
    "content_data": "Также для создания регулярного выражения можно использовать конструктор RegExp:"
  },
  {
    "_id": "64518e2a78a3eb63645a9eb4",
    "parentId": "64518e2a78a3eb63645a9eae",
    "content_type": "code",
    "order": 5,
    "content_data": "const regex = new RegExp('java', 'i')\nconst str = 'JavaScript'\nconsole.log(regex.test(str)) // true"
  },
  {
    "_id": "64518e2a78a3eb63645a9eb8",
    "parentId": "64518e2a78a3eb63645a9eb7",
    "content_type": "text",
    "order": 0,
    "content_data": "В регулярных выражениях используется два основных метода: exec() и test()."
  },
  {
    "_id": "64518e2a78a3eb63645a9eb9",
    "parentId": "64518e2a78a3eb63645a9eb7",
    "content_type": "text",
    "order": 1,
    "content_data": "Метод exec() ищет совпадение с регулярным выражением в переданной ему в качестве аргумента строке. Поведение данного метода зависит от того, имеет ли регулярное выражение флаг g. Если нет, то возвращается первое совпадение. Если флаг g есть, то:"
  },
  {
    "_id": "64518e2a78a3eb63645a9eba",
    "parentId": "64518e2a78a3eb63645a9eb7",
    "content_type": "list",
    "order": 2,
    "content_data": [
      "Вызов exec() возвращает первое совпадение и запоминает позицию после него в свойстве lastIndex.",
      "Следующий такой вызов начинает поиск с позиции lastIndex, возвращает следующее совпадение и запоминает позицию после него в lastIndex.",
      "Если совпадений больше нет, то exec() возвращает null, а для lastIndex устанавливается значение 0."
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9ebb",
    "parentId": "64518e2a78a3eb63645a9eb7",
    "content_type": "code",
    "order": 3,
    "content_data": "const str = 'Java и JavaScript - разные языки программирования'\nconst regex = /Java/g\n\nlet result\nwhile (result = regex.exec(str)) {\n    console.log(\n        `Найдено ${result[0]} на позиции ${result.index}`\n    )\n}\n/*\n    Найдено Java на позиции 0\n    Найдено Java на позиции 7\n*/"
  },
  {
    "_id": "64518e2a78a3eb63645a9ebc",
    "parentId": "64518e2a78a3eb63645a9eb7",
    "content_type": "text",
    "order": 4,
    "content_data": "Метод test() возвращает логическое значение в зависимости от того, найдено ли совпадение в строке:"
  },
  {
    "_id": "64518e2a78a3eb63645a9ebd",
    "parentId": "64518e2a78a3eb63645a9eb7",
    "content_type": "code",
    "order": 5,
    "content_data": "const str = 'Я люблю JavaScript'\n\nconsole.log(\n    /Я люблю/.test(str) // true\n)"
  },
  {
    "_id": "64518e2a78a3eb63645a9ec1",
    "parentId": "64518e2a78a3eb63645a9ec0",
    "content_type": "table",
    "order": 0,
    "content_data": [
      [
        "Флаг",
        "Описание"
      ],
      [
        "g",
        "глобальное сопоставление"
      ],
      [
        "i",
        "игнорирование регистра при сопоставлении"
      ],
      [
        "m",
        "сопоставление по нескольким строкам"
      ]
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9ec2",
    "parentId": "64518e2a78a3eb63645a9ec0",
    "content_type": "code",
    "order": 1,
    "content_data": "const regex = /([а-яё]+)s([а-яё]+)/i\nconst str = 'Иван Иванов'\nconst newStr = str.replace(regex, '$2 $1')\nconsole.log(newStr) // Иванов Иван"
  },
  {
    "_id": "64518e2a78a3eb63645a9ec6",
    "parentId": "64518e2a78a3eb63645a9ec5",
    "content_type": "text",
    "order": 0,
    "content_data": "Специальные символы, используемые в регулярных выражениях, можно разделить на несколько групп."
  },
  {
    "_id": "64518e2a78a3eb63645a9ec7",
    "parentId": "64518e2a78a3eb63645a9ec5",
    "content_type": "text",
    "order": 1,
    "content_data": "Основные символьные классы:"
  },
  {
    "_id": "64518e2a78a3eb63645a9ec8",
    "parentId": "64518e2a78a3eb63645a9ec5",
    "content_type": "table",
    "order": 2,
    "content_data": [
      [
        "Символ",
        "Значение"
      ],
      [
        "\\.",
        "любой символ, за некоторым исключением"
      ],
      [
        "\\d",
        "цифра"
      ],
      [
        "\\D",
        "не цифра"
      ],
      [
        "\\w",
        "символ латиницы и нижнее подчеркивание"
      ],
      [
        "\\W",
        "не символ латиницы и нижнее подчеркивание"
      ],
      [
        "\\s",
        "пробельный символ"
      ],
      [
        "\\S",
        "не пробельный символ"
      ],
      [
        "\\",
        "экранирование, например,\\.-этоточка"
      ]
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9ec9",
    "parentId": "64518e2a78a3eb63645a9ec5",
    "content_type": "text",
    "order": 3,
    "content_data": "Наборысимволов: "
  },
  {
    "_id": "64518e2a78a3eb63645a9eca",
    "parentId": "64518e2a78a3eb63645a9ec5",
    "content_type": "table",
    "order": 4,
    "content_data": [
      [
        "Символ",
        "Значение"
      ],
      [
        "[а-яёА-ЯЁ]",
        "любая буква русского алфавита"
      ],
      [
        "[^а-яёА-ЯЁ]",
        "любойсимвол, кроме букв русского алфавита"
      ]
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9ecb",
    "parentId": "64518e2a78a3eb63645a9ec5",
    "content_type": "text",
    "order": 5,
    "content_data": "Границы: "
  },
  {
    "_id": "64518e2a78a3eb63645a9ecc",
    "parentId": "64518e2a78a3eb63645a9ec5",
    "content_type": "table",
    "order": 6,
    "content_data": [
      [
        "Символ",
        "Значение"
      ],
      [
        "^",
        "началостроки"
      ],
      [
        "$",
        "конецстроки"
      ],
      [
        "\\b",
        "границаслованулевойширины"
      ],
      [
        "\\B",
        "границаслованенулевойширины"
      ]
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9ecd",
    "parentId": "64518e2a78a3eb63645a9ec5",
    "content_type": "text",
    "order": 7,
    "content_data": "Группировка: "
  },
  {
    "_id": "64518e2a78a3eb63645a9ece",
    "parentId": "64518e2a78a3eb63645a9ec5",
    "content_type": "table",
    "order": 8,
    "content_data": [
      [
        "Символ",
        "Значение"
      ],
      [
        "(x)",
        "сопоставляется с x, сопоставление запоминается"
      ],
      [
        "(?: x)",
        "сопоставляется с x, сопоставление не запоминается"
      ]
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9ecf",
    "parentId": "64518e2a78a3eb63645a9ec5",
    "content_type": "text",
    "order": 9,
    "content_data": "Квантификаторы: "
  },
  {
    "_id": "64518e2a78a3eb63645a9ed0",
    "parentId": "64518e2a78a3eb63645a9ec5",
    "content_type": "table",
    "order": 10,
    "content_data": [
      [
        "Символ",
        "Значение"
      ],
      [
        "*",
        "ноль и более символов"
      ],
      [
        "+",
        "один и более символов"
      ],
      [
        "*?и+?",
        "аналогично * и +, но ищется минимальное совпадение"
      ],
      [
        "?",
        "ноль или один символ"
      ],
      [
        "x(?=y)",
        "сопоставляется с x, если за x следует y"
      ],
      [
        "x(?!y)",
        "сопоставляется с x, если за x не следует y"
      ],
      [
        "(?<=y)x",
        "сопоставляется с x, если x предшествует y"
      ],
      [
        "(?!y)x",
        "сопоставляется с x, если x не предшествует y"
      ],
      [
        "x|y",
        "x или y"
      ],
      [
        "x{n}",
        "n-точное количество x"
      ],
      [
        "x{n,}",
        "n-минимальное количество x"
      ],
      [
        "x{n,m}",
        "n-минимальное количество x, m-максимальное (от,до)"
      ]
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9ed4",
    "parentId": "64518e2a78a3eb63645a9ed3",
    "content_type": "text",
    "order": 0,
    "content_data": "Это можно сделать либо с помощью свойства style, либо присвоив элементу соответствующий класс: "
  },
  {
    "_id": "64518e2a78a3eb63645a9ed5",
    "parentId": "64518e2a78a3eb63645a9ed3",
    "content_type": "code",
    "order": 1,
    "content_data": "document\n.querySelector(selector)\n.style.property=value\ndocument\n.querySelector('title')\n.fontSize='2rem'\n\ndocument.querySelector(selector)\n.className='class-name'\ndocument.querySelector(selector)\n.classList.add('class-name')\ndocument.querySelector('button')\n.classList.add('active')"
  },
  {
    "_id": "64518e2a78a3eb63645a9edb",
    "parentId": "64518e2a78a3eb63645a9eda",
    "content_type": "text",
    "order": 0,
    "content_data": "Выражение debugger открывает доступ к любому доступному в конкретном окружении отладочному функционалу, например, к установке контрольных точек(точек останова, брекпойнтов).Если функционал отладки в среде выполнения не доступен, данное выражение не будет иметь никакого эффекта: "
  },
  {
    "_id": "64518e2a78a3eb63645a9edc",
    "parentId": "64518e2a78a3eb63645a9eda",
    "content_type": "code",
    "order": 1,
    "content_data": "const fun=()=>{\n//магия\ndebugger//вэтом месте выполнение функции будет приостановлено\n//магия\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9ee0",
    "parentId": "64518e2a78a3eb63645a9edf",
    "content_type": "text",
    "order": 0,
    "content_data": "Контрольные точки используются для приостановки выполнения функции или другого кода в определенном месте с целью выяснения причин неправильной работы программы. После остановки выполнение функции может быть продолжено."
  },
  {
    "_id": "64518e2a78a3eb63645a9ee4",
    "parentId": "64518e2a78a3eb63645a9ee3",
    "content_type": "text",
    "order": 0,
    "content_data": "Нет, использовать зарезервированные слова в качестве названий переменных, меток, функций или объектов нельзя: "
  },
  {
    "_id": "64518e2a78a3eb63645a9ee5",
    "parentId": "64518e2a78a3eb63645a9ee3",
    "content_type": "code",
    "order": 1,
    "content_data": "const class='Первый раз в первый класс'//SyntaxError: Unexpectedtoken'class'"
  },
  {
    "_id": "64518e2a78a3eb63645a9ee7",
    "parentId": "64518e2a78a3eb63645a9ee6",
    "content_type": "text",
    "order": 0,
    "content_data": "Это можно сделать разными способами. Вот один из них: "
  },
  {
    "_id": "64518e2a78a3eb63645a9ee8",
    "parentId": "64518e2a78a3eb63645a9ee6",
    "content_type": "code",
    "order": 1,
    "content_data": "const getImgSize = src=> {\nconst img = new Image()\n img.src = src\nimg.addEventListener('load',() => console.log(`${img.width}x${img.height}`))//276x110\ndocument.body.append(img)\n}\ngetImgSize('http://www.google.com/ intl/en_ALL/images/logo.gif')"
  },
  {
    "_id": "64518e2a78a3eb63645a9eeb",
    "parentId": "64518e2a78a3eb63645a9eea",
    "content_type": "text",
    "order": 0,
    "content_data": "Для этого можно использовать объект XMLHttpRequest, передав его методу open() третий опциональный аргумент со значением false: "
  },
  {
    "_id": "64518e2a78a3eb63645a9eec",
    "parentId": "64518e2a78a3eb63645a9eea",
    "content_type": "code",
    "order": 1,
    "content_data": "const getUsers = url => {\nconst xhr = new XMLHttpRequest()\nxhr.open('GET',url, false)\nxhr.send()\nconsole.table(xhr.response)\n\nconst response = JSON.parse(xhr.response)\nconst template=`\n<table>\n${response.reduce((html,user) => html += `\n<tr>\n<td>${user.name}</td>\n<td>${user.username}</td>\n<td>${user.email}</td>\n</tr>`,'')}\n<table>\n`\ndocument.body\n.insertAdjacentHTML('beforeend', template)\n}\n\ngetUsers('https://jsonplaceholder.typicode.com/users')"
  },
  {
    "_id": "64518e2a78a3eb63645a9ef0",
    "parentId": "64518e2a78a3eb63645a9eef",
    "content_type": "text",
    "order": 0,
    "content_data": "Для этого можно использовать метод fetch(): "
  },
  {
    "_id": "64518e2a78a3eb63645a9ef1",
    "parentId": "64518e2a78a3eb63645a9eef",
    "content_type": "code",
    "order": 1,
    "content_data": "const getUsers = async url => {\nconst response = await fetch(url)\nconst data = await response.json()\nconsole.table(data)\n\nconst template=`\n<table>\n${data.reduce((html, user) => html += `\n<tr>\n<td>${user.name}</td>\n<td>${user.username}</td>\n<td>${user.email}</td>\n</tr>`,'')}\n<table>\n`\ndocument.body.insertAdjacentHTML('beforeend', template)\n}\n\ngetUsers('https://jsonplaceholder.typicode.com/users')"
  },
  {
    "_id": "64518e2a78a3eb63645a9ef5",
    "parentId": "64518e2a78a3eb63645a9ef4",
    "content_type": "text",
    "order": 0,
    "content_data": "Для этого можно использовать метод toLocaleString(): "
  },
  {
    "_id": "64518e2a78a3eb63645a9ef6",
    "parentId": "64518e2a78a3eb63645a9ef4",
    "content_type": "code",
    "order": 1,
    "content_data": "console.log(\nnewDate().toLocaleString('ru-Ru',{\nweekday: 'long',\nyear: 'numeric',\nmonth: 'long',\nday: 'numeric'\n})\n)//воскресенье, 6сентября2020г."
  },
  {
    "_id": "64518e2a78a3eb63645a9ef9",
    "parentId": "64518e2a78a3eb63645a9ef8",
    "content_type": "text",
    "order": 0,
    "content_data": " Для этого нужно найти максимальные значения свойств scrollWidth, offsetWidth, clientWidth и scrollHeight, offsetHeight, clientHeight объектов document.body и document.documentElement: "
  },
  {
    "_id": "64518e2a78a3eb63645a9efa",
    "parentId": "64518e2a78a3eb63645a9ef8",
    "content_type": "code",
    "order": 1,
    "content_data": "const pageWidth = Math.max(\ndocument.body.scrollWidth, document.documentElement.scrollWidth,\ndocument.body.offsetWidth, document.documentElement.offsetWidth,\ndocument.body.clientWidth, document.documentElement.clientWidth\n)\nconst pageHeight = Math.max(\ndocument.body.scrollHeight, document.documentElement.scrollHeight,\ndocument.body.offsetHeight, document.documentElement.offsetHeight,\ndocument.body.clientHeight, document.documentElement.clientHeight\n)\nconst pageSize = {\nwidth: pageWidth,\nheigth: pageHeight\n}\nconsole.log(pageSize)\n\nconst pageCenter = {\ncenterX: pageWidth/2,\ncenterY: pageHeight/2\n}\nconsole.log(pageCenter)"
  },
  {
    "_id": "64518e2a78a3eb63645a9efd",
    "parentId": "64518e2a78a3eb63645a9efc",
    "content_type": "text",
    "order": 0,
    "content_data": "Тернарный оператор является сокращенным способом записи блока if...else: "
  },
  {
    "_id": "64518e2a78a3eb63645a9efe",
    "parentId": "64518e2a78a3eb63645a9efc",
    "content_type": "code",
    "order": 1,
    "content_data": "let accesAllowed\nconst age = propmt('Сколько вам лет?')\n\n//if...else\nif(age>18){\naccesAllowed = true\n}else{\naccessAllowed = false\n}\n\n//тернарный оператор\n(age>18)\n?accesAllowed = true\n: accessAllowed = false"
  },
  {
    "_id": "64518e2a78a3eb63645a9f02",
    "parentId": "64518e2a78a3eb63645a9f01",
    "content_type": "text",
    "order": 0,
    "content_data": "Да, в этом случае тернарный оператор является альтернативой блока if...else if...else: "
  },
  {
    "_id": "64518e2a78a3eb63645a9f03",
    "parentId": "64518e2a78a3eb63645a9f01",
    "content_type": "code",
    "order": 1,
    "content_data": "let accessAllowed\nconst getAge = () => prompt('Сколько вам лет?')\n\n//это всего лишь пример - не надо так делать\n//if...else if...else\nconst checkAge = (age = getAge () ) => {\nconsole.log(age)\nif(isNaN(age)){\nPromise.resolve(alert('Возраст должен быть числом')).then(accessAllowed = false).then(checkAge)\n}else if(age===null||age===''){\nPromise.resolve(alert('Введите ваш возраст')).then(accessAllowed = false).then(checkAge)\n}else if(age < 0){\nPromise.resolve(alert('Возраст не может быть меньше 0')).then(accessAllowed = false).then(checkAge)\n}else if(age > 100){\nPromise.resolve(alert('Возраст не может быть больше 100')).then(accessAllowed = false).then(checkAge)\n}else if(age < 18){\nPromise.resolve(alert('Извините, вы слишком молоды')).then(accessAllowed = false)\n}else{\nPromise.resolve(alert('Добро пожаловать!')).then(accessAllowed = true)\n}\nconsole.log(accessAllowed)\n}\n\n//тернарный оператор\nconst checkAge = (age = getAge()) => {\nisNaN(age)\n?Promise.resolve(alert('Возраст должен быть числом')).then(accessAllowed = false).then(checkAge)\n: (age===null||age==='')\n?Promise.resolve(alert('Введите ваш возраст')).then(accessAllowed = false).then(checkAge)\n: (age < 0)\n?Promise.resolve(alert('Возраст не может быть меньше 0')).then(accessAllowed = false).then(checkAge)\n: (age > 100)\n?Promise.resolve(alert('Возраст не может быть больше 100')).then(accessAllowed = false).then(checkAge)\n: (age<18)\n?Promise.resolve(alert('Извините, вы слишком молоды')).then(accessAllowed = false)\n: Promise.resolve(alert('Добро пожаловать!')).then(accessAllowed = true)\nconsole.log(accessAllowed)\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9f07",
    "parentId": "64518e2a78a3eb63645a9f06",
    "content_type": "text",
    "order": 0,
    "content_data": "Это можно сделать несколькими способами."
  },
  {
    "_id": "64518e2a78a3eb63645a9f08",
    "parentId": "64518e2a78a3eb63645a9f06",
    "content_type": "text",
    "order": 1,
    "content_data": "Разместить тег script перед закрывающим тегом body или добавить ему атрибут defer: "
  },
  {
    "_id": "64518e2a78a3eb63645a9f09",
    "parentId": "64518e2a78a3eb63645a9f06",
    "content_type": "code",
    "order": 2,
    "content_data": "<body>\n...\n<script src=\"script.js\"></script>\n</body>\n\n\n<head>\n    ...\n    <script src=\"script.js\" defer></script>\n</head>"
  },
  {
    "_id": "64518e2a78a3eb63645a9f0a",
    "parentId": "64518e2a78a3eb63645a9f06",
    "content_type": "text",
    "order": 3,
    "content_data": "Если ваш скрипт - это модуль, то вместо атрибута defer, нужно указать атрибут contentType со значением module:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f0b",
    "parentId": "64518e2a78a3eb63645a9f06",
    "content_type": "code",
    "order": 4,
    "content_data": "<script src=\"script.js\" contentType=\"module\"></script>"
  },
  {
    "_id": "64518e2a78a3eb63645a9f0c",
    "parentId": "64518e2a78a3eb63645a9f06",
    "content_type": "text",
    "order": 5,
    "content_data": "Добавить тегу body атрибут onload:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f0d",
    "parentId": "64518e2a78a3eb63645a9f06",
    "content_type": "code",
    "order": 6,
    "content_data": "<body onload=\"script()\"></body>"
  },
  {
    "_id": "64518e2a78a3eb63645a9f0e",
    "parentId": "64518e2a78a3eb63645a9f06",
    "content_type": "text",
    "order": 7,
    "content_data": "Добавить код в качестве обработчика события load объекта window:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f0f",
    "parentId": "64518e2a78a3eb63645a9f06",
    "content_type": "code",
    "order": 8,
    "content_data": "window.onload = () => console.log('Страница полностью загружена')\n\n// или\nwindow.addEventListener('load', () => console.log('Страница полностью загружена'))"
  },
  {
    "_id": "64518e2a78a3eb63645a9f10",
    "parentId": "64518e2a78a3eb63645a9f06",
    "content_type": "text",
    "order": 9,
    "content_data": "Сделать тоже самое для document.body:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f11",
    "parentId": "64518e2a78a3eb63645a9f06",
    "content_type": "code",
    "order": 10,
    "content_data": "document.body.onload = () => console.log('Страница полностью загружена')"
  },
  {
    "_id": "64518e2a78a3eb63645a9f13",
    "parentId": "64518e2a78a3eb63645a9f12",
    "content_type": "text",
    "order": 0,
    "content_data": "Свойство __proto__ (внутреннее скрытое свойство [[ProtocontentType]]) - это объект, от которого экземпляр наследует поля и методы. А protocontentType - это объект, который используется для создания __proto__ при создании экземпляра с помощью ключевого слова new:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f14",
    "parentId": "64518e2a78a3eb63645a9f12",
    "content_type": "code",
    "order": 1,
    "content_data": "class Person {\n    constructor(firstName, secondName) {\n        this.firstName = firstName\n        this.secondName = secondName\n    }\n    getFullName() {\n        return `${this.firstName} ${this.secondName}`\n    }\n\n}\n\nconst user = new Person('Иван', 'Иванов')\nconsole.log(user.getFullName()) // Иван Иванов\nconsole.log(user.__proto__.getFullName === Person.protocontentType.getFullName) // true\nconsole.log(Person.protocontentType) // {constructor: ƒ, getFullName: ƒ}\nconsole.log(user.protocontentType === undefined) // true"
  },
  {
    "_id": "64518e2a78a3eb63645a9f18",
    "parentId": "64518e2a78a3eb63645a9f17",
    "content_type": "text",
    "order": 0,
    "content_data": "Одним из случаев обязательного использования точки запятой является использование IIFE (Immediately Invoked Fuction Expression - немедленно вызываемого функционального выражения):"
  },
  {
    "_id": "64518e2a78a3eb63645a9f19",
    "parentId": "64518e2a78a3eb63645a9f17",
    "content_type": "text",
    "order": 1,
    "content_data": "Например, следующий код:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f1a",
    "parentId": "64518e2a78a3eb63645a9f17",
    "content_type": "code",
    "order": 2,
    "content_data": "try {\n    const x = 'Быть'\n\n    (() => {\n        console.log(x)\n    })()\n} catch {\n    console.log('Не быть')\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9f1b",
    "parentId": "64518e2a78a3eb63645a9f17",
    "content_type": "text",
    "order": 3,
    "content_data": "Будет интерпретирован так:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f1c",
    "parentId": "64518e2a78a3eb63645a9f17",
    "content_type": "code",
    "order": 4,
    "content_data": "try {\n    const x = 'Быть'(() => {\n        console.log(x)\n    })()\n} catch {\n    console.log('Не быть')\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9f1d",
    "parentId": "64518e2a78a3eb63645a9f17",
    "content_type": "text",
    "order": 5,
    "content_data": "Поэтому в блоке try мы получаем ошибку contentTypeError: \"Быть\" is not a function, управление передается блоку catch, и в консоль выводится \"Не быть\"."
  },
  {
    "_id": "64518e2a78a3eb63645a9f1e",
    "parentId": "64518e2a78a3eb63645a9f17",
    "content_type": "text",
    "order": 6,
    "content_data": "Для того, чтобы код работал, как ожидается, он должен выглядеть так:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f1f",
    "parentId": "64518e2a78a3eb63645a9f17",
    "content_type": "code",
    "order": 7,
    "content_data": "try {\n    // точку с запятой нужно поставить либо здесь\n    const x = 'Быть';\n    // либо здесь\n    ;(() => {\n        console.log(x)\n    })()\n} catch {\n    console.log('Не быть')\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9f20",
    "parentId": "64518e2a78a3eb63645a9f17",
    "content_type": "text",
    "order": 8,
    "content_data": "Также не забывайте про случаи автоматического расставления точек с запятой."
  },
  {
    "_id": "64518e2a78a3eb63645a9f22",
    "parentId": "64518e2a78a3eb63645a9f21",
    "content_type": "text",
    "order": 0,
    "content_data": "Данный метод, как следует из его названия, служит для \"замораживания\" объекта. Замороженный объект является неизменяемым (иммутабельным). Это означает, что в такой объект нельзя добавлять новые свойства, удалять или изменять существующие. Также этот метод устанавливает configurable: false и writable: false для существующих свойств. Метод возвращает замороженный объект."
  },
  {
    "_id": "64518e2a78a3eb63645a9f23",
    "parentId": "64518e2a78a3eb63645a9f21",
    "content_type": "code",
    "order": 1,
    "content_data": "'use strict'\nconst obj = {\n    mission: 'possible'\n}\n\nObject.freeze(obj)\nobj.mission = 'impossible' // contentTypeError: Cannot assign to read only property 'mission' of object '#<Object>'\n\ndelete obj.mission // contentTypeError: Cannot delete property 'mission' of #<Object>"
  },
  {
    "_id": "64518e2a78a3eb63645a9f24",
    "parentId": "64518e2a78a3eb63645a9f21",
    "content_type": "text",
    "order": 2,
    "content_data": "Обратите внимание, что в нестрогом режиме исключение не выбрасывается, код просто не выполняется."
  },
  {
    "_id": "64518e2a78a3eb63645a9f28",
    "parentId": "64518e2a78a3eb63645a9f27",
    "content_type": "text",
    "order": 0,
    "content_data": "Парадигма объектно-ориентированного программирования гласит, что интерфейс, содержащий определенное количество элементов, должен быть иммутабельным, т.е. должна быть исключена возможность его расширения, модификации или использования элементов за пределами текущего контекста. Данный метод является алиасом ключевого слова final в некоторых других языках программирования."
  },
  {
    "_id": "64518e2a78a3eb63645a9f2c",
    "parentId": "64518e2a78a3eb63645a9f2b",
    "content_type": "text",
    "order": 0,
    "content_data": "Одним из способов это сделать является следующий:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f2d",
    "parentId": "64518e2a78a3eb63645a9f2b",
    "content_type": "code",
    "order": 1,
    "content_data": "const capitilize = str => str.replace(\n    /[а-яё]S+/gi,\n    txt => txt[0].toUpperCase() + txt.slice(1).toLowerCase()\n)\n\nconsole.log(capitilize('аПтека, улИца, фонАрь')) // Аптека, Улица, Фонарь"
  },
  {
    "_id": "64518e2a78a3eb63645a9f2f",
    "parentId": "64518e2a78a3eb63645a9f2e",
    "content_type": "text",
    "order": 0,
    "content_data": "Для этого можно использовать тег noscript. Код внутри этого тега будет выполнен только в случае, если на странице отключен JavaScript:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f30",
    "parentId": "64518e2a78a3eb63645a9f2e",
    "content_type": "code",
    "order": 1,
    "content_data": "console.log('JavaScript включен')\n\n<noscript>\n    <p>Включите JavaScript, или ничего не получится</p>\n</noscript>"
  },
  {
    "_id": "64518e2a78a3eb63645a9f31",
    "parentId": "64518e2a78a3eb63645a9f2e",
    "content_type": "text",
    "order": 2,
    "content_data": "Для того, чтобы отключить JavaScript в Chrome, заходим в настройки -> раздел \"Конфиденциальность и безопасность\" -> Настройки сайтов -> раздел \"Контент\" -> JavaScript."
  },
  {
    "_id": "64518e2a78a3eb63645a9f34",
    "parentId": "64518e2a78a3eb63645a9f33",
    "content_type": "text",
    "order": 0,
    "content_data": "Операторы служат для работы со значениями или операндами. JavaScript поддерживает следующие операторы:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f35",
    "parentId": "64518e2a78a3eb63645a9f33",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "Арифметические: + (сложение, приведение к числу, конкатенация), - (вычитание), * (умножение), / (деление), % (деление по модулю, с остатком), ++ (инкремент), -- (декремент), ** (возведение в степень)",
      "операторы сравнения: == (абстрактное, нестрогое равенство), != (абстрактное неравенство), === (строгое равенство, проверка на идентичность), !== (строгое неравенство), >, >=, <, <=",
      "логические: && (и), || (или), ! (не) (!! (двойное отрицание) не является отдельным оператором)",
      "операторы присваивания: =, +=, -=, *=, /=, %=",
      "тернарный: ?...: (if...else)",
      "оператор contentTypeof: определяет тип операнда",
      "побитовые: & (и), | (или), ^ (исключающее или), ~ (не), << (левый сдвиг), >> (правый сдвиг), >>> (правый сдвиг с заполнением нулями)",
      "новые: ?. (опциональная цепочка), ?? (слияние с null)"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9f36",
    "parentId": "64518e2a78a3eb63645a9f33",
    "content_type": "code",
    "order": 2,
    "content_data": "// опциональная цепочка\nconst obj = {\n    foo: {\n        baz: {\n            qux: 'bar'\n        }\n    }\n}\n\n// тогда\nconsole.log(obj.foo.bar.baz.qux) // contentTypeError: Cannot read property 'baz' of undefined\n\nif (\n    obj.foo !== undefined &&\n    obj.foo.bar !== undefined &&\n    obj.foo.bar.baz !== undefined\n) {\n    console.log(obj.foo.bar.baz.qux) // ошибки не будет\n}\n\n// сейчас\nconsole.log(obj?.foo?.bar?.baz?.qux) // undefined\n\n// слияние с null\nconsole.log(\n    0 || 'default null', // 'default null'\n    0 ?? 'default null', // 0\n    '' || 'default string', // default string\n    '' ?? 'default string', // ''\n)"
  },
  {
    "_id": "64518e2a78a3eb63645a9f3f",
    "parentId": "64518e2a78a3eb63645a9f3e",
    "content_type": "text",
    "order": 0,
    "content_data": "Оператор rest является альтернативой объекта arguments и возвращает массив из переданных функции аргументов:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f40",
    "parentId": "64518e2a78a3eb63645a9f3e",
    "content_type": "code",
    "order": 1,
    "content_data": "const sum = (...rest) => rest.reduce((acc, cur) => acc + cur)\n\nconsole.log(sum(1, 2, 3)) // 6"
  },
  {
    "_id": "64518e2a78a3eb63645a9f41",
    "parentId": "64518e2a78a3eb63645a9f3e",
    "content_type": "text",
    "order": 2,
    "content_data": "Обратите внимание, что оператор rest должен передаваться в качестве последнего аргумента:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f42",
    "parentId": "64518e2a78a3eb63645a9f3e",
    "content_type": "code",
    "order": 3,
    "content_data": "const fun = (x, ...rest, y) => console.log(rest) // SyntaxError: Rest parameter must be last formal parameter"
  },
  {
    "_id": "64518e2a78a3eb63645a9f46",
    "parentId": "64518e2a78a3eb63645a9f45",
    "content_type": "text",
    "order": 0,
    "content_data": "Оператор spread используется для расширения (распаковки, разворачивания) итерируемых сущностей (массивов, строк). Распаковка означает преобразование, например, массива из чисел в набор простых значений:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f47",
    "parentId": "64518e2a78a3eb63645a9f45",
    "content_type": "code",
    "order": 1,
    "content_data": "const sum = (x, y, z) => x + y + z\n\nconst nums = [1, 2, 3]\n\nconsole.log(sum(...nums)) // 6"
  },
  {
    "_id": "64518e2a78a3eb63645a9f4b",
    "parentId": "64518e2a78a3eb63645a9f4a",
    "content_type": "text",
    "order": 0,
    "content_data": "Для того, чтобы определить, заморожен ли объект, т.е. является ли он неизменяемым (иммутабельным), используется метод isFrozen():"
  },
  {
    "_id": "64518e2a78a3eb63645a9f4c",
    "parentId": "64518e2a78a3eb63645a9f4a",
    "content_type": "code",
    "order": 1,
    "content_data": "const obj = {\n    prop: 'Добро пожаловать в мир JavaScript!'\n}\n\nObject.freeze(obj)\n\nconsole.log(Object.isFrozen(obj)) // true"
  },
  {
    "_id": "64518e2a78a3eb63645a9f4f",
    "parentId": "64518e2a78a3eb63645a9f4e",
    "content_type": "text",
    "order": 0,
    "content_data": "Для этого можно использовать метод is():"
  },
  {
    "_id": "64518e2a78a3eb63645a9f50",
    "parentId": "64518e2a78a3eb63645a9f4e",
    "content_type": "code",
    "order": 1,
    "content_data": "Object.is('двое из ларца', 'двое из ларца') // true\nObject.is(0.1 + 0.2, 0.3) // false\nObject.is(window, window) // true\nObject.is(+0, -0) // false\n\nconst objA = {}\nconst objB = objA\nObject.is(objA, objB) // true\nObject.is({}, {}) // false"
  },
  {
    "_id": "64518e2a78a3eb63645a9f51",
    "parentId": "64518e2a78a3eb63645a9f4e",
    "content_type": "text",
    "order": 2,
    "content_data": "Значения являются равными, если:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f52",
    "parentId": "64518e2a78a3eb63645a9f4e",
    "content_type": "list",
    "order": 3,
    "content_data": [
      "оба являются undefined",
      "оба являются null",
      "оба являются true или false",
      "оба являются строками одинаковой длины с одинаковыми символами",
      "оба ссылаются на один объект",
      "оба являются числами, +0, -0 или NaN"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9f56",
    "parentId": "64518e2a78a3eb63645a9f55",
    "content_type": "text",
    "order": 0,
    "content_data": "Одним из самых надежных способов это сделать является использование метода assign():"
  },
  {
    "_id": "64518e2a78a3eb63645a9f57",
    "parentId": "64518e2a78a3eb63645a9f55",
    "content_type": "code",
    "order": 1,
    "content_data": "const objA = {a: 1, b: 2}\nconst objB = Object.assign(objA)\n\nconsole.log(objB) // {a: 1, b: 2}\n\nconsole.log(objA === objB) // true"
  },
  {
    "_id": "64518e2a78a3eb63645a9f58",
    "parentId": "64518e2a78a3eb63645a9f55",
    "content_type": "text",
    "order": 2,
    "content_data": "Также данный метод позволяет объединять объекты, исключая дубликаты:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f59",
    "parentId": "64518e2a78a3eb63645a9f55",
    "content_type": "code",
    "order": 3,
    "content_data": "const objA = {a: 1, b: 2}\nconst objB = {b: 2, c: 3}\n\nconst objC = Object.assign(objA, objB)\nconsole.log(objC) {a: 1, b: 2, c: 3}"
  },
  {
    "_id": "64518e2a78a3eb63645a9f5a",
    "parentId": "64518e2a78a3eb63645a9f55",
    "content_type": "text",
    "order": 4,
    "content_data": "Для копирования простых объектов можно использовать связку JSON.parse-JSON.stringify:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f5b",
    "parentId": "64518e2a78a3eb63645a9f55",
    "content_type": "code",
    "order": 5,
    "content_data": "const objA = {a: 1, b: 2}\n\nconst objB = JSON.parse(JSON.stringify(objA))\n\nconsole.log(objB) // {a: 1, b: 2}"
  },
  {
    "_id": "64518e2a78a3eb63645a9f5f",
    "parentId": "64518e2a78a3eb63645a9f5e",
    "content_type": "text",
    "order": 0,
    "content_data": "Объект Proxy «оборачивается» вокруг другого объекта и может перехватывать (и, при желании, самостоятельно обрабатывать) разные действия с ним, например чтение/запись свойств и другие."
  },
  {
    "_id": "64518e2a78a3eb63645a9f60",
    "parentId": "64518e2a78a3eb63645a9f5e",
    "content_type": "code",
    "order": 1,
    "content_data": "const handler = {\n    get: (obj, prop) => prop in obj\n        ? obj[prop]\n        : 0\n}\n\n// new Proxy(цель, обработчик)\nconst p = new Proxy({}, handler)\n\np.a = 1\np.b = true\n\nconsole.log(p.a, p.b) // 1 true\nconsole.log( 'c' in p, p.c) // false 0"
  },
  {
    "_id": "64518e2a78a3eb63645a9f62",
    "parentId": "64518e2a78a3eb63645a9f61",
    "content_type": "text",
    "order": 0,
    "content_data": "Данный метод \"запечатывает\" объект, запрещая добавлять/удалять свойства. Он также устанавливает configurable: false для всех существующих свойств. Однако, значения свойств такого объекта можно менять. Для проверки, является ли объект запечатанным, используется метод isSealed()."
  },
  {
    "_id": "64518e2a78a3eb63645a9f63",
    "parentId": "64518e2a78a3eb63645a9f61",
    "content_type": "code",
    "order": 1,
    "content_data": "'use strict'\nconst obj = {\n    prop: 'Добро пожаловать в мир JavaScript!'\n}\n\nObject.seal(obj)\n\nobj.prop = 'Оставь надежду, всяк сюда входящий'\nconsole.log(Object.isSealed(obj)) // true\ndelete obj.prop // contentTypeError: Cannot delete property 'prop' of #<Object>\nconsole.log(obj.prop) // Оставь надежду, всяк сюда входящий"
  },
  {
    "_id": "64518e2a78a3eb63645a9f64",
    "parentId": "64518e2a78a3eb63645a9f61",
    "content_type": "text",
    "order": 2,
    "content_data": "Обратите внимание, что в нестрогом режиме попытка удаления свойства запечатанного объекта тихо завершится ничем."
  },
  {
    "_id": "64518e2a78a3eb63645a9f68",
    "parentId": "64518e2a78a3eb63645a9f67",
    "content_type": "text",
    "order": 0,
    "content_data": "Метод Object.seal() в отличие от метода Object.freeze() позволяет изменять существующие свойства объекта."
  },
  {
    "_id": "64518e2a78a3eb63645a9f69",
    "parentId": "64518e2a78a3eb63645a9f67",
    "content_type": "code",
    "order": 1,
    "content_data": "'use strict'\nconst objA = {\n    prop: 'Быть'\n}\nObject.freeze(objA)\nobjA.prop = 'Не быть' // contentTypeError: Cannot assign to read only property 'prop' of object '#<Object>'\n\nconst objB = {\n    prop: 'Не быть'\n}\nObject.seal(objB)\nobjB.prop = 'Быть'\nconsole.log(objB.prop) // Быть"
  },
  {
    "_id": "64518e2a78a3eb63645a9f6b",
    "parentId": "64518e2a78a3eb63645a9f6a",
    "content_type": "text",
    "order": 0,
    "content_data": "Метод Object.entries() возвращает массив из перечисляемых пар ключ/значение объекта в виде подмассивов в том же порядке, что и цикл for...in:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f6c",
    "parentId": "64518e2a78a3eb63645a9f6a",
    "content_type": "code",
    "order": 1,
    "content_data": "const obj = {\n    x: 1,\n    y: 2\n}\n\nconsole.log(Object.entries(obj)) // [[\"x\", 1], [\"y\", 2]]\n\nfor (let [key, value] of Object.entries(obj)) {\n    console.log(`${key}: ${value}`) // x: 1 y: 2\n}"
  },
  {
    "_id": "64518e2a78a3eb63645a9f70",
    "parentId": "64518e2a78a3eb63645a9f6f",
    "content_type": "text",
    "order": 0,
    "content_data": "Метод Object.keys() возвращает ключи объекта, метод Object.values() - значения его свойств, а Object.entries() массив из пар ключ/значение:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f71",
    "parentId": "64518e2a78a3eb63645a9f6f",
    "content_type": "code",
    "order": 1,
    "content_data": "const user = {\n    name: 'Ванька',\n    age: 30\n}\n\nconsole.log(Object.keys(user)) // [\"name\", \"age\"]\nconsole.log(Object.values(user)) // [\"Ванька\", 30]\nconsole.log(Object.entries(user)) // [[\"name\", \"Ванька\"], [\"age\", 30]]"
  },
  {
    "_id": "64518e2a78a3eb63645a9f77",
    "parentId": "64518e2a78a3eb63645a9f76",
    "content_type": "text",
    "order": 0,
    "content_data": "Для этого можно использовать метод Object.create():"
  },
  {
    "_id": "64518e2a78a3eb63645a9f78",
    "parentId": "64518e2a78a3eb63645a9f76",
    "content_type": "code",
    "order": 1,
    "content_data": "const firstUser = {\n    name: 'Ванька',\n    sayHi() {\n        console.log(`Привет, меня зовут ${this.name}!`)\n    }\n}\n\nconst secondUser = Object.create(firstUser)\n\nsecondUser.name = 'Петька'\nsecondUser.sayHi() // Привет, меня зовут Петька!"
  },
  {
    "_id": "64518e2a78a3eb63645a9f7c",
    "parentId": "64518e2a78a3eb63645a9f7b",
    "content_type": "text",
    "order": 0,
    "content_data": "WeakSet используется для хранения коллекции объектов со слабыми ссылками. Другими словами, он служит дополнительным хранилищем объектов, используемых другим кодом. Такие объекты автоматически удаляются сборщиком мусора, когда становятся недостижимыми (неиспользуемыми), т.е. когда от объекта остается только ключ в WeakSet."
  },
  {
    "_id": "64518e2a78a3eb63645a9f7d",
    "parentId": "64518e2a78a3eb63645a9f7b",
    "content_type": "code",
    "order": 1,
    "content_data": "const ws = new WeakSet()\nlet user = {}\n\nws.add(user)\nconsole.log(ws.has(user)) // true\n\nuser = null\nconsole.log(ws.has(user)) // false, структура была очищена автоматически"
  },
  {
    "_id": "64518e2a78a3eb63645a9f81",
    "parentId": "64518e2a78a3eb63645a9f80",
    "content_type": "text",
    "order": 0,
    "content_data": "Их основным отличием является то, что объекты, хранящиеся в WeakSet, имеют слабые ссылки, т.е. автоматически удаляются, как только становятся недостижимыми. Другие отличия состоят в следующем:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f82",
    "parentId": "64518e2a78a3eb63645a9f80",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "В Set могут храниться любые значения, а в WeakSet - только объекты",
      "WeakSet не имеет свойства size",
      "WeakSet не имеет методов clear(), keys(), values(), forEach()",
      "WeakSet не является итерируемой сущностью"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9f86",
    "parentId": "64518e2a78a3eb63645a9f85",
    "content_type": "text",
    "order": 0,
    "content_data": "WeakSet обладает следующими методами:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f87",
    "parentId": "64518e2a78a3eb63645a9f85",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "add(): добавляет объект в коллекцию",
      "delete(): удаляет объект из коллекции",
      "has(): определяет наличие объекта в коллекции",
      "length(): возвращает длину коллекции"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9f88",
    "parentId": "64518e2a78a3eb63645a9f85",
    "content_type": "code",
    "order": 2,
    "content_data": "const ws = new WeakSet()\nconst objA = {}\nconst objB = {}\n\nws.add(objA)\nws.add(objB)\nconsole.log(ws.has(objA)) // true\nconsole.log(ws.lenghth()) // 2\nws.delete(objA)\nconsole.log(ws.has(objA)) // false"
  },
  {
    "_id": "64518e2a78a3eb63645a9f8c",
    "parentId": "64518e2a78a3eb63645a9f8b",
    "content_type": "text",
    "order": 0,
    "content_data": "WeakMap используется для хранения пар ключ/значение, в которых ключи имеют слабые ссылки. Другими словами, он служит дополнительным хранилищем ключей, используемых другим кодом. Такие ключи автоматически удаляются сборщиком мусора, когда становятся недостижимыми (неиспользуемыми), т.е. когда от них остается только ключ в WeakMap."
  },
  {
    "_id": "64518e2a78a3eb63645a9f8d",
    "parentId": "64518e2a78a3eb63645a9f8b",
    "content_type": "code",
    "order": 1,
    "content_data": "const wm = new WeakMap()\nlet user = {}\nwm.set(user, 'user')\nconsole.log(wm.has(user)) // true\nuser = null\nconsole.log(wm.has(user)) // false, структура была очищена автоматически"
  },
  {
    "_id": "64518e2a78a3eb63645a9f91",
    "parentId": "64518e2a78a3eb63645a9f90",
    "content_type": "text",
    "order": 0,
    "content_data": "Их основным отличием является то, что ключи, хранящиеся в WeakMap, имеют слабые ссылки, т.е. автоматически удаляются как только становятся недостижимыми. Другие отличия состоят в следующем:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f92",
    "parentId": "64518e2a78a3eb63645a9f90",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "В Map в качестве ключей могут использоваться любые значения, а в WeakMap - только объекты",
      "WeakMap не имеет свойства size",
      "WeakMap не имеет методов clear(), keys(), values(), entries(), forEach()",
      "WeakMap не является итерируемой сущностью"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9f96",
    "parentId": "64518e2a78a3eb63645a9f95",
    "content_type": "text",
    "order": 0,
    "content_data": "WeakMap обладает следующими методами:"
  },
  {
    "_id": "64518e2a78a3eb63645a9f97",
    "parentId": "64518e2a78a3eb63645a9f95",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "set(): добавляет пару ключ/значение в объект",
      "delete(): удаляет значение по ключу",
      "has(): определяет наличие значения по ключу",
      "get(): возвращает значение по ключу"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9f98",
    "parentId": "64518e2a78a3eb63645a9f95",
    "content_type": "code",
    "order": 2,
    "content_data": "const wm = new WeakMap()\nconst firstUser = {}\nconst secondUser = {}\n\nwm.set(firstUser, 'Ванька')\nwm.set(secondUser, 'Петька')\nconsole.log(wm.has(firstUser)) // true\nconsole.log(wm.get(firstUser)) // Ванька\nwm.delete(secondUser)\nconsole.log(wm.has(secondUser)) // false"
  },
  {
    "_id": "64518e2a78a3eb63645a9f9c",
    "parentId": "64518e2a78a3eb63645a9f9b",
    "content_type": "text",
    "order": 0,
    "content_data": "Для этого можно использовать метод encodeURI(). Данный метод преобразует все специальные символы, кроме , / ? : @ = + $ #"
  },
  {
    "_id": "64518e2a78a3eb63645a9f9d",
    "parentId": "64518e2a78a3eb63645a9f9b",
    "content_type": "code",
    "order": 1,
    "content_data": "const url = 'https://ru.wikipedia.org/wiki/Лермонтов,_Михаил_Юрьевич'\nconst encoded = encodeURI(url)\nconsole.log(encoded) // https://ru.wikipedia.org/wiki/%D0%9B%D0..."
  },
  {
    "_id": "64518e2a78a3eb63645a9fa1",
    "parentId": "64518e2a78a3eb63645a9fa0",
    "content_type": "text",
    "order": 0,
    "content_data": "Для этого можно использовать метод decodeURI():"
  },
  {
    "_id": "64518e2a78a3eb63645a9fa2",
    "parentId": "64518e2a78a3eb63645a9fa0",
    "content_type": "code",
    "order": 1,
    "content_data": "const url = 'https://ru.wikipedia.org/wiki/%D0%9B%D0...'\nconst decoded = decodeURI(url)\nconsole.log(decoded) // https://ru.wikipedia.org/wiki/Лермонтов,_Михаил_Юрьевич"
  },
  {
    "_id": "64518e2a78a3eb63645a9fa6",
    "parentId": "64518e2a78a3eb63645a9fa5",
    "content_type": "text",
    "order": 0,
    "content_data": "Для этого можно использовать глобальный метод print(). Данный метод открывает специальное диалоговое окно с настройками печати:"
  },
  {
    "_id": "64518e2a78a3eb63645a9fa7",
    "parentId": "64518e2a78a3eb63645a9fa5",
    "content_type": "code",
    "order": 1,
    "content_data": "<button>Печать</button>\n\ndocument.querySelector('button')\n    .addEventListener('click', () => print())"
  },
  {
    "_id": "64518e2a78a3eb63645a9faa",
    "parentId": "64518e2a78a3eb63645a9fa9",
    "content_type": "text",
    "order": 0,
    "content_data": "Анонимная функция - это функция без названия. Такие функции часто присваиваются переменным, а также используются в качестве колбэков:"
  },
  {
    "_id": "64518e2a78a3eb63645a9fab",
    "parentId": "64518e2a78a3eb63645a9fa9",
    "content_type": "code",
    "order": 1,
    "content_data": "const sayHi = function () {\n    console.log('Привет')\n}\nsayHi() // Привет\n// или\nconst sayBye = () => console.log('Пока')\nsayBye() // Пока\n\nwindow.addEventListener('click', function () {\n    console.log('Не буди лихо, пока оно тихо')\n})\n// или\nwindow.addEventListener('contextmenu', e => {\n    e.preventDefault()\n    console.log('Контекстное меню - детям не игрушка')\n})"
  },
  {
    "_id": "64518e2a78a3eb63645a9faf",
    "parentId": "64518e2a78a3eb63645a9fae",
    "content_type": "text",
    "order": 0,
    "content_data": "Локальные переменные имеют приоритет над одноименными глобальными переменными:"
  },
  {
    "_id": "64518e2a78a3eb63645a9fb0",
    "parentId": "64518e2a78a3eb63645a9fae",
    "content_type": "code",
    "order": 1,
    "content_data": "let question = 'Не быть'\n\nfunction toBe () {\n    question = 'Быть'\n    console.log(question)\n}\ntoBe() // Быть"
  },
  {
    "_id": "64518e2a78a3eb63645a9fb4",
    "parentId": "64518e2a78a3eb63645a9fb3",
    "content_type": "text",
    "order": 0,
    "content_data": "Аксессоры или вычисляемые свойства - это геттеры и сеттеры. Геттеры используются для получения значений свойств объекта, а сеттеры - для их установки:"
  },
  {
    "_id": "64518e2a78a3eb63645a9fb5",
    "parentId": "64518e2a78a3eb63645a9fb3",
    "content_type": "code",
    "order": 1,
    "content_data": "class User {\n    constructor (name, age) {\n        this.name = name\n        this.age = age\n    }\n\n    #access = false\n\n    get access () {\n        return this.#access\n    }\n\n    set access (bool) {\n        this.#access = bool\n    }\n}\n\nconst user = new User('Ванька', 30)\nconsole.log(user.#access) // SyntaxError: Private field '#access' must be declared in an enclosing class\n\nconsole.log(user.access) // false\nuser.access = true\nconsole.log(user.access) // true"
  },
  {
    "_id": "64518e2a78a3eb63645a9fb6",
    "parentId": "64518e2a78a3eb63645a9fb3",
    "content_type": "text",
    "order": 2,
    "content_data": "Геттеры и сеттеры - это свойства, а методы - функции:"
  },
  {
    "_id": "64518e2a78a3eb63645a9fb7",
    "parentId": "64518e2a78a3eb63645a9fb3",
    "content_type": "code",
    "order": 3,
    "content_data": "class User {\n    constructor (name, age) {\n        this.name = name\n        this.age = age\n    }\n\n    #access = false\n\n    getAccess () {\n        return this.#access\n    }\n\n    setAccess(bool) {\n        this.#access = bool\n    }\n}\n\nconst user = new User('Ванька', 30)\nconsole.log(user.#access) // SyntaxError: Private field '#access' must be declared in an enclosing class\n\nconsole.log(user.getAccess()) // false\nuser.setAccess(true)\nconsole.log(user.getAccess()) // true"
  },
  {
    "_id": "64518e2a78a3eb63645a9fba",
    "parentId": "64518e2a78a3eb63645a9fb9",
    "content_type": "text",
    "order": 0,
    "content_data": "Для этого можно использовать метод Object.defineProperty(). Данный метод позволяет добавлять новые свойства к объекту и модифицировать существующие, а также изменять настройки доступа к объекту:"
  },
  {
    "_id": "64518e2a78a3eb63645a9fbb",
    "parentId": "64518e2a78a3eb63645a9fb9",
    "content_type": "code",
    "order": 1,
    "content_data": "'use strict'\nconst obj = {}\n\nObject.defineProperty(obj, 'prop', {\n    value: 1,\n    writable: false\n})\n\nconsole.log(obj.prop) // 1\nobj.prop = 2 // contentTypeError: Cannot assign to read only property 'prop' of object '#<Object>'"
  },
  {
    "_id": "64518e2a78a3eb63645a9fbc",
    "parentId": "64518e2a78a3eb63645a9fb9",
    "content_type": "text",
    "order": 2,
    "content_data": "В нестрогом режиме попытка изменить свойство только для чтения тихо завершится ничем."
  },
  {
    "_id": "64518e2a78a3eb63645a9fc0",
    "parentId": "64518e2a78a3eb63645a9fbf",
    "content_type": "text",
    "order": 0,
    "content_data": "Основными особенностями геттеров и сеттеров является следующее:"
  },
  {
    "_id": "64518e2a78a3eb63645a9fc1",
    "parentId": "64518e2a78a3eb63645a9fbf",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "Они имеют более простой по сравнению с методами синтаксис",
      "Используются для определения вычисляемых свойств - аксессоров",
      "Позволяют обеспечить одинаковые отношения между свойствами и методами",
      "Могут обеспечивать более высокое качество данных",
      "Позволяют выполнять задачи за сценой, когда речь идет об инкапсуляции"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9fc4",
    "parentId": "64518e2a78a3eb63645a9fc3",
    "content_type": "text",
    "order": 0,
    "content_data": "Вполне:"
  },
  {
    "_id": "64518e2a78a3eb63645a9fc5",
    "parentId": "64518e2a78a3eb63645a9fc3",
    "content_type": "code",
    "order": 1,
    "content_data": "const obj = {counter: 0}\n\nObject.defineProperty(obj, 'increment', {\n    get() {return ++this.counter}\n})\nObject.defineProperty(obj, 'decrement', {\n    get() {return --this.counter}\n})\n\nObject.defineProperty(obj, 'sum', {\n    set(val) {return this.counter += val}\n})\nObject.defineProperty(obj, 'sub', {\n    set(val) {return this.counter -= val}\n})\n\nobj.sum = 10\nobj.sub = 5\nconsole.log(obj) // {counter: 5}\nconsole.log(obj.increment) // 6\nconsole.log(obj.decrement) // 5"
  },
  {
    "_id": "64518e2a78a3eb63645a9fc9",
    "parentId": "64518e2a78a3eb63645a9fc8",
    "content_type": "text",
    "order": 0,
    "content_data": "switch...case является альтернативой if...else и представляет собой более наглядный способ выполнения кода в зависимости от переданного условия:"
  },
  {
    "_id": "64518e2a78a3eb63645a9fca",
    "parentId": "64518e2a78a3eb63645a9fc8",
    "content_type": "code",
    "order": 1,
    "content_data": "const calc = (x, y, operator) => {\n    let result\n\n    try {\n        switch (operator) {\n            case '+':\n                result = x + y\n                break\n            case '-':\n                result = x - y\n                break\n            case '*':\n                result = x * y\n                break\n            case '/':\n                result = x / y\n                break\n            default:\n                throw new Error('Некорректная операция')\n        }\n\n        if (isNaN(result)) {\n            throw new Error('Операнды должны быть числами')\n        }\n\n        console.log(result)\n        return result\n    } catch (e) {\n        console.error(e.message)\n    }\n}\n\ncalc(1, 2, '+') // 3\ncalc(3, 4, '*') // 12\ncalc('a', 1, '-') // Операнды должны быть числами\ncalc(5, 6, 'x') // Некорректная операция"
  },
  {
    "_id": "64518e2a78a3eb63645a9fce",
    "parentId": "64518e2a78a3eb63645a9fcd",
    "content_type": "text",
    "order": 0,
    "content_data": "При использовании конструкции switch...case необходимо придерживаться следующих правил:"
  },
  {
    "_id": "64518e2a78a3eb63645a9fcf",
    "parentId": "64518e2a78a3eb63645a9fcd",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "условие может быть числом или строкой",
      "не допускается дублирование значений",
      "инструкция default является опциональной. Если ни для одного блока case не найдено совпадения, выполняется блок default",
      "break используется для остановки цикла",
      "break также является опциональным, но без него выполнение цикла продолжится"
    ]
  },
  {
    "_id": "64518e2a78a3eb63645a9fd3",
    "parentId": "64518e2a78a3eb63645a9fd2",
    "content_type": "text",
    "order": 0,
    "content_data": "Примитивными типами данных (\"примитивами\") в JavaScript являются следующие значения:"
  },
  {
    "_id": "64518e2a78a3eb63645a9fd4",
    "parentId": "64518e2a78a3eb63645a9fd2",
    "content_type": "list",
    "order": 1,
    "content_data": [
      "number для любых чисел: целочисленных или чисел с плавающей точкой, целочисленные значения ограничены диапазоном ±253",
      "bigint для целых чисел произвольной длины",
      "string для строк. Строка может содержать один или больше символов, нет отдельного символьного типа",
      "boolean для true/false",
      "null для неизвестных значений – отдельный тип, имеющий одно значение null",
      "undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined",
      "symbol для уникальных идентификаторов"
    ]
  }
]